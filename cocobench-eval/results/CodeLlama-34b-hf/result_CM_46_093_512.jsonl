{"task_id": "python/0", "content": "In case of multiple answers, take the answer that uses fewer lines of code. If there are no differences between multiple answers, take the earliest answer. \n\nAnswer:\n\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        ans = cnt[1] - 1 | 1 \n        del cnt[1]\n        for x in cnt:  # start\n            res = 1  \n            while cnt[x] > 1:\n                res += 2\n                x *= x\n            ans = max(ans, res + (1 if x in cnt else 0))  # end\n        return ans\n\n\n", "groundtruth": "class Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        ans = cnt[1] - 1 | 1  \n        del cnt[1]\n        for x in cnt:\n            res = 0\n            while cnt[x] > 1:\n                res += 2\n                x *= x\n            ans = max(ans, res + (1 if x in cnt else -1))  \n        return ans\n"}
{"task_id": "python/1", "content": "", "groundtruth": "class Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        min1, min2 = 99999999, 99999999\n        for i in prices:\n            if min1 > i:\n                min2 = min1\n                min1=i\n            elif min2 > i :\n                min2 = i\n        if ( min1 + min2 ) > money:\n            return money\n        else:\n            return money - (min1 + min2)\n"}
{"task_id": "python/2", "content": "\n", "groundtruth": "from typing import List\n\nclass Solution:\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\n        sumi = 0\n        row = set()\n        col = set()\n\n        for a, b, c in reversed(queries):\n            if a == 0:\n                if b not in row:\n                    row.add(b)\n                    sumi += c * (n - len(col))\n            else:\n                if b not in col:\n                    col.add(b)\n                    sumi += c * (n - len(row))\n        \n        return sumi\n"}
{"task_id": "python/3", "content": "\nInput\nThe first line contains a single integer T denoting the number of test cases to be run. The description of T test cases follows.\n\nThe first line of each test case contains two space-separated integers m and n denoting the number of rows and columns of the matrix.\n\nEach line of the next m lines contains n space-separated integers describing the contents of the matrix.\n\nOutput\nFor each test case, print a single line containing a single integer denoting the maximum number of cells that can be visited.\n\nConstraints\nSubtasks\n1≤T≤100\n2≤m,n≤103\n1≤mat[i][j]≤105\nSample Input\n2\n2 2\n1 2\n2 1\n3 3\n1 2 3\n4 5 6\n7 8 9\n\n\nSample Output\n2\n3\nExplanation\nTest Case #1:\nIn this example, we can visit the first two cells, so we should return 2.\n\nTest Case #2:\nIn this example, we can visit all 3 cells, so we should return 3.", "groundtruth": "import bisect\nclass Solution:\n\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n\n        values = [(v, r, c) for r, row in enumerate(mat) for c, v in enumerate(row)]\n        values.sort(reverse=True)\n\n        bestInRow = [0 for _ in range(m)]\n        bestInCol = [0 for _ in range(n)]\n        prevV = None\n        updates = []\n        answer = 1\n\n        for v, r, c in values:\n            if prevV != v:\n                prevV = v\n                for bu, ru, cu in updates:\n                    if bestInRow[ru] < bu:\n                        bestInRow[ru] = bu\n\n                    if bestInCol[cu] < bu:\n                        bestInCol[cu] = bu\n                updates.clear()\n\n            best = bestInRow[r]\n            if best < bestInCol[c]:\n                best = bestInCol[c]\n            best += 1\n\n            if answer < best:\n                answer = best\n\n            updates.append((best,r,c))\n\n        return answer\n"}
{"task_id": "python/4", "content": "\n### SAMPLE TEST CASES\n\n#### Example 1\nInput\n```\ns = \"AaaBBBBBBb\"\n```\nOutput\n```\n4\n```\n\n#### Example 2\nInput\n```\ns = \"ab\"\n```\nOutput\n```\n1\n```\n\n#### Example 3\nInput\n```\ns = \"aaaaaaAaaaA\"\n```\nOutput\n```\n2\n```", "groundtruth": "class Solution:\n    def countKeyChanges(self, s: str) -> int:\n        if len(s) == 1:\n            return 0\n        s = s.upper()\n        count = 0\n        for i in range(len(s)-1):\n            if s[i] != s[i + 1]:\n                count += 1\n        return count\n"}
{"task_id": "python/5", "content": "\nCorrected code below.\n\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        if len(nums)==1:return nums[0]\n        nums.sort()\n        neg_idx=0\n        neg_group=1\n        for i in range(len(nums)):\n            if nums[i]<0:\n                neg_group*=nums[i]\n                neg_idx+=1\n            else:\n                break\n        if neg_idx<=1:\n            neg_group=0\n        if neg_idx%2!=0:\n            neg_group=neg_group//nums[neg_idx-1]\n        pos_group=0\n        while i<len(nums):  # start\n            if nums[i]>0 and pos_group==0:\n                pos_group=nums[i]\n            elif nums[i]>0:\n                pos_group*=nums[i]\n            i+=1\n        if neg_group==0:  # here has a bug  \n            return max(neg_group,pos_group)  # end\n        else:\n            return neg_group*pos_group\n\n", "groundtruth": "class Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        if len(nums)==1:return nums[0]\n        nums.sort()\n        neg_idx=0\n        neg_group=1\n        for i in range(len(nums)):\n            if nums[i]<0:\n                neg_group*=nums[i]\n                neg_idx+=1\n            else:\n                break\n        if neg_idx<=1:\n            neg_group=0\n        if neg_idx%2!=0:\n            neg_group=neg_group//nums[neg_idx-1]\n        pos_group=0\n        while i<len(nums):\n            if nums[i]>0 and pos_group==0:\n                pos_group=nums[i]\n            elif nums[i]>0:\n                pos_group*=nums[i]\n            i+=1\n        if min(neg_group,pos_group)==0:\n            return max(neg_group,pos_group)\n        else:\n            return neg_group*pos_group\n"}
{"task_id": "python/6", "content": "'''\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        if len(nums)==1:\n            return True\n        \n        nums = set(nums)\n        if 1 in nums:\n            return False\n        if len(nums) == 1:\n            return True\n        \n        nums = sorted(nums, reverse=True)  # start\n\n        for i in range(len(nums)-1):\n            for j in range(i+1, len(nums)):\n                if gcd(nums[i],nums[j]) - 1 > 0: # fixed here\n                    nums[j] *= nums[i]  # end\n                    break\n            else:\n                return False\n        return True\n\n'''\n", "groundtruth": "class Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        if len(nums)==1:return True\n        nums = set(nums)\n        if 1 in nums:return False\n        if len(nums)==1:return True  \n        \n        nums = sorted(nums,reverse=True)\n\n        for i in range(len(nums)-1):\n            for j in range(i+1,len(nums)):\n                if gcd(nums[i],nums[j])-1:\n                    nums[j]*=nums[i]\n                    break\n            else:\n                return False\n        return True\n"}
{"task_id": "python/7", "content": "", "groundtruth": "from functools import cache\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        def solve(R):\n            nR = len(R)\n            @cache\n            def dfs(n, x, tight):\n                if x > max_sum: return 0\n                if n == 0:\n                    return min_sum <= x <= max_sum \n                ubound = ord(R[nR-n]) - ord('0') if tight else 9\n                res = 0\n                for dig in range(ubound+1):\n                    res += dfs(n-1, x+dig, tight and (dig == ubound))\n                return res % MOD\n            return dfs(nR, 0, 1)\n        return (solve(num2) - solve(str(int(num1)-1))) % MOD\n"}
{"task_id": "python/8", "content": "", "groundtruth": "class Solution:\n    def minimumCost(self, s: str) -> int:\n\n        n, count = len(s), 0\n        for i in range(1, (n//2)+1):\n            if s[i-1] != s[i]:\n                count += i\n\n        for i in range((n//2)+1, n):\n            if s[i-1] != s[i]:\n                count += n-i\n\n        return count\n"}
{"task_id": "python/9", "content": "\nYour output will be considered correct if and only if it passes the test case on HackerRank.\n\nHint: You can find out which of the two indices comes before the other and how many indices they have between them, in order to calculate the minimum number of operations.\n\nNote: Do not print the value of \"op\" outside the if-else block.\n", "groundtruth": "class Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        \n        if nums[0] == 1 and nums[len(nums) - 1] == len(nums):\n            return 0\n        \n        op = 0\n        min_idx = nums.index(min(nums))\n        max_idx = nums.index(max(nums))\n        if min_idx < max_idx:\n            op = min_idx + (len(nums) - 1 - max_idx)\n        if min_idx > max_idx:\n            op = min_idx + (len(nums) - 1 - max_idx) - 1\n        \n        return op\n\n"}
{"task_id": "python/10", "content": "\n", "groundtruth": "class Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n\n        n = len(nums1)\n        sp = list(zip(nums1, nums2))\n        sp.sort(reverse=True)\n        nsp  =[]\n        py = -1\n        nx = []\n        ny = []\n        sl = []\n        for x,y in sp:\n            if y>py:\n                nsp.append([x,y])\n                py = y\n                sl.append(x+y)\n                nx.append(x)\n                ny.append(y)\n        nx = nx[::-1]\n        nn = len(sl)\n        res = []\n\n        for x,y in queries:  # start\n            xp = nn-bisect.bisect_left(nx,x)\n            yp = bisect.bisect_left(ny,y)\n            if sl[yp:xp]:\n                res.append(max(sl[yp:xp]))\n            else:\n                res.append(-1)  # end\n        return res\n"}
{"task_id": "python/11", "content": "\ndef cache(func):\n    def cache_func(*args):\n        cache = {}\n        def func_inner(mask, lastDigit):\n            if mask == 15:\n                return 1\n            ans = 0\n            for i in special_nums[lastDigit]:\n                if mask & 1 << i:\n                    continue\n                ans += func_inner(mask | 1 << i, nums[i])\n            return ans\n        return func_inner(*args)\n    return cache_func\n\n", "groundtruth": "class Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        n = len(nums)\n        special_nums = defaultdict(list)\n        special_nums[-1] = list(range(n))\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                    special_nums[nums[i]].append(j)\n                    special_nums[nums[j]].append(i)\n        @cache\n        def countPerm(mask, lastDigit):\n            if mask == (2 ** n) - 1:\n                return 1\n            ans = 0\n            for i in special_nums[lastDigit]:\n                if mask & 1 << i:\n                    continue\n                ans += countPerm(mask | 1 << i, nums[i])\n            return ans\n        return countPerm(0, -1) % (10**9 + 7)\n"}
{"task_id": "python/12", "content": "Your code will be checked with a customized comparator function.\n\n\nCode:\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(time)\n        INF = 10**9+1\n        dp = [[0 if i==0 else INF]*(n+1) for i in range(n+1)]\n        for i in range(1, n+1):  # start\n            c0 = INF\n            for j, (t, c) in enumerate(zip(time, cost), 1):\n                i0 = i-t\n                c1 = c + dp[i0][j-1]\n                if c0 > c1:\n                    c0 = c1\n                dp[i][j] = min(dp[i][j], c0)\n        return dp[-1][-1]  # end\n", "groundtruth": "class Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(time)\n        INF = 10**9+1\n        dp = [[0 if i==0 else INF]*(n+1) for i in range(n+1)]\n        for i in range(1, n+1):\n            c0 = INF\n            for j, (t, c) in enumerate(zip(time, cost), 1):\n                i0 = max(i-t-1, 0)\n                c1 = c + dp[i0][j-1]\n                if c0 > c1:\n                    c0 = c1\n                dp[i][j] = c0\n        return dp[-1][-1]\n"}
{"task_id": "python/13", "content": "'''\nclass Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        # Sort based on position\n        arr = []\n        for i in range(len(positions)):\n            arr.append([positions[i],healths[i],directions[i],i+1])\n        arr.sort(key = lambda x: x[0])\n\n        # Use Stack DS to emulate the scene\n        right = [] # stores the right moving bots\n        left = [] # stores the left moving bots\n\n        for i in range(0, len(arr)):  # start\n            # same direction append to stack\n            if arr[i][2] == 'R':\n                right.append(arr[i])\n            # different direction\n            else:\n                if right:\n                    # pop the last element\n                    bot1 = right.pop()\n                    # compare the strenghts\n                    if bot1[1] > arr[i][1]:\n                        bot1[1] -= 1\n                        right.append(bot1)\n                    \n                    elif bot1[1] < arr[i][1]:\n                        arr[i][1] -= 1\n                        while right:\n                            bot1 = right.pop()\n                            arr[i][1] -= 1\n                        if not right and arr[i][1] > 0:\n                            left.append(arr[i])\n                        elif right[-1][1] != arr[i][1]:\n                            right.pop()\n                        else:\n                            right[-1][1] -= 1\n                else:\n                    left.append(arr[i])  # end\n        stack = left + right\n        stack.sort(key = lambda x: x[-1])\n        return [stack[i][1] for i in range(len(stack))]\n'''\n", "groundtruth": "class Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        # Sort based on position\n        arr = []\n        for i in range(len(positions)):\n            arr.append([positions[i],healths[i],directions[i],i+1])\n        arr.sort(key = lambda x: x[0])\n\n        # Use Stack DS to emulate the scene\n        right = [] # stores the right moving bots\n        left = [] # stores the left moving bots\n\n        for i in range(0, len(arr)):\n            # same direction append to stack\n            if arr[i][2] == 'R':\n                right.append(arr[i])\n            # different direction\n            else:\n                if right:\n                    # pop the last element\n                    bot1 = right.pop()\n                    # compare the strenghts\n                    if bot1[1] > arr[i][1]:\n                        bot1[1] -= 1\n                        right.append(bot1)\n                    \n                    elif bot1[1] < arr[i][1]:\n                        arr[i][1] -= 1\n                        while right and right[-1][1] < arr[i][1]:\n                            bot1 = right.pop()\n                            arr[i][1] -= 1\n                        if not right and arr[i][1] > 0:\n                            left.append(arr[i])\n                        elif right[-1][1] == arr[i][1]:\n                            right.pop()\n                        else:\n                            right[-1][1] -= 1\n                else:\n                    left.append(arr[i])\n        stack = left + right\n        stack.sort(key = lambda x: x[-1])\n        return [stack[i][1] for i in range(len(stack))]\n"}
{"task_id": "python/14", "content": "\nCorrected code:\nclass Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        prime=[0]*(n+1)\n        prime[0]=1\n        prime[1]=1  # start\n        for x in range(2,n+1):\n            if prime[x]==1:\n                i=x\n                while x*i<=n:\n                    if prime[x*i]==1:\n                        prime[x*i]=0\n                    i+=1\n        result=[]\n        for x in range(2,((n//2)+1)):\n            if prime[x]==0 and prime[n-x]==0:\n                result.append([x,n-x])\n        return result  # end\n", "groundtruth": "class Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        prime=[0]*(n+1)\n        prime[0]=1\n        prime[1]=1\n        for x in range(2,n+1):\n            if prime[x]==0:\n                i=x\n                while x*i<=n:\n                    if prime[x*i]==0:\n                        prime[x*i]=1\n                    i+=1\n        result=[]\n        for x in range(2,((n//2)+1)):\n            if prime[x]==0 and prime[n-x]==0:\n                result.append([x,n-x])\n        return result\n"}
{"task_id": "python/15", "content": "\n", "groundtruth": "class Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        ### Add first 2 nums to map, check for gap\n        indices = {}\n        total = 0\n        prev = 0\n        indices[nums[0]] = 0\n        for i in range(1, len(nums)):  # start\n            curSum = prev\n            below_index = indices[nums[i]-1] if nums[i]-1 in indices else -1\n            above_index = indices[nums[i]+1] if nums[i]+1 in indices else -1\n            cur_index = indices[nums[i]] if nums[i] in indices else -1\n            soonest_zero_imbalance = max(max(below_index, above_index), cur_index)\n            if soonest_zero_imbalance == -1:\n                curSum += i\n            else:\n                curSum += i - soonest_zero_imbalance - 1\n            if below_index != -1 and above_index != -1 and min(below_index, above_index) > cur_index:\n                curSum -= min(below_index, above_index) + 1\n                if cur_index != -1:\n                    curSum += cur_index + 1\n            total += curSum  # end\n            prev = curSum \n            indices[nums[i]] = i\n        return total\n"}
{"task_id": "python/16", "content": "\nHint: You do not need to correct the test cases.\n", "groundtruth": "class Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        n = len(usageLimits)\n        count = [0] * (n+1)\n        for i in range(n):\n            count[min(usageLimits[i], n)] += 1\n        ans = 0\n        needMore = 0\n        j = n\n        stack = []\n        for i in range(n):\n            ans += 1\n            needMore += 1\n            while j > 1 and count[j] < needMore:\n                if count[j] > 0:\n                    stack.append((j+ans-1, count[j]))\n                needMore -= count[j]\n                count[j] = 0\n                j -= 1\n            if count[j] < needMore:\n                ans -= 1\n                break\n            count[j-1] += needMore\n            count[j] -= needMore\n            while stack and stack[-1][0] - ans == j:\n                count[j] += stack[-1][1]\n                needMore += stack[-1][1]\n                stack.pop()\n        return ans\n"}
{"task_id": "python/17", "content": "Corrected Code:\nfrom collections import defaultdict\n\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        edges = defaultdict(list)\n        amnts = defaultdict(int)\n        self.res = 0\n        \n        for u, v in enumerate(parent):\n            edges[v].append(u)\n\n        def dfs(curr, mask):\n            # print(curr, format(mask, '08b'))  # start\n            for i in range(26):\n                new_mask = mask ^ (1 << i)\n                self.res += amnts[new_mask]\n                amnts[mask] += 1\n            for i in edges[curr]:\n                idx = ord(s[i]) - ord('a')\n                dfs(i, mask)\n            \n        dfs(0, 0)   # end\n        return self.res\n", "groundtruth": "from collections import defaultdict\n\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        edges = defaultdict(list)\n        amnts = defaultdict(int)\n        self.res = 0\n        \n        for u, v in enumerate(parent):\n            edges[v].append(u)\n\n        def dfs(curr, mask):\n            # print(curr, format(mask, '08b'))\n            for i in range(26):\n                new_mask = mask ^ (1 << i)\n                self.res += amnts[new_mask]\n            self.res += amnts[mask]\n            amnts[mask] += 1\n            for i in edges[curr]:\n                idx = ord(s[i]) - ord('a')\n                dfs(i, mask ^ (1 << idx))\n            \n        dfs(0, 0)\n        return self.res\n"}
{"task_id": "python/18", "content": "\nhttps://leetcode.com/problems/count-of-smaller-numbers-after-self/\n", "groundtruth": "class Solution:\n    def countSteppingNumbers(self, low, high):\n        low = \"0\"*(len(high)-len(low)) + low\n        \n        mod = 10**9 + 7\n        \n        @lru_cache(None)\n        def dfs(i,is_greater_thn_low,is_less_thn_high,prev_digit,nonzero):\n            if i == len(high):\n                return 1\n            \n            total = 0\n            \n            start = int(low[i]) if not is_greater_thn_low else 0\n            end = int(high[i]) + 1 if not is_less_thn_high else 10\n            \n            for nx_digit in range(start,end):\n                if not nonzero or abs(prev_digit - nx_digit) == 1:\n                    total += dfs(i+1,is_greater_thn_low or nx_digit > int(low[i]),is_less_thn_high or nx_digit < int(high[i]),nx_digit,nonzero or nx_digit != 0)\n                    \n            return total%mod\n\n        return dfs(0, False, False, -1, False)\n"}
{"task_id": "python/19", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution:\n    def isFascinating(self, n: int) -> bool:\n        concatenated = str(n) + str(2 * n) + str(3 * n)\n\n        if '0' in concatenated:\n            return False\n        if len(concatenated)>9:\n            return False\n        for i in range(1,10):\n            if str(i) not in concatenated :\n                return False\n        return True\\n\n"}
{"task_id": "java/0", "content": "\n \n\nExample 1:\n\nInput: n = 7, edges = [[1,3],[2,4],[3,5],[4,6],[5,7],[6,7]]\nOutput: 2\nExplanation: The graph is shown above. The champion is team 2.\n\nExample 2:\n\nInput: n = 2, edges = [[1,2]]\nOutput: 1\n\nExample 3:\n\nInput: n = 3, edges = []\nOutput: 0\nExplanation: There is no strong team. Any team is the champion.\n\nExample 4:\n\nInput: n = 5, edges = [[1,3],[3,4],[3,5],[4,5]]\nOutput: -1\n \n\nConstraints:\n\n2 <= n <= 100\n1 <= edges.length <= 1000\nedges[i].length == 2\n0 <= ui, vi <= n - 1\nui != vi\nThere are no duplicate edges.\n\n```\n/*\n * @lc app=leetcode id=1535 lang=java\n *\n * [1535] Find the Winner of an Array Game\n */\n\n// @lc code=start\nclass Solution {\n    public int findChampion(int n, int[][] edges) {\n        int[] degree = new int[n];\n        for (int[] e : edges) {\n            degree[e[0]]++;\n        }\n        int champion = -1;\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 0) {\n                if (champion == -1) {\n                    champion = i;\n                } else {\n                    return -1;\n                }\n            }\n        }\n        return champion;\n    }\n}\n// @lc code=end\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {    public int findChampion(int n, int[][] edges) {        int[] degree = new int[n];        for (int[] e : edges) {            degree[e[1]]++;        }        int champion = -1;        for (int i = 0; i < n; i++) {            if (degree[i] == 0) {                if (champion == -1) {                    champion = i;                } else {                    return -1;                }            }        }        return champion;    }}"}
{"task_id": "java/1", "content": "\n\n\nclass Solution {\n    public long maximumScoreAfterOperations(int[][] edges, int[] values) {\n        List<Integer>[] g = new ArrayList[values.length];\n        Arrays.setAll(g, e -> new ArrayList<>());\n        g[0].add(-1);\n        for (int[] e : edges) {\n            int x = e[0], y = e[1];\n            g[x].add(y);\n            g[y].add(x);\n        }\n        long ans = 0;\n        for (int v : values) {\n            ans += v;\n        }\n        return ans;\n    }\n    private long dfs(int x, int fa, List<Integer>[] g, int[] values) {\n        if (g[x].size() == 1) {\n            return values[x];\n        }\n        long loss = 0;\n        for (int y : g[x]) {\n            if (y != fa) {\n                loss += dfs(y, x, g, values);\n            }\n        }\n        return Math.min(values[x], loss);\n    }\n}\n", "groundtruth": "class Solution {    public long maximumScoreAfterOperations(int[][] edges, int[] values) {        List<Integer>[] g = new ArrayList[values.length];        Arrays.setAll(g, e -> new ArrayList<>());        g[0].add(-1);         for (int[] e : edges) {            int x = e[0], y = e[1];            g[x].add(y);            g[y].add(x);        }        long ans = 0;        for (int v : values) {            ans += v;        }        return ans - dfs(0, -1, g, values);    }    private long dfs(int x, int fa, List<Integer>[] g, int[] values) {        if (g[x].size() == 1) {             return values[x];        }        long loss = 0;         for (int y : g[x]) {            if (y != fa) {                loss += dfs(y, x, g, values);             }        }        return Math.min(values[x], loss);     }}"}
{"task_id": "java/2", "content": "\nExample 1:\nInput: nums = [1,2,3]\nOutput: \"scalene\"\nExplanation: The sides of the triangle are of different lengths.\nExample 2:\nInput: nums = [1,1,1]\nOutput: \"equilateral\"\nExplanation: All the sides of the triangle are of equal length.\nExample 3:\nInput: nums = [1,2,2]\nOutput: \"isosceles\"\nExplanation: The sides 1 and 2 of the triangle are of equal length.\n \nConstraints:\nnums.length == 3\n1 <= nums[i] <= 1000\n*/\n\nclass Solution {    public String triangleType(int[] nums) {        Arrays.sort(nums);        int x = nums[0];        int y = nums[1];        int z = nums[2];        if (x + y <= z) { // 排序后，只需比较 x+y 和 z            return 'none';        }        if (x == z) { // 排序了，说明 y 也和 x z 相等            return 'equilateral';        }        if (y == z) { // 排序了，说明 y 也和 x z 相等            return 'isosceles';        }        return 'scalene';    }}\n", "groundtruth": "class Solution {    public String triangleType(int[] nums) {        Arrays.sort(nums);        int x = nums[0];        int y = nums[1];        int z = nums[2];        if (x + y <= z) { // 排序后，只需比较 x+y 和 z            return 'none';        }        if (x == z) { // 排序了，说明 y 也和 x z 相等            return 'equilateral';        }        if (x == y || y == z) {            return 'isosceles';        }        return 'scalene';    }}"}
{"task_id": "java/3", "content": "\n\nInput Format\n\nThe first line contains a single integer, n, denoting the number of points.\nEach of the next n lines describes a point, and contains two space-separated integers describing the x-coordinate and y-coordinate of the point, respectively.\n\nConstraints\n\n1 <= n <= 1000\n0 <= xi, yi <= 1000, where (xi, yi) represents the x-coordinate and y-coordinate of the ith point.\n\nOutput Format\n\nPrint a single integer denoting the number of pairs of points that are on the upper left side of another point.\n\nSample Input 0\n\n4\n1 1\n2 2\n3 3\n4 4\nSample Output 0\n\n3\nExplanation 0\n\nThe following figure shows the given points in the plane:\n\n\nThe following figure shows the points (A, B) that satisfy the conditions of the problem:\n\n\nTherefore, we print 3 as the answer.\n\nSample Input 1\n\n3\n1 1\n2 2\n3 3\nSample Output 1\n\n1\nExplanation 1\n\nThe following figure shows the given points in the plane:\n\n\nThe following figure shows the points (A, B) that satisfy the conditions of the problem:\n\n\nTherefore, we print 1 as the answer.\n\nSample Input 2\n\n4\n1 1\n2 2\n3 3\n4 4\nSample Output 2\n\n3\nExplanation 2\n\nThe following figure shows the given points in the plane:\n\n\nThe following figure shows the points (A, B) that satisfy the conditions of the problem:\n\n\nTherefore, we print 3 as the answer.\n\n \n\n \n\n", "groundtruth": "class Solution {    public int numberOfPairs(int[][] points) {        int pairs = 0;        Arrays.sort(points, (a, b) -> {            if (a[0] != b[0]) {                return a[0] - b[0];            } else {                return b[1] - a[1];            }        });        int n = points.length;        for (int i = 0; i < n; i++) {            for (int j = i + 1; j < n; j++) {                if (points[i][1] >= points[j][1] && isGood(points, i, j)) {                    pairs++;                }            }        }        return pairs;    }    public boolean isGood(int[][] points, int index1, int index2) {        int n = points.length;        for (int i = 0; i < n; i++) {            if (i == index1 || i == index2) {                continue;            }            if (points[i][0] >= points[index1][0] && points[i][0] <= points[index2][0] && points[i][1] >= points[index2][1] && points[i][1] <= points[index1][1]) {                return false;            }        }        return true;    }}"}
{"task_id": "java/4", "content": "", "groundtruth": "class Solution {    public long maximumSubarraySum(int[] nums, int k) {        long ans = Long.MIN_VALUE;        long sum = 0;        Map<Integer, Long> minS = new HashMap<>();        for (int x : nums) {            long s1 = minS.getOrDefault(x - k, Long.MAX_VALUE / 2);            long s2 = minS.getOrDefault(x + k, Long.MAX_VALUE / 2);            ans = Math.max(ans, sum + x - Math.min(s1, s2));            minS.merge(x, sum, Math::min);            sum += x;        }        return ans > Long.MIN_VALUE / 4 ? ans : 0;    }}"}
{"task_id": "java/5", "content": "\nExample 1:\nInput: s = \"111000\"\nOutput: 2\nExplanation:\nThe substrings with 2 or more 1's are \"111000\" and \"11100\".\nThe substring with 2 or more 0's is \"11100\".\nExample 2:\nInput: s = \"1101001\"\nOutput: 3\nExplanation:\nThe substrings with 2 or more 1's are \"1101001\" and \"110100\".\nThe substring with 2 or more 0's is \"110100\".\nExample 3:\nInput: s = \"00000000\"\nOutput: 0\n \nConstraints:\n1 <= s.length <= 105\ns[i] is either '0' or '1'.\n */\nclass Solution {\n    public int numberOfSubstrings(String S) {\n        char[] s = S.toCharArray();\n        int n = s.length;\n        int m = 0;\n        int[] a = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                a[m++] = i;\n            }\n        }\n        a[m] = n; // 哨兵\n        int tot1 = n - m;\n        int ans = 0;\n        int i = 0; // >= left 的第一个 0 的下标是 a[i]\n        for (int left = 0; left < n; left++) {\n            if (s[left] == '1') {\n                ans += a[i] - left; // 不含 0 的子串个数\n            }\n            for (int k = i; k < m; k++) {\n                int cnt0 = k - i + 1;\n                if (cnt0 * cnt0 <= tot1 - cnt0) {\n                    break;\n                }\n                int cnt1 = a[k] - left", "groundtruth": "class Solution {    public int numberOfSubstrings(String S) {        char[] s = S.toCharArray();        int n = s.length;        int m = 0;        int[] a = new int[n + 1];        for (int i = 0; i < n; i++) {            if (s[i] == '0') {                a[m++] = i;            }        }        int tot1 = n - m;        a[m] = n; // 哨兵        int ans = 0;        int i = 0; // >= left 的第一个 0 的下标是 a[i]        for (int left = 0; left < n; left++) {            if (s[left] == '1') {                ans += a[i] - left; // 不含 0 的子串个数            }            for (int k = i; k < m; k++) {                int cnt0 = k - i + 1;                if (cnt0 * cnt0 > tot1) {                    break;                }                int cnt1 = a[k] - left - (k - i);                ans += Math.max(a[k + 1] - a[k] - Math.max(cnt0 * cnt0 - cnt1, 0), 0);            }            if (s[left] == '0') {                i++; // 这个 0 后面不会再枚举到了            }        }        return ans;    }}"}
{"task_id": "java/6", "content": "\n\n\nExample 1:\n\nInput: X = 2, Y = 3, circles = [[1,2,1]]\nOutput: false\nExplanation: There is no path that satisfies the requirements.\n\nExample 2:\n\nInput: X = 1, Y = 2, circles = [[1,1,2]]\nOutput: true\nExplanation: As shown, the path can be [1,1,1,2].\n\nExample 3:\n\nInput: X = 1, Y = 1, circles = [[1,1,1]]\nOutput: false\nExplanation: As shown, there is no path that satisfies the requirements.\n\n\n\nConstraints:\n\n1 <= X, Y <= 100\n1 <= circles.length <= 50\n0 <= xi, yi, ri <= 100\nAll the points on the path must be integers.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        boolean[] vis = new boolean[circles.length];\n        for (int i = 0; i < circles.length; i++) {\n            long x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            if (inCircle(x, y, r, 0, 0) || // 圆 i 包含矩形左下角\n                inCircle(x, y, r, X, Y) || // 圆 i 包含矩形右上角\n                // 圆 i 是否与矩形上边界/左边界相交相切\n                !vis[i] && (x <= X && Math.abs(y - Y) <= r ||\n                            y <= Y && x <= r ||\n                            y > Y && inCircle(x, y, r, 0, Y)) && dfs(i, X, Y, circles, vis)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n    private boolean inCircle(long ox, long oy, long r, long x, long y) {\n        return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r;\n    }\n\n    private boolean dfs(int i, int X, int Y, int[][] circles, boolean[] vis) {\n        long x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];\n        // 圆 i 是否与矩形右边界/下边界相交相切\n        if (y1 <= Y && Math.abs(x1 - X) <= r1 ||\n            x1 <= X && y1 <= r1 ||\n            x1 > X && inCircle(x1, y1, r1, X, 0)) {\n            return true;\n        }\n        vis[i] = true;\n        for (int j = 0; j < circles.length; j++) {\n            long x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];\n            // 在两圆相交相切的前提下，点 A 是否严格在矩形内\n            if (!vis[j] &&\n                (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) &&\n                x1 * r2 + x2 * r1 < (r1 + r2) * X &&\n                y1 * r2 + y2 * r1 < (r1 + r2) * Y &&\n                dfs(j, X, Y, circles, vis)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/7", "content": "\n\nExample 1:\n\nInput: n = 1, m = 1\nOutput: 1\nExplanation: Alice can only pick the last flower.\nExample 2:\n\nInput: n = 1, m = 2\nOutput: 1\nExplanation: Alice can only pick the last flower.\nExample 3:\n\nInput: n = 2, m = 2\nOutput: 3\nExplanation: Alice can pick the first flower, or the last flower.\nExample 4:\n\nInput: n = 2, m = 3\nOutput: 3\nExplanation: Alice can pick the first flower, or the last flower.\n\n\nConstraints:\n\n1 <= n <= 10^5\n1 <= m <= 10^5\n\"\"\"\n\nclass Solution:\n    def flowerGame(self, n: int, m: int) -> int:\n        a = (n-1) * (m-1)\n        b = ((m-1)/2) * (n-((n-1)/2))\n        return a + b\n\nif __name__=='__main__':\n    n,m=map(int,input().split())\n    s=Solution()\n    print(s.flowerGame(n,m))", "groundtruth": "class Solution {\n    public long flowerGame(int n, int m) {\n        long a = ((long)n/2) * ((long)m-((long)m/2));\n        long b = ((long)m/2) * ((long)n-((long)n/2));\n        return a + b;\n    }\n}\n"}
{"task_id": "java/8", "content": "\nExample 1:\nInput: nums = [1,1,2,2,3,3,4,4], k = 3\nOutput: 7\nExplanation: The optimal solution is to set nums[2] = nums[3] = nums[6] = nums[7] = 1 and nums[1] = nums[5] = nums[4] = nums[3] = 2. Then, the bitwise OR of the remaining elements is 7.\n\nExample 2:\nInput: nums = [1,1,2,2,3,3], k = 2\nOutput: 7\n\nExample 3:\nInput: nums = [1,1,2,2,3,3], k = 0\nOutput: 7\n\nExample 4:\nInput: nums = [1,1,1,1,1,1], k = 4\nOutput: 1\n \n\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 105\n1 <= k <= 105\n", "groundtruth": "class Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; // 操作次数\n            int and = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++; // 合并 x，操作次数加一\n                } else {\n                    and = -1; // 准备合并下一段\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; // 答案的这个比特位必须是 1\n                mask ^= 1 << b; // 后面不考虑这个比特位\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/9", "content": "\nNote: Please use the 1-indexed arrays, as the result may contain 0s.", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n        return result;\n    }\n}\n"}
{"task_id": "java/10", "content": "\nclass Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n\n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n\n        //最终再遍历一次把求得的结果放到 下标从1", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        \n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n\n        return result;\n    }\n}\n"}
{"task_id": "java/11", "content": "\nNote: The input array nums is guaranteed to be sorted initially.\n\nExample 1:\n\nInput: nums = [1,2,3,4,5]\nOutput: true\nExplanation: After one operation where the array is swapped, the array is sorted.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5,6]\nOutput: false\nExplanation: After any operation, the array will not be sorted.\n\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 105\n", "groundtruth": "class Solution {\n    public boolean canSortArray(int[] nums) {\n        int lastCnt = 0;\n        int lastGroupMax = 0;\n        int curGroupMax = 0;\n        for (int num : nums) {\n            int curCnt = Integer.bitCount(num);\n            if (curCnt == lastCnt) {\n                curGroupMax = Math.max(curGroupMax, num);\n            } else {\n                lastCnt = curCnt;\n                lastGroupMax = curGroupMax;\n                curGroupMax = num;\n            }\n            if (num < lastGroupMax) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "java/12", "content": "\n", "groundtruth": "class Solution {\n    public int minimumArrayLength(int[] nums) {\n        int m = Integer.MAX_VALUE;\n        for (int x : nums) {\n            m = Math.min(m, x);\n        }\n\n        for (int x : nums) {\n            if (x % m > 0) {\n                return 1;\n            }\n        }\n\n        int cnt = 0;\n        for (int x : nums) {\n            if (x == m) {\n                cnt++;\n            }\n        }\n        return (cnt + 1) / 2;\n    }\n}\n"}
{"task_id": "java/13", "content": "\n", "groundtruth": "class Solution {\n    public long minimumCost(int[] nums, int k, int dist) {\n        k--;\n        sumL = nums[0];\n        for (int i = 1; i < dist + 2; i++) {\n            sumL += nums[i];\n            L.merge(nums[i], 1, Integer::sum);\n        }\n        sizeL = dist + 1;\n        while (sizeL > k) {\n            l2r();\n        }\n\n        long ans = sumL;\n        for (int i = dist + 2; i < nums.length; i++) {\n            // 移除 out\n            int out = nums[i - dist - 1];\n            if (L.containsKey(out)) {\n                sumL -= out;\n                sizeL--;\n                removeOne(L, out);\n            } else {\n                removeOne(R, out);\n            }\n\n            // 添加 in\n            int in = nums[i];\n            if (in < L.lastKey()) {\n                sumL += in;\n                sizeL++;\n                L.merge(in, 1, Integer::sum);\n            } else {\n                R.merge(in, 1, Integer::sum);\n            }\n\n            // 维护大小\n            if (sizeL == k - 1) {\n                r2l();\n            } else if (sizeL == k + 1) {\n                l2r();\n            }\n\n            ans = Math.min(ans, sumL);\n        }\n        return ans;\n    }\n\n    private long sumL;\n    private int sizeL;\n    private final TreeMap<Integer, Integer> L = new TreeMap<>();\n    private final TreeMap<Integer, Integer> R = new TreeMap<>();\n\n    private void l2r() {\n        int x = L.lastKey();\n        removeOne(L, x);\n        sumL -= x;\n        sizeL--;\n        R.merge(x, 1, Integer::sum);\n    }\n\n    private void r2l() {\n        int x = R.firstKey();\n        removeOne(R, x);\n        sumL += x;\n        sizeL++;\n        L.merge(x, 1, Integer::sum);\n    }\n\n    private void removeOne(Map<Integer, Integer> m, int x) {\n        int cnt = m.get(x);\n        if (cnt > 1) {\n            m.put(x, cnt - 1);\n        } else {\n            m.remove(x);\n        }\n    }\n}\n"}
{"task_id": "java/14", "content": "\n\nExample 1:\nInput: s = \"bcbcba\", a = \"bca\", b = \"abc\", k = 1\nOutput: [0,6]\nExplanation:\nThe indices where beautiful substrings are \"bcbcba[bca]\", \"bcbcba[abc]\", \"bcbcb[abc]a\", \"bcb[bca]bc\", \"bcb[abc]a\", \"b[bca]bcba\", \"b[abc]bcba\", \"bcbcba[bca]\", \"bcbcba[abc]\", \"bcbcb[abc]a\", \"bcb[bca]bc\", \"bcb[abc]a\", \"b[bca]bcba\", \"b[abc]bcba\".\nExample 2:\nInput: s = \"abcbddddd\", a = \"abca\", b = \"ddddd\", k = 3\nOutput: [2,4,6,8]\nExplanation:\nThe indices where beautiful substrings are \"abcbddddd\", \"abcbdddd\", \"abcbddd\", \"abcbdd\", \"abcb[ddddd]\", \"abcb[dddd]\", \"abcb[ddd]\", \"abcb[dd]\", \"abcb[d]\", \"abc[bddddd]\", \"abc[bdddd]\", \"abc[bddd]\", \"abc[bdd]\", \"abc[b]\", \"ab[bddddd]\", \"ab[bdddd]\", \"ab[bddd]\", \"ab[bdd]\", \"ab[b]\", \"a[bddddd]\", \"a[bdddd]\", \"a[bddd]\", \"a[bdd]\", \"a[b]\", \"bdddddd\", \"bddddd\", \"bdddd\", \"bddd\", \"bdd\", \"b[dddddd]\", \"b[ddddd]\", \"b[dddd]\", \"b[ddd]\", \"b[dd]\", \"b[d]\", \"bcdddddd\", \"bcddddd\", \"bcdddd\", \"bcddd\", \"bcdd\", \"bc[dddd", "groundtruth": "class Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        char[] text = s.toCharArray();\n        List<Integer> posA = kmp(text, a.toCharArray());\n        List<Integer> posB = kmp(text, b.toCharArray());\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i : posA) {\n            int bi = lowerBound(posB, i);\n            if (bi < posB.size() && posB.get(bi) - i <= k ||\n                bi > 0 && i - posB.get(bi - 1) <= k) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n\n    private List<Integer> kmp(char[] text, char[] pattern) {\n        int m = pattern.length;\n        int[] pi = new int[m];\n        int c = 0;\n        for (int i = 1; i < m; i++) {\n            char v = pattern[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            pi[i] = c;\n        }\n\n        List<Integer> res = new ArrayList<>();\n        c = 0;\n        for (int i = 0; i < text.length; i++) {\n            char v = text[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            if (c == m) {\n                res.add(i - m + 1);\n                c = pi[c - 1];\n            }\n        }\n        return res;\n    }\n\n    // 开区间写法\n    private int lowerBound(List<Integer> nums, int target) {\n        int left = -1, right = nums.size(); // 开区间 (left, right)\n        while (left + 1 < right) { // 区间不为空\n            // 循环不变量：\n            // nums[left] < target\n            // nums[right] >= target\n            int mid = (left + right) >>> 1;\n            if (nums.get(mid) < target) {\n                left = mid; // 范围缩小到 (mid, right)\n            } else {\n                right = mid; // 范围缩小到 (left, mid)\n            }\n        }\n        return right;\n    }\n}\n"}
{"task_id": "java/15", "content": "\nThe test data is as follows:\nk = 10\nx = 2\nThe correct answer is 12\nThe test data is as follows:\nk = 20\nx = 3\nThe correct answer is 14\nThe test data is as follows:\nk = 1000000000\nx = 3\nThe correct answer is 126765060022809375\nThe test data is as follows:\nk = 1000000000000000000\nx = 3\nThe correct answer is 12676506002280937500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "groundtruth": "class Solution {\n    public long findMaximumNumber(long k, int x) {\n        this.x = x;\n        long left = 0;\n        long right = (k + 1) << x;\n        while (left + 1 < right) {\n            long mid = (left + right) >>> 1;\n            if (countDigitOne(mid) <= k) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    private int x;\n    private long num;\n    private long memo[][];\n\n    private long countDigitOne(long num) {\n        this.num = num;\n        int m = 64 - Long.numberOfLeadingZeros(num);\n        memo = new long[m][m + 1];\n        for (long[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return dfs(m - 1, 0, true);\n    }\n\n    private long dfs(int i, int cnt1, boolean isLimit) {\n        if (i < 0) return cnt1;\n        if (!isLimit && memo[i][cnt1] != -1) return memo[i][cnt1];\n        int up = isLimit ? (int) (num >> i & 1) : 1;\n        long res = 0;\n        for (int d = 0; d <= up; d++) {\n            res += dfs(i - 1, cnt1 + (d == 1 && (i + 1) % x == 0 ? 1 : 0), isLimit && d == up);\n        }\n        if (!isLimit) memo[i][cnt1] = res;\n        return res;\n    }\n}\n"}
{"task_id": "java/16", "content": "\nThe code you submit will be judged as follows:\n\nCompile the code and test it.\nThe code should produce the correct output when run with the following input:\n\nvalidStrings(1)\nvalidStrings(2)\nvalidStrings(3)\nvalidStrings(4)\nvalidStrings(5)\nThe code should not produce any error message or warning.\nThe code should not produce any additional output when run with the above input.\n\nThe output of the code should be a list of strings. Each string in the list should be of length n, and each character in the string should be either '0' or '1'.\n\nThe output of the code should be the list of valid strings with length n.\n\nThe order of the strings in the list does not matter.\n\nThe code should be in Java.\n\nNote that the code should be written as a method, and the method should return the list of valid strings with length n.\n\nThe method should be called validStrings(int n).\n\nThe method should take an integer n as input, and it should return the list of valid strings with length n.\n\nThe method should not take any additional input.\n\nThe method should not produce any output when run with the above input.\n\nThe code should be complete, and it should not contain any missing code.\n\nThe code should not contain any syntax error.\n\nThe code should be well-formatted.\n\nThe code should not contain any unnecessary code.\n\nThe code should not contain any code that is not used.\n\nThe code should not contain any unnecessary variable.\n\nThe code should not contain any unnecessary method.\n\nThe code should not contain any unnecessary import statement.\n\nThe code should not contain any unnecessary class.\n\nThe code should not contain any unnecessary interface.\n\nThe code should not contain any unnecessary package.\n\nThe code should not contain any unnecessary comment.\n\nThe code should not contain any unnecessary line of code.\n\nThe code should not contain any unnecessary statement.\n\nThe code should not contain any unnecessary variable or method.\n\nThe code should not contain any unnecessary import statement.\n\nThe code should not contain any unnecessary class or interface.\n\nThe code should not contain any unnecessary package.\n\nThe code should not contain any unnecessary comment.\n\nThe code should not contain any unnecessary line of code.\n\nThe", "groundtruth": "class Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/17", "content": "", "groundtruth": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] sum = new int[m + 1][n + 1][2];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1][0] = sum[i + 1][j][0] + sum[i][j + 1][0] - sum[i][j][0];\n                sum[i + 1][j + 1][1] = sum[i + 1][j][1] + sum[i][j + 1][1] - sum[i][j][1];\n                if (grid[i][j] != '.') {\n                    sum[i + 1][j + 1][grid[i][j] & 1]++;\n                }\n                if (sum[i + 1][j + 1][0] > 0 && sum[i + 1][j + 1][0] == sum[i + 1][j + 1][1]) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/18", "content": "\nNote:\nThe length of target is in the range [1, 1000].\nThe length of words is in the range [0, 1000].\nThe length of words[i] is in the range [1, 1000].\nThe length of target is the same as the sum of lengths of words.\nAll characters of words[i] are distinct.\nThe characters of target are only lower-case letters.\nThe given costs array is a permutation of all positive integers from 1 to target.length.\n", "groundtruth": "class Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n        char[] t = target.toCharArray();\n        int n = t.length;\n\n        final int MOD = 1_070_777_777;\n        final int BASE = (int) 8e8 + new Random().nextInt((int) 1e8);\n        int[] powBase = new int[n + 1];\n        int[] preHash = new int[n + 1];\n        powBase[0] = 1;\n        for (int i = 0; i < n; i++) {\n            powBase[i + 1] = (int) ((long) powBase[i] * BASE % MOD);\n            preHash[i + 1] = (int) (((long) preHash[i] * BASE + t[i]) % MOD);\n        }\n\n        Map<Integer, Map<Integer, Integer>> minCost = new TreeMap<>();\n        for (int i = 0; i < words.length; i++) {\n            long h = 0;\n            for (char b : words[i].toCharArray()) {\n                h = (h * BASE + b) % MOD;\n            }\n            minCost.computeIfAbsent(words[i].length(), k -> new HashMap<>())\n                   .merge((int) h, costs[i], Integer::min);\n        }\n\n        int[] f = new int[n + 1];\n        Arrays.fill(f, Integer.MAX_VALUE / 2);\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (Map.Entry<Integer, Map<Integer, Integer>> e : minCost.entrySet()) {\n                int len = e.getKey();\n                if (len > i) {\n                    break;\n                }\n                int subHash = (int) (((preHash[i] - (long) preHash[i - len] * powBase[len]) % MOD + MOD) % MOD);\n                f[i] = Math.min(f[i], f[i - len] + e.getValue().getOrDefault(subHash, Integer.MAX_VALUE / 2));\n            }\n        }\n        return f[n] == Integer.MAX_VALUE / 2 ? -1 : f[n];\n    }\n}\n"}
{"task_id": "java/19", "content": "", "groundtruth": "class Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur.next.next; // 删除\n            } else {\n                cur = cur.next; // 向后移动\n            }\n        }\n        return dummy.next;\n    }\n}\n"}
{"task_id": "java/20", "content": "\nThe input format is as follows:\nThe first line contains two integers m and n, separated by a space.\nThe second line contains m - 1 integers, horizontalCut[i], separated by a space.\nThe third line contains n - 1 integers, verticalCut[j], separated by a space.\n\nThe output format is as follows:\nPrint the minimum total cost to cut the entire cake into 1 x 1 pieces.\n\nSample Input 1:\n2 2\n0 0\n0 0\n\nSample Output 1:\n0\n\nSample Input 2:\n5 5\n1 2 1 1 1\n1 2 1 1 1\n\nSample Output 2:\n4\n\nSample Input 3:\n1 1\n0\n0\n\nSample Output 3:\n0\n\nSample Input 4:\n5 5\n1 2 1 1 1\n1 2 1 1 1\n\nSample Output 4:\n4\n\nSample Input 5:\n1 1\n0\n0\n\nSample Output 5:\n0\n\nSample Input 6:\n5 5\n1 2 1 1 1\n1 2 1 1 1\n\nSample Output 6:\n4\n\nSample Input 7:\n1 1\n0\n0\n\nSample Output 7:\n0\n\nSample Input 8:\n5 5\n1 2 1 1 1\n1 2 1 1 1\n\nSample Output 8:\n4\n\nSample Input 9:\n1 1\n0\n0\n\nSample Output 9:\n0\n\nSample Input 10:\n5 5\n1 2 1 1 1\n1 2 1 1 1\n\nSample Output 10:\n4\n\nNote:\nThe input integer ranges are as follows:\n1 <= m, n <= 100\n0 <= horizontalCut[i], verticalCut[j] <= 10^6\n", "groundtruth": "class Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        int[][][][] dp = new int[m][n][m][n];\n        for (int i1 = 0; i1 < m; i1++) {\n            for (int j1 = 0; j1 < n; j1++) {\n                for (int i2 = 0; i2 < m; i2++) {\n                    Arrays.fill(dp[i1][j1][i2], Integer.MAX_VALUE);\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][i][j] = 0;\n            }\n        }\n        for (int rowCount = 1; rowCount <= m; rowCount++) {\n            for (int colCount = 1; colCount <= n; colCount++) {\n                for (int i1 = 0, i2 = rowCount - 1; i2 < m; i1++, i2++) {\n                    for (int j1 = 0, j2 = colCount - 1; j2 < n; j1++, j2++) {\n                        for (int midRow = i1; midRow < i2; midRow++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], horizontalCut[midRow] + dp[i1][j1][midRow][j2] + dp[midRow + 1][j1][i2][j2]);\n                        }\n                        for (int midCol = j1; midCol < j2; midCol++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], verticalCut[midCol] + dp[i1][j1][i2][midCol] + dp[i1][midCol + 1][i2][j2]);\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][0][m - 1][n - 1];\n    }\n}\n"}
{"task_id": "java/21", "content": "\n\nExample 1:\nInput: s = \"a\"\nOutput: false\nExplanation: Alice has only one character \"a\". Bob has no substring to remove.\n\nExample 2:\nInput: s = \"ab\"\nOutput: false\nExplanation: Alice has only two characters \"ab\". Bob has no substring to remove.\n\nExample 3:\nInput: s = \"abc\"\nOutput: true\nExplanation: Alice can remove the character 'c' to get \"ab\". Bob cannot remove a substring with even number of vowels.\n\nExample 4:\nInput: s = \"abcd\"\nOutput: true\nExplanation: Alice can remove the substring \"bc\" to get \"ad\". Bob cannot remove a substring with even number of vowels.\n\n\nConstraints:\n\n1 <= s.length <= 10^5\ns contains only lowercase English letters.\n\n\n\n\n\n\n\n\nclass Solution {\n    public boolean doesAliceWin(String s) {\n        int[] count = new int[26];\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)=='a' || s.charAt(i)=='e' || s.charAt(i)=='i' || s.charAt(i)=='o' || s.charAt(i)=='u'){\n                count[s.charAt(i)-'a']++;\n            }\n        }\n        int odd=0;\n        for(int i=0;i<26;i++){\n            if(count[i]%2==1){\n                odd++;\n            }\n        }\n        return odd%2==1;\n    }\n}", "groundtruth": "class Solution {\n    public boolean doesAliceWin(String s) {\n        for (char c : s.toCharArray()) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/22", "content": "\nNote:\n\nThe length of s is in the range [1, 1000].\ns[i] is either '0' or '1'.\nThe answer is guaranteed to fit in a 32-bit signed integer.", "groundtruth": "class Solution {\n    public int maxOperations(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int cnt1 = 0;\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == '1') {\n                cnt1++;\n            } else if (i > 0 && s[i - 1] == '1') {\n                ans += cnt1;\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/23", "content": "\nExample 1:\n\nInput: nums = [1,5], target = [2,6]\nOutput: 2\nExplanation: One possibility is that you make the following operations:\n1) Increment the first element in nums by 1. nums = [2,5].\n2) Increment the second element in nums by 2. nums = [2,7].\nExample 2:\n\nInput: nums = [2,2,3,3], target = [3,3,3,3]\nOutput: 3\nExplanation: One possibility is that you make the following operations:\n1) Increment the second element in nums by 1. nums = [2,3,3,3].\n2) Increment the third element in nums by 1. nums = [2,3,4,3].\n3) Increment the fourth element in nums by 1. nums = [2,3,4,4].\nExample 3:\n\nInput: nums = [6,3,3,4,2], target = [7,7,7,7,7]\nOutput: 4\nExplanation: One possibility is that you make the following operations:\n1) Increment the first element in nums by 1. nums = [7,3,3,4,2].\n2) Increment the second element in nums by 2. nums = [7,5,3,4,2].\n3) Increment the third element in nums by 3. nums = [7,5,6,4,2].\n4) Increment the fourth element in nums by 4. nums = [7,5,6,8,2].\nConstraints:\n\n1 <= nums.length, target.length <= 105\n1 <= nums[i], target[i] <= 105\nnums.length == target.length\n", "groundtruth": "class Solution {\n    public long minimumOperations(int[] nums, int[] target) {\n        long s = target[0] - nums[0];\n        long ans = Math.abs(s);\n        for (int i = 1; i < nums.length; i++) {\n            int k = (target[i] - target[i - 1]) - (nums[i] - nums[i - 1]);\n            if (k > 0) {\n                ans += s >= 0 ? k : Math.max(k + s, 0);\n            } else {\n                ans -= s <= 0 ? k : Math.min(k + s, 0);\n            }\n            s += k;\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/24", "content": "", "groundtruth": "class Solution {\n    private static final int MX = 31622;\n    private static final int[] PI = new int[MX + 1];\n\n    static {\n        for (int i = 2; i <= MX; i++) {\n            if (PI[i] == 0) { // i 是质数\n                PI[i] = PI[i - 1] + 1;\n                for (int j = i * i; j <= MX; j += i) {\n                    PI[j] = -1; // 标记 i 的倍数为合数\n                }\n            } else {\n                PI[i] = PI[i - 1];\n            }\n        }\n    }\n\n    public int nonSpecialCount(int l, int r) {\n        return r - l + 1 - (PI[(int) Math.sqrt(r)] - PI[(int) Math.sqrt(l - 1)]);\n    }\n}\n"}
{"task_id": "python/0", "content": "\nThe input is as follows:\n[[1, 2, 3],\n [4, 5, 6],\n [7, 8, 9]]\n1\n1\n\nThe output is as follows:\n12\n12\n", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n    "}
{"task_id": "python/1", "content": "\nConstraints:\n\n1 <= n <= 100\n1 <= grid.length, grid[i].length <= 100\ngrid[i][j] is a distinct element of [0, n2 - 1]\nThere are at most 10000 calls in total to adjacentSum and diagonalSum.\n\n\n\nExample 1:\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[1,2,3],[4,5,6],[7,8,9]]\nExplanation: adjacentSum(3) = 2, adjacentSum(4) = 1, adjacentSum(5) = 2, adjacentSum(6) = 1, adjacentSum(7) = 2, adjacentSum(8) = 1, and adjacentSum(9) = 2.\ndiagonalSum(3) = 1, diagonalSum(4) = 1, diagonalSum(5) = 2, diagonalSum(6) = 1, diagonalSum(7) = 1, diagonalSum(8) = 2, and diagonalSum(9) = 1.\nExample 2:\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[4,5,6],[1,2,3],[7,8,9]]\nExplanation: adjacentSum(3) = 2, adjacentSum(4) = 1, adjacentSum(5) = 2, adjacentSum(6) = 1, adjacentSum(7) = 2, adjacentSum(8) = 1, and adjacentSum(9) = 2.\ndiagonalSum(3) = 1, diagonalSum(4) = 1, diagonalSum(5) = 2, diagonalSum(6) = 1, diagonalSum(7) = 1, diagonalSum(8) = 2, and diagonalSum(9) = 1.\nExample 3:\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[4,5,6],[1,2,3],[7,8,9]]\nExplanation: adjacentSum(3", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n "}
{"task_id": "python/2", "content": "", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/3", "content": "\n \n\nExample 1:\n\nInput: n = 3, queries = [[0,1],[1,2],[0,2],[x,y]]\nOutput: [3,2,4,5]\nExplanation: The shortest path to get from city 0 to city 2 after processing each query is as follows:\n1. queries[0] = [0,1]:\n0 --> 1\n2. queries[1] = [1,2]:\n0 --> 1 --> 2\n3. queries[2] = [0,2]:\n0 --> 2\n4. queries[3] = [x,y]:\n0 --> 1 --> 2 --> 3 --> 4 --> 5\nExample 2:\n\nInput: n = 6, queries = [[0,3],[1,3],[2,3],[4,3],[5,3],[0,4],[1,4],[2,4],[0,5],[1,5],[2,5],[3,4],[3,5],[4,5]]\nOutput: [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6]\nExplanation: Each query has a shortest path from city 0 to city 5, which is 6.\n \n\nConstraints:\n\n2 <= n <= 1000\n1 <= queries.length <= n * (n - 1) / 2\nqueries[i].length == 2\n0 <= ui, vi <= n - 1\nui != vi\nThere will be at most 10^4 queries.\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n  "}
{"task_id": "python/4", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/5", "content": "", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/6", "content": "The format of the output is:\nA list of integers, where the ith element is the answer to the ith query.\nThe list must be output in the order of the input queries.\n\nExample 1:\nInput: n = 6, queries = [[0,1],[1,3],[2,4],[0,5]]\nOutput: [6,3,4,6]\nExplanation: The queries are processed as follows:\n- Query = [0,1]: The shortest path between cities 0 and 1 is 6.\n- Query = [1,3]: The shortest path between cities 1 and 3 is 3.\n- Query = [2,4]: The shortest path between cities 2 and 4 is 4.\n- Query = [0,5]: The shortest path between cities 0 and 5 is 6.\n\nExample 2:\nInput: n = 5, queries = [[0,4],[2,3],[0,2],[1,4],[2,0],[3,4]]\nOutput: [1,4,2,1,3]\nExplanation: The queries are processed as follows:\n- Query = [0,4]: The shortest path between cities 0 and 4 is 1.\n- Query = [2,3]: The shortest path between cities 2 and 3 is 4.\n- Query = [0,2]: The shortest path between cities 0 and 2 is 2.\n- Query = [1,4]: The shortest path between cities 1 and 4 is 1.\n- Query = [2,0]: The shortest path between cities 2 and 0 is 3.\n- Query = [3,4]: The shortest path between cities 3 and 4 is 3.\n\nConstraints:\n2 <= n <= 1000\nn - 1 <= queries.length <= 2000\nqueries[i].length == 2\n0 <= queries[i][0], queries[i][1] < n\nThere are no two queries that have the same value in queries[i][0] and queries[j][0].\n\"\"\"\n\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/7", "content": "\nThe test case is as follows:\nn = 4\nqueries = [[1,2],[3,4]]\n\nThe answer is as follows:\n[2,1]\n\nExplanation:\n1. After the first query, the shortest path from city 0 to city 3 has length 2, and the shortest path from city 0 to city 3 has length 3.\n2. After the second query, the shortest path from city 0 to city 3 has length 1, and the shortest path from city 0 to city 3 has length 2.\n\nNote: The input and output format are the same as the previous problem.\n\nNote:\n1 <= n <= 10^4\n1 <= queries.length <= 10^4\n0 <= queries[i][0], queries[i][1] < n\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/8", "content": "\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/9", "content": "\nThe input format is as follows:\nThe first line contains an integer n (1 ≤ n ≤ 500,000), the number of tiles. The second line contains n integers colors, where colors[i] is the color of tile i (0 or 1). The third line contains a positive integer m (1 ≤ m ≤ 500,000), the number of queries. The next m lines contain queries, each line contains two integers q and k (1 ≤ q ≤ 2, 1 ≤ k ≤ 500,000), q is the type of query and k is the parameter of the query.\n\nOutput format\nOutput m integers in one line, the i-th integer represents the answer to the i-th query.\n\nSample Input 1:\n4\n0 1 1 0\n2\n1 2\n2 2 0\nSample Output 1:\n0\n2\nExplanation of Sample Output 1:\nThe first query: There is no alternating group of size 2.\nThe second query: There are 2 alternating groups of size 2.\n\nSample Input 2:\n4\n0 1 1 0\n3\n1 2\n2 2 0\n1 2\nSample Output 2:\n0\n2\n1\nExplanation of Sample Output 2:\nThe first query: There is no alternating group of size 2.\nThe second query: There are 2 alternating groups of size 2.\nThe third query: The first alternating group is removed and a new alternating group of size 2 is formed.\nThe fourth query: The number of alternating groups of size 2 is 1.\n\nNote:\nThe answer to the second query should be 2, not 1.\n\nSample Input 3:\n4\n0 1 1 0\n2\n1 2\n2 2 1\nSample Output 3:\n0\n0\nExplanation of Sample Output 3:\nThe first query: There is no alternating group of size 2.\nThe second query: There is no alternating group of size 2.\n\n\n\n", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/10", "content": "\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n               ", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/11", "content": "\n\n# class FenwickTree:\n#     def __init__(self, n: int):\n#         self.t = [[0, 0] for _ in range(n + 1)]\n\n#     # op=1，添加一个 size\n#     # op=-1，移除一个 size\n#     def update(self, size: int, op: int) -> None:\n#         i = len(self.t) - size\n#         while i < len(self.t):\n#             self.t[i][0] += op\n#             self.t[i][1] += op * size\n#             i += i & -i\n\n#     # 返回 >= size 的元素个数，元素和\n#     def query(self, size: int) -> (int, int):\n#         cnt = s = 0\n#         i = len(self.t) - size\n#         while i > 0:\n#             cnt += self.t[i][0]\n#             s += self.t[i][1]\n#             i &= i - 1\n#         return cnt, s\n\n# class Solution:\n#     def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n#         n = len(a)\n#         sl = SortedList()\n#         t = FenwickTree(n)\n\n#         # op=1，添加一个结束位置 i\n#         # op=-1，移除一个结束位置 i\n#         def update(i: int, op: int) -> None:\n#             idx = sl.bisect_left(i)\n#             pre = sl[idx - 1]\n#             nxt = sl[idx % len(sl)]\n\n#             t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n#             t.update((i - pre) % n, op)\n#             t.update((nxt - i) % n, op)  # 添加/移除新长度\n", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/12", "content": "", "groundtruth": " class Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\n        double=0\n        for it in nums:\n            if it>=10: \n                double=double+it \n            else:\n                single=single+it  \n        \n        return single !=double\n "}
{"task_id": "python/13", "content": "\nExample 1:\n\nInput: l = 3, r = 10\nOutput: 4\nExplanation: The numbers between 3 and 10 are 4, 5, 6, and 9.\n\nExample 2:\n\nInput: l = 1, r = 2\nOutput: 0\nExplanation: The number between 1 and 2 is 1.\n\nExample 3:\n\nInput: l = 1, r = 2147483647\nOutput: 0\nExplanation: The number between 1 and 2147483647 is 1.\n\nConstraints:\n\n1 <= l <= r <= 2 * 10^9\n", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n"}
{"task_id": "python/14", "content": "", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n "}
{"task_id": "python/15", "content": "The code is as follows:\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += 1\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b =='0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n "}
{"task_id": "python/16", "content": "\nExample 1:\nInput: s = \"0110\"\nOutput: 1\nExplanation: The only substring with dominant ones is \"011\".\nExample 2:\nInput: s = \"01100110\"\nOutput: 2\nExplanation: The two substrings with dominant ones are \"0110\" and \"011\".\nExample 3:\nInput: s = \"0000000000\"\nOutput: 1\n\n\nSolution:\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = a[k + 1] - a[k]\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = left - a[k] + 1\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/17", "content": "", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/18", "content": "\nThe format of the input data is as follows:\nThe first line contains two integers xCorner and yCorner, which denote the x and y coordinates of the top right corner of the rectangle.\nThe second line contains an integer N (1≤N≤500), which denotes the number of circles.\nEach of the next N lines contains three integers xi, yi, and ri (1≤ri≤1000), which denote the x and y coordinates of the center of the circle, and the radius of the circle, respectively.\nThe circles are guaranteed to be pairwise disjoint.\nIt is guaranteed that there exists a path from the bottom left corner to the top right corner such that the entire path lies inside the rectangle, does not touch or lie inside any circle, and touches the rectangle only at the two corners.\n\nThe format of the output data is as follows:\nPrint only one line containing the boolean value indicating whether such a path exists or not.\n\nThe time limit is 2 seconds.\n\nThe format of the input data is as follows:\n\n5 3\n1 2 1\n3 1 2\n5 1 3\n4 3 2\n2 4 1\n\nThe format of the output data is as follows:\n\ntrue\n", "groundtruth": " class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n    "}
{"task_id": "python/19", "content": "\n", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/20", "content": "\n \n\nExample 1:\n\nInput: xCorner = 1, yCorner = 2, circles = [[0,0,2],[2,0,1]]\nOutput: true\nExplanation: The path is: [0,0] -> [1,0] -> [1,1] -> [2,1]\nExample 2:\n\nInput: xCorner = 1, yCorner = 2, circles = [[0,0,1],[0,1,1]]\nOutput: false\nExplanation: The point (0,0) lies inside the circle (0,0,1).\nExample 3:\n\nInput: xCorner = 1, yCorner = 2, circles = [[0,0,1],[0,1,1],[1,0,1]]\nOutput: false\nExplanation: The point (0,1) lies on the circle (0,1,1).\n\n \n\nConstraints:\n\n    1 <= xCorner, yCorner <= 100\n    1 <= circles.length <= 100\n    circles[i].length == 3\n    0 <= xi, yi, ri <= 100\n\nAccepted\n227,916\nSubmissions\n433,043\n\n\n\n## 解法\n```\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] =", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/21", "content": "\n \n\nExample 1:\n\nInput: grid = [[1,1,0],[0,1,0],[0,1,1]]\nOutput: 0\nExplanation: In the first game team 0 will play against team 1 and win (1-0). \nIn the second game team 1 will play against team 2 and lose (0-1). \nTherefore, team 0 will win the tournament.\n\nExample 2:\n\nInput: grid = [[1,0,0],[0,1,1],[0,0,1]]\nOutput: 2\nExplanation: In the first game team 2 will play against team 0 and win (1-0). \nIn the second game team 0 will play against team 1 and lose (0-1). \nTherefore, team 2 will win the tournament.\n\nExample 3:\n\nInput: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: 0\n\n \n\nConstraints:\n\n1 <= grid.length == grid[i].length <= 30\ngrid[i][j] is either 0 or 1.\nThink about how you can make use of this property of the problem:\n\nIf there is no team b that is stronger than team a, then team a will be the champion.\n\n \n\nNote:\n\nThe given matrix is a boolean matrix, which means all the elements are either 0 or 1.\n\n'''\n\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] and not grid[j][i]:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n\n", "groundtruth": "\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] == 1 and grid[j][i] == 0:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n"}
{"task_id": "python/22", "content": "\nNote:\n\nThe given graph is guaranteed to be a DAG.\nn is in the range [1, 100,000].\nm is in the range [0, 100,000].\nedges[i] is guaranteed to be a permutation of [0, 1, ..., n - 1].\n\n \n\nExample 1:\n\nInput: n = 5, edges = [[0,1],[1,2],[3,4],[2,3],[3,4]]\nOutput: 3\nExplanation:\nThe given graph is shown above.\nTeams 3 and 4 are the only two teams that have a unique champion.\nTeams 2 and 4 are the only two teams that have a unique last place team.\nThus, the champion team and the last place team are both 3.\n\nExample 2:\n\nInput: n = 7, edges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,0]]\nOutput: -1\nExplanation:\nThe given graph is shown above.\nThere is no team that has a unique champion and a unique last place team.\nThus, there is no champion team.\n \n\nConstraints:\n\n1 <= n <= 100,000\n0 <= edges.length <= 100,000\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] < n\nedges[i][0] != edges[i][1]\nThere are no duplicate edges.\n\n'''\n\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            visited = [False] * n\n            count = 0\n            if self.dfs(graph, i, visited) == n:\n                return i\n        return -1\n    \n    def dfs(self, graph: List[List[int]], start: int, visited: List[", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/23", "content": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/24", "content": "\nExample 1:\n\nInput: edges = [[0,1],[0,2]], values = [1,2,3]\nOutput: 6\nExplanation:\nThe maximum score is 6 after following the optimal path on the tree.\nThe optimal path is:\n- Pick the node with value 3 at the root.\n- Pick the node with value 2 at the right subtree of the root.\n- Pick the node with value 1 at the left subtree of the node with value 2.\nThe sum of the values on the path is 1 + 2 + 3 = 6, and the sum of the values in the path is 0 + 2 + 3 = 5.\nThe tree remains healthy because the difference between the sum of the values on the path and the sum of the values in the path is 1, which is not 0.\n\nExample 2:\n\nInput: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [7,7,7,7,7,7]\nOutput: 14\nExplanation:\nThe maximum score is 14 after following the optimal path on the tree.\nThe optimal path is:\n- Pick the node with value 7 at the root.\n- Pick the node with value 7 at the right subtree of the root.\n- Pick the node with value 7 at the right subtree of the node with value 7.\n- Pick the node with value 7 at the left subtree of the node with value 7.\nThe sum of the values on the path is 7 + 7 + 7 + 7 = 24, and the sum of the values in the path is 0 + 7 + 7 + 7 = 14.\nThe tree remains healthy because the difference between the sum of the values on the path and the sum of the values in the path is 10, which is not 0.\n\nExample 3:\n\nInput: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [1,1000,1000,1000,1000,100", "groundtruth": "\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/25", "content": "\n\n# 暴力法\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                diff = [nums[j] - nums[i]]\n                for k in range(j+1, n):\n                    if nums[k] - nums[k-1] in diff:\n                        diff.append(nums[k] - nums[k-1])\n                    else:\n                        break\n                ans = max(ans, sum(diff))\n        return ans\n\n\n# 贪心+BIT\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i)\n            f = j - i\n            t.update(j, f)\n        return t.pre_max(len(b))  \n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/26", "content": "\nConstraints\nn ≤ 105\n1 ≤ nums[i] ≤ 109\nThe elements of nums are distinct.", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/27", "content": "\n#include <algorithm>\n#include <cmath>\n#include <cstddef>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\n public:\n  int maxBalancedSubsequenceSum(vector<int>& nums) {\n    vector<int> b(nums.size());\n    b[0] = nums[0];\n    for (int i = 1; i < nums.size(); i++) {\n      b[i] = max(b[i - 1], nums[i]);\n    }\n    int sum = 0;\n    int res = 0;\n    for (int i = 0; i < nums.size(); i++) {\n      sum += nums[i];\n      res = max(res, sum - b[i]);\n    }\n    return res;\n  }\n};\n\nint main() {\n  vector<int> nums = {5, 1, 1, 1, 10};\n  Solution solution;\n  int ans = solution.maxBalancedSubsequenceSum(nums);\n  return 0;\n}", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/28", "content": "\n\n\nExample 1:\nInput: nums = [2], k = 1\nOutput: 2\n\nExample 2:\nInput: nums = [2,4], k = 2\nOutput: 6\n\nExample 3:\nInput: nums = [2,4,7], k = 2\nOutput: 7\n\nExample 4:\nInput: nums = [2,4,7,8], k = 2\nOutput: 7\n\n\n\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n1 <= k <= 105\n\n\n\nHint #1  \nThe number of bits in the binary representation of a number can be found using the built-in function max().bit_length().\n\n\n\nHint #2  \nFor each bit position i, we can count the number of 1s by iterating through nums and checking if the bit at position i is 1 using the & operator.\n\n\n\nHint #3  \nFor each bit position i, if the number of 1s at that position is greater than or equal to k, we can set the bit at position i in the answer to 1 using the | operator.\n\n\n\nHint #4  \nIf there are fewer than k numbers, we can set the bit at that position to 1, as there are at least k 1s at that position.\n\n\n\nHint #5  \nWe can use the Python built-in function sum() to count the number of 1s at each bit position.\n\n\n\nHint #6  \nWe can use the Python built-in function max() to find the maximum value in nums.\n\n\n\nHint #7  \nWe can use the Python built-in function range() to iterate through each bit position in the binary representation of the maximum value in nums.\n\n\n\nHint #8  \nWe can use the Python built-in function len() to count the number of 1s at each bit position.\n\n\n\nHint #9  \nWe can use the Python built-in function sum() to count the number of 1s at each bit position.\n\n\n\nHint #10  \nWe can use the Python built-in function max()", "groundtruth": "\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/29", "content": "\nConstraints:\n1 <= nums1.length, nums2.length <= 10^5\n1 <= nums1[i], nums2[i] <= 10^4\n\nExample 1:\nInput: nums1 = [1,0], nums2 = [1,1]\nOutput: 2\nExplanation: We can combine the two arrays as follows: [1,1,1,1]\n\nExample 2:\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: -1\nExplanation: There is no way to combine nums1 and nums2 to have the same sum.\n\nExample 3:\nInput: nums1 = [3,1,1,5], nums2 = [1,1,1,1]\nOutput: 5\nExplanation: We can combine the two arrays as follows: [1,1,1,1,1,1,1,1,5]\n\n\n\n", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/30", "content": "\n\n", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/31", "content": "\nThe test case is as follows:\n\nnums = [2,3,3,2,3,3,2]\nk = 2\n\nThe expected answer is 3.\n", "groundtruth": "\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/32", "content": "\nNote: In the above code, @cache is a decorator function provided by LeetCode to cache the results of function calls.\n\n \n\nExample 1:\n\n\nInput: edges = [[0,1],[0,2],[1,3],[2,4],[2,5]], coins = [1,1,1,1,1], k = 3\nOutput: 9\nExplanation: The optimal way is to collect coins [0, 2, 3, 4, 5].\nThe total number of points is 1 + 1 + 1 + 1 + 1 = 5.\nExample 2:\n\n\nInput: edges = [[0,1],[0,2],[1,3],[2,4],[2,5]], coins = [0,0,0,0,0], k = 0\nOutput: 0\nExplanation: Since there are no coins, there is no need to collect coins.\nExample 3:\n\n\nInput: edges = [[0,1],[0,2],[1,3],[2,4],[2,5]], coins = [1,1,1,1,1], k = 2\nOutput: 10\nExplanation: The optimal way is to collect coins [0, 2, 3, 4, 5].\nThe total number of points is 1 + 1 + 1 + 1 + 1 = 5.\n \n\nConstraints:\n\nn == coins.length\n1 <= n <= 10^5\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] < n\n0 <= coins[i] <= 10^4\n0 <= k <= 10^4\n\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    int maximumPoints(vector<vector<int>>& edges, vector<int>& coins, int k) {\n        vector<vector<int>> g(edges.size());\n        for (int i = 0; i < edges.size(); i++) {\n            g[edges[i][0]].push_back(edges[i][1]);\n", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/33", "content": "\nThe correct code is as follows:\n\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = coins[i] - k if coins[i] - k > 0 else 0\n            res2 = coins[i] // 2\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i)  \n                    if j < 13:  \n                        res2 += dfs(ch, j + 1, i)  \n            coins[i] = coins[i] // 2\n            return max(res1, res2)\n        return dfs(0, 0, -1)\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/34", "content": "", "groundtruth": " class Solution:     def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:         g = [[] for _ in coins]         for x, y in edges:             g[x].append(y)             g[y].append(x)         @cache         def dfs(i: int, j: int, fa: int) -> int:             res1 = (coins[i] >> j) - k             res2 = coins[i] >> (j + 1)             for ch in g[i]:                 if ch != fa:                     res1 += dfs(ch, j, i)                      if j < 13:                          res2 += dfs(ch, j + 1, i)              return max(res1, res2)         return dfs(0, 0, -1) "}
{"task_id": "python/35", "content": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n        def do(o, l, r, add):\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n        def query_and_add1(o, l, r, L, R):\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n\n", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/36", "content": "\n \n\nExample 1:\n\nInput: nums = [1,2,3,2,1]\nOutput: 49\nExplanation: The distinct counts of the subarrays are [1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3,", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/37", "content": "\n\n", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/38", "content": "\n \n\nInput Format\n\nA single line containing a binary string s.\n\nConstraints\n\n2 ≤ s.length ≤ 105\n\ns consists of 0's and 1's.\n\nOutput Format\n\nAn integer that denotes the minimum number of changes required to make the string beautiful.\n\nSample Input 1\n\n01010011\n\nSample Output 1\n\n3\n\nExplanation 1\n\nOne possible way to make the string beautiful is to change the 0 at the 2nd position to 1, the 5th position to 0, and the 7th position to 1.\n\n \n\nSample Input 2\n\n11111111\n\nSample Output 2\n\n0\n\nExplanation 2\n\nThe string is already beautiful, so there is no need to change any character.\n\n \n\nSample Input 3\n\n11110111\n\nSample Output 3\n\n1\n\nExplanation 3\n\nOne possible way to make the string beautiful is to change the 6th position to 0.\n\n \n\nSample Input 4\n\n00000000\n\nSample Output 4\n\n0\n\nExplanation 4\n\nThe string is already beautiful, so there is no need to change any character.\n\n \n\nSample Input 5\n\n0101010101010101\n\nSample Output 5\n\n4\n\n \n\nSample Input 6\n\n0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101", "groundtruth": " class Solution:     def minChanges(self, s: str) -> int:         cnt = 0         for i in range(0, len(s), 2):             if len(set(s[i:i + 2])) > 1:                 cnt += 1                 print(s)         return cnt "}
{"task_id": "python/39", "content": "\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestSubsequence(self, nums: List[int], target: int) -> int:\n        f = [0] + [-inf] * target\n        s = 0\n        for x in nums:\n            s = s + x\n            for j in range(s, x - 1, -1):\n                # f[j] = max(f[j], f[j - x] + 1)\n                if f[j] < f[j - x] + 1:\n                    f[j] = f[j - x] + 1\n        return f[-1] if f[-1] > 0 else -1", "groundtruth": " class Solution:     def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:         f = [0] + [-inf] * target         s = 0         for x in nums:             s = min(s + x, target)             for j in range(s, x - 1, -1):                 # f[j] = max(f[j], f[j - x] + 1)                 if f[j] < f[j - x] + 1:                     f[j] = f[j - x] + 1         return f[-1] if f[-1] > 0 else -1 "}
{"task_id": "python/40", "content": "\n\n", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/41", "content": "", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/42", "content": "", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/43", "content": "The input format is as follows:\nThere are 5 lines in the input file.\nEach line contains a string, and there is no extra space at the beginning or end of each line.\nThe first line contains string source.\nThe second line contains string target.\nThe third line contains an integer k.\nThe fourth line contains k space-separated strings, which represent original.\nThe fifth line contains k space-separated strings, which represent changed.\nThe output format is as follows:\nThere is only one line in the output file.\nThe line contains an integer, which represents the minimum cost to convert source to target.\nNote:\n1. 1 <= source.length == target.length <= 10^5\n2. source, target contain only lowercase English letters.\n3. original.length == changed.length == cost.length == k\n4. 1 <= k <= 10^5\n5. 1 <= cost[i] <= 10^5\n\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/44", "content": "The input and output is as follows:\nInput:\nsource = \"aab\"\ntarget = \"bbb\"\noriginal = [\"a\",\"b\"]\nchanged = [\"b\",\"b\"]\ncost = [1,1]\nOutput:\n2\nInput:\nsource = \"aab\"\ntarget = \"bba\"\noriginal = [\"a\",\"b\"]\nchanged = [\"b\",\"a\"]\ncost = [1,1]\nOutput:\n3\nInput:\nsource = \"aab\"\ntarget = \"bba\"\noriginal = [\"a\",\"b\"]\nchanged = [\"b\",\"a\"]\ncost = [1,1]\nOutput:\n3\nInput:\nsource = \"aab\"\ntarget = \"bba\"\noriginal = [\"a\",\"b\"]\nchanged = [\"b\",\"a\"]\ncost = [1,1]\nOutput:\n3\nInput:\nsource = \"aab\"\ntarget = \"bba\"\noriginal = [\"a\",\"b\"]\nchanged = [\"b\",\"a\"]\ncost = [1,1]\nOutput:\n3\n\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)         for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/45", "content": "", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                      continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/46", "content": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumCost(string source, string target, vector<string> original, vector<string> changed, vector<int> cost) {\n        int n = source.size();\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n        for (int i = 0; i <= n; ++i) {\n            for (int j = 0; j <= n; ++j) {\n                if (i == 0 && j == 0) continue;\n                if (i == 0) dp[i][j] = 0;\n                else if (j == 0) dp[i][j] = INT_MAX;\n                else dp[i][j] = INT_MAX;\n                for (int k = 0; k < original.size(); ++k) {\n                    if (original[k] == source.substr(i - original[k].size(), original[k].size()) && changed[k] == target.substr(j - changed[k].size(), changed[k].size())) {\n                        dp[i][j] = min(dp[i][j], dp[i - original[k].size()][j - changed[k].size()] + cost[k]);\n                    }\n                }\n            }\n        }\n        return dp[n][n];\n    }\n};\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/47", "content": "", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/48", "content": "\n# Test case 1:\n# Please enter a 2D-array(e.g. [[1,2],[3,4]]):\n# [[1,2,3],[4,5,6],[7,8,9]]\n# Please enter a value:\n# 5\n# The result of adjacentSum is:\n# 12\n# The result of diagonalSum is:\n# 20\n# Test case 2:\n# Please enter a 2D-array(e.g. [[1,2],[3,4]]):\n# [[1,2],[3,4]]\n# Please enter a value:\n# 0\n# The result of adjacentSum is:\n# 5\n# The result of diagonalSum is:\n# 0\n# Test case 3:\n# Please enter a 2D-array(e.g. [[1,2],[3,4]]):\n# [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\n# Please enter a value:\n# 15\n# The result of adjacentSum is:\n# 50\n# The result of diagonalSum is:\n# 24\n\n# Note: The custom input/output system of LeetCode is only used for the convenience of the problem setter. You should use the standard input/output system of Python to solve the problem.\n\n# Test case 4:\n# Please enter a 2D-array(e.g. [[1,2],[3,4]]):\n# [[1,2,3],[4,5,6],[7,8,9]]\n# Please enter a value:\n# 5\n# The result of adjacentSum is:\n# 12\n# The result of diagonalSum is:\n# 20\n\n# Note: The custom input/output system of LeetCode is only used for the convenience of the problem setter. You should use the standard input/output system of Python to solve the problem.\n\n# Test case 5:\n# Please enter a 2D-array(e.g. [[1,2],[3,4]]):\n# [[1,2],[3,4]]\n# Please", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/49", "content": "\nConstraints:\n1 <= n <= 1000\n1 <= grid[i][j] < n2\n0 <= value < n2\n\nExample 1:\nInput\n[\"NeighborSum\",\"adjacentSum\",\"adjacentSum\",\"diagonalSum\",\"diagonalSum\"]\n[[[[0,1,2],[3,4,5],[6,7,8]]], [0], [1], [0], [1]]\nOutput\n[null,1,2,1,2]\nExplanation\nNeighborSum neighborSum = new NeighborSum([[0,1,2],[3,4,5],[6,7,8]]);\nneighborSum.adjacentSum(0); // returns 1 because only 1 adjacent element is 1.\nneighborSum.adjacentSum(1); // returns 2 because only 2 adjacent elements are 2.\nneighborSum.diagonalSum(0); // returns 1 because only 1 diagonal element is 1.\nneighborSum.diagonalSum(1); // returns 2 because only 2 diagonal elements are 2.\n\n\n\n", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/50", "content": "", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/51", "content": "\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        def find(x: int) -> int:\n            if x == fa[x]:\n                return x\n            fa[x] = find(fa[x])\n            return fa[x]\n\n        def union(u: int, v: int) -> None:\n            u = find(u)\n            v = find(v)\n            if u != v:\n                fa[u] = v\n\n        ans = []\n        for ui, vi in queries:\n            union(ui, vi)\n            ans.append(len(set(find(i) for i in range(n - 1))))\n        return ans\n\n", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/52", "content": "\n\n", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/53", "content": "\nNote: In the following code, we use SortedList as a container to count the number of alternating groups. You can use a list to replace SortedList if you prefer.\n\n\n", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/54", "content": "\nInput Format\n\nThe first line contains an integer n, the size of nums. The next line contains n space-separated integers nums[i].\n\nConstraints\n\n1 ≤ n ≤ 10^5\n1 ≤ nums[i] ≤ 10^9\n\nOutput Format\n\nOutput true if Alice can win the game, otherwise, output false.\n\nSample Input 0\n\n3\n1 2 3\n\nSample Output 0\n\ntrue\n\nSample Input 1\n\n3\n1 2 3\n\nSample Output 1\n\nfalse\n\nSample Input 2\n\n3\n1 2 3\n\nSample Output 2\n\ntrue\n\nExplanation 2\n\nAlice can choose either all single-digit numbers or all double-digit numbers. If Alice chooses all single-digit numbers, she will win the game. If Alice chooses all double-digit numbers, Bob can only choose 3, and Alice will win the game.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\ndouble=0\nfor it in nums:\nif it>=10: \ndouble=double+it \nelse:\nsingle=single+it  \n        \nreturn single !=double\n "}
{"task_id": "python/55", "content": "\nExample 1:\n\nInput: s = \"11110000111111\"\nOutput: 15\nExplanation: The number of substrings with dominant ones is 15.\nExample 2:\n\nInput: s = \"00000000000000000000000000001011\"\nOutput: 1\nExplanation: The number of substrings with dominant ones is 1.\n\nConstraints:\n\n1 <= s.length <= 10^5\ns[i] is either '0' or '1'.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/56", "content": "", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/57", "content": "\nNote: You may assume that the given rectangle is at the bottom left of the coordinate plane and the given circles are all distinct.\n\nExample 1:\n\nInput: xCorner = 2, yCorner = 3, circles = [[1,1,2]]\nOutput: false\nExplanation: The circle with center at (1,1) and radius 2 lies outside the rectangle.\n\nExample 2:\n\nInput: xCorner = 2, yCorner = 3, circles = [[1,1,2],[2,2,3]]\nOutput: false\nExplanation: The circle with center at (2,2) and radius 3 lies outside the rectangle.\n\nExample 3:\n\nInput: xCorner = 1, yCorner = 1, circles = [[1,1,1]]\nOutput: true\nExplanation: The path to the bottom right corner is (0,0) -> (1,1) -> (1,0) -> (0,0).\n\nExample 4:\n\nInput: xCorner = 1, yCorner = 1, circles = [[1,1,1],[1,1,2]]\nOutput: false\nExplanation: The circle with center at (1,1) and radius 2 lies outside the rectangle.\n\nExample 5:\n\nInput: xCorner = 2, yCorner = 2, circles = [[1,1,1],[2,2,1]]\nOutput: false\nExplanation: The circle with center at (2,2) and radius 1 lies outside the rectangle.\n\nConstraints:\n\n1 <= xCorner, yCorner <= 100\n1 <= circles.length <= 50\ncircles[i].length == 3\n1 <= xi, yi <= 100\n1 <= ri <= min(xCorner, yCorner)\nNo two circles are the same.\n\n\nSolution：\n\n```\n\"\"\"\n# Definition for a point.\nclass Point:\n    def __init__(self, a=0, b=0):\n        self.x = a\n        self.y = b\n\"\"\"\n\nclass Solution:\n    def canReachCorner(self, xCor", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/58", "content": "", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/59", "content": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n        visited = [False] * n\n        champion = -1\n        for i in range(n):\n            if not visited[i]:\n                self.dfs(graph, i, visited)\n                if champion == -1:\n                    champion = i\n                elif champion != i:\n                    return -1\n        return champion\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                self.dfs(graph, neighbor, visited)\n", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/60", "content": "\nExample 1:\nInput: edges = [[0,1],[1,2],[2,3],[2,4],[2,5]], nums = [1,2,3,4,5,6]\nOutput: 17\nExplanation: The above figure represents the input tree. The blue nodes denote the nodes that are on the path from node 0 to node 5.\nWe can see that the path from node 0 to node 5 has a sum of values equal to 1 + 2 + 3 + 4 + 5 + 6 = 21.\nOne optimal way to make the tree healthy is to do the following operations:\n1. Pick node 5 and add its value 6 to the score.\n2. Pick node 4 and add its value 5 to the score.\n3. Pick node 3 and add its value 4 to the score.\n4. Pick node 2 and add its value 3 to the score.\n5. Pick node 1 and add its value 2 to the score.\n6. Pick node 0 and add its value 1 to the score.\nThe tree remains healthy because the path from the root to the leaf nodes now has a sum of values equal to 1 + 2 + 3 + 4 + 5 + 6 = 21, which is different from zero.\nThe maximum score we can obtain is 1 + 2 + 3 + 4 + 5 + 6 = 21.\n\nExample 2:\nInput: edges = [[0,1],[0,2],[3,4],[3,5],[6,7],[6,8]], nums = [1,2,3,4,5,6,7,8]\nOutput: 28\nExplanation: The above figure represents the input tree.\nWe can see that the path from node 0 to node 7 has a sum of values equal to 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.\nOne optimal way to make the tree healthy is to do the following operations:\n1. Pick node 7 and add its value 8 to the score.\n2. Pick node 6 and add its value 7 to the score.\n3. Pick node 5 and", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/61", "content": "\n \n\nExample 1:\n\nInput: edges = [[0,1],[0,2]], values = [1,2,3]\nOutput: 3\nExplanation: One possible way to obtain a maximum score is to:\n- Set values[0] to 0 and obtain a score of 3.\nThe tree is healthy.\nExample 2:\n\nInput: edges = [[0,1],[1,2],[2,3],[1,4],[4,5]], values = [1,2,3,4,5,6]\nOutput: 10\nExplanation: One possible way to obtain a maximum score is to:\n- Set values[1] to 0 and obtain a score of 6.\n- Set values[4] to 0 and obtain a score of 10.\nThe tree is healthy.\n\n \n\nConstraints:\n\nn == edges.length == values.length\n2 <= n <= 10^4\nedges[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\n0 <= values[i] <= 10^4\n\n'''\n\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        def dfs(u, p = -1):\n            total, res = 0, 0\n            for v in graph[u]:\n                if v != p:\n                    t, r = dfs(v, u)\n                    total += t\n                    res += r\n            res += total\n            res += nums[u]\n            return total, res\n        return dfs(0)[1]\n", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/62", "content": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1  \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))  \n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        res = -inf\n        while i > 0:\n            res = max(res, self.tree[i])\n            i -= i & -i\n        return res", "groundtruth": "class Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/63", "content": "\nThe sample test case is as follows:\n\nInput: nums = [2,4,8,2], k = 2\nOutput: 10\nExplanation: The binary representation of the numbers in nums is:\nnums[0] = 0b0010 \nnums[1] = 0b0100\nnums[2] = 0b1000\nnums[3] = 0b0010\nThe 2-or of nums is:\n0b0010\n0b0100\n0b1000\n0b0010\n= 0b1010\n= 10\n\nThe constraints are as follows:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 105\n1 <= k <= nums.length\n\n", "groundtruth": "class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/64", "content": "\n", "groundtruth": "class Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n\n"}
{"task_id": "python/65", "content": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        int n,k;\n        cin>>n>>k;\n        vector<int> arr(n);\n        for(int i=0;i<n;i++)\n        {\n            cin>>arr[i];\n        }\n        Solution ob;\n        cout<<ob.minIncrementOperations(arr,k)<<endl;\n    }\n    return 0;\n}\n\n\n\n", "groundtruth": "class Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/66", "content": "\n\n\nExample 1:\n\n\nInput: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], coins = [10,20,30,40,50,60], k = 20\nOutput: 130\nExplanation:\nThe tree structure is shown above.\nThe best way to collect coins is to collect all the coins at the node 2.\nThe total amount of coins collected is 30 + 40 + 50 + 60 = 160.\nThe total amount of points earned is 160 - 20 = 140.\nThe maximum points earned is 140 + 30 = 170.\n\nExample 2:\n\n\nInput: edges = [[0,1],[1,2],[2,3],[2,4],[5,6],[6,7]], coins = [1,2,3,4,5,6], k = 10\nOutput: 12\nExplanation:\nThe tree structure is shown above.\nThe best way to collect coins is to collect all the coins at the node 2.\nThe total amount of coins collected is 1 + 2 + 3 + 4 + 5 + 6 = 18.\nThe total amount of points earned is 18 - 10 = 8.\nThe maximum points earned is 8 + 3 = 11.\n\nExample 3:\n\n\nInput: edges = [[0,1],[1,2],[2,3],[2,4],[2,5],[2,6],[3,7],[4,8],[5,9],[6,10]], coins = [1,2,3,4,5,6,7,8,9,10], k = 15\nOutput: 50\nExplanation:\nThe tree structure is shown above.\nThe best way to collect coins is to collect all the coins at the node 2.\nThe total amount of coins collected is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55", "groundtruth": "class Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/67", "content": "\nThe input and output format is as follows:\n\nThe first line of the input contains a single integer n (1 <= n <= 1000), denoting the length of nums.\nThe second line contains n space-separated integers nums[i] (0 <= nums[i] <= 1000), where nums[i] is the i-th integer in nums.\nThe third line contains a single integer x (1 <= x <= 1000), denoting the number of queries.\nFor each query, the third line contains two space-separated integers L and R (1 <= L <= R <= 1000), denoting the left and right indices of the subarray.\n\nThe output should contain only one line, containing a single integer denoting the sum of the squares of distinct counts of all subarrays of nums.\n\nNote:\n\nFor each subarray, you should count the number of distinct values in that subarray.\nFor example, if nums is [1,2,3,1,2,1], then the distinct count of the subarray [1,2,3,1,2,1] is 3.\n\nExample 1:\n\nInput:\n5\n1 2 3 1 2\n2\n2 3\n1 5\n\nOutput:\n3\n\nExplanation:\nThe subarrays are:\n[1, 2, 3, 1, 2]\n[1, 2, 3, 1, 2, 1]\n\nThe distinct counts are:\n[1, 2, 3, 1, 2] = 3\n[1, 2, 3, 1, 2, 1] = 3\n\nSo the answer is 3^2 + 3^2 = 3.\n\nExample 2:\n\nInput:\n6\n1 2 3 1 2 3\n3\n1 6\n2 6\n1 6\n\nOutput:\n27\n\nExplanation:\nThe subarrays are:\n[1, 2, 3, 1, 2, 3]\n[1, 2, 3, 1, 2, 3, ", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/68", "content": "\nThe format of the return value is as follows:\n\nIf there is no solution, return -1.\nIf there is a solution, return the sum of the squares of distinct counts of all subarrays of nums.\n\nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 10^5\nThe sum of the lengths of all subarrays does not exceed 2 * 10^5.\n\nExample 1:\nInput: nums = [1,2,3,2,1]\nOutput: 49\nExplanation: The subarrays are:\n[1], [2], [3], [2], [1], [1, 2], [2, 3], [2, 2], [1, 2, 3], [2, 2, 2], [1, 2, 3, 2], [2, 2, 2, 1], [1, 2, 3, 2, 1]\nThe distinct counts of each subarray are:\n1, 1, 1, 2, 1, 1, 2, 2, 2, 3, 2, 2, 2\nThe sum of the squares of distinct counts is 1 + 1 + 1 + 4 + 1 + 1 + 4 + 4 + 9 + 2 + 4 + 4 = 49.\n\nExample 2:\nInput: nums = [1,2,3,3,2,1]\nOutput: 30\nExplanation: The subarrays are:\n[1], [2], [3], [3], [2], [1], [1, 2], [2, 3], [2, 3], [1, 2, 3], [2, 3, 3], [1, 2, 3, 3], [2, 3, 3, 2], [1, 2, 3, 3, 2], [2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]\nThe distinct counts of each subarray are:\n", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/69", "content": "\nInput: s = \"0100\"\nOutput: 1\nExplanation: Change the last character to get t = \"0100\".\n\nInput: s = \"100110\"\nOutput: 2\nExplanation: Change the first character and the last character to get t = \"101010\".\n\nInput: s = \"111000\"\nOutput: 0\nExplanation: The string s is already beautiful.\n\nInput: s = \"111001\"\nOutput: 1\nExplanation: Change the last character to get t = \"111000\".\n\nInput: s = \"00000000\"\nOutput: 0\n\nPrecondition: 0 <= len(s) <= 10^5\ns consists only of '0's and '1's.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        cnt = 0\n        for i in range(0, len(s), 2):\n            if len(set(s[i:i + 2])) > 1:\n                cnt += 1\n                \n        print(s)\n        return cnt\n"}
{"task_id": "python/70", "content": "\nInput Format\nThe first line contains an integer t, the number of test cases.\nFor each test case, there are two lines.\nThe first line contains two space-separated integers n and k, the number of integers and the target sum.\nThe second line contains n space-separated integers nums[i].\n\nConstraints\n1≤t≤50\n1≤n≤105\n1≤k≤109\n1≤nums[i]≤109\n\nOutput Format\nFor each test case, print the length of the longest subsequence of nums that sums up to target. If no such subsequence exists, print -1 instead.\n\nSample Input\n2\n4 3\n1 2 3 4\n5 3\n1 2 3 4 5\n\nSample Output\n3\n-1\n\nExplanation\n\nTest case 1: The longest subsequence of nums that sums up to 3 is [1, 2, 3]. Thus, we print 3 as the answer.\n\nTest case 2: There is no subsequence of nums that sums up to 3. Thus, we print -1 as the answer.\n", "groundtruth": "\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        f = [0] + [-inf] * target\n        s = 0\n        for x in nums:\n            s = min(s + x, target)\n            for j in range(s, x - 1, -1):\n                # f[j] = max(f[j], f[j - x] + 1)\n                if f[j] < f[j - x] + 1:\n                    f[j] = f[j - x] + 1\n        return f[-1] if f[-1] > 0 else -1\n"}
{"task_id": "python/71", "content": "\nThe correct answer is 25.", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/72", "content": "\nInput Format:\nThe first line contains three space-separated integers m, n, and k, respectively. The next k lines contain two space-separated integers each. The ith line contains two space-separated integers x and y, denoting the horizontal and vertical fences, respectively.\n\nConstraints:\n1 ≤ m, n ≤ 100\n1 ≤ k ≤ min(m, n)\n1 ≤ x ≤ m\n1 ≤ y ≤ n\nAll fences are distinct.\n\nOutput Format:\nOutput the maximum area of a square field that can be formed by removing some fences (possibly none) or -1 if it is impossible to make a square field.\n\nSample Input 1:\n2 3 2\n1 2\n2 3\n\nSample Output 1:\n9\n\nExplanation 1:\nThe maximum square field that can be formed by removing the two vertical fences is the square field with area 9 (the field is surrounded by the horizontal fences).\n\nSample Input 2:\n3 3 3\n1 2\n2 3\n3 1\n\nSample Output 2:\n9\n\nExplanation 2:\nThe maximum square field that can be formed by removing the three vertical fences is the square field with area 9 (the field is surrounded by the horizontal fences).\n\nSample Input 3:\n3 3 2\n1 1\n2 2\n\nSample Output 3:\n4\n\nExplanation 3:\nThe maximum square field that can be formed by removing the two vertical fences is the square field with area 4 (the field is surrounded by the horizontal fences).\n\nSample Input 4:\n3 3 1\n2 1\n\nSample Output 4:\n-1\n\nExplanation 4:\nThere is no way to form a square field by removing any fences.\n\nSample Input 5:\n2 2 1\n1 1\n\nSample Output 5:\n4\n\nExplanation 5:\nThe maximum square field that can be formed by removing the vertical fence is the square field with area 4 (the field is surrounded by the horizontal fences).\n", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/73", "content": "\n\nExample 1:\n\nInput: source = \"abb\", target = \"bab\", original = [\"a\",\"a\",\"b\"], changed = [\"b\",\"b\",\"a\"], cost = [1,2,3]\nOutput: 3\nExplanation:\n- Convert 'a' to 'b' at index 0.\n  \"abb\"  -> \"bab\"  (cost = 1)\n- Convert 'a' to 'b' at index 1.\n  \"bab\"  -> \"bba\"  (cost = 2)\n- Convert 'b' to 'a' at index 0.\n  \"bba\"  -> \"aba\"  (cost = 3)\nThe minimum cost to convert \"abb\" to \"aba\" is 1 + 2 + 3 = 6.\nExample 2:\n\nInput: source = \"ab\", target = \"ba\", original = [\"a\",\"b\"], changed = [\"b\",\"a\"], cost = [1,1]\nOutput: 2\nExplanation:\n- Convert 'a' to 'b' at index 0.\n  \"ab\"  -> \"ba\"  (cost = 1)\n- Convert 'b' to 'a' at index 0.\n  \"ba\"  -> \"ab\"  (cost = 2)\nThe minimum cost to convert \"ab\" to \"ba\" is 1 + 2 = 3.\n\n\nConstraints:\n\nn == source.length == target.length\n2 <= n <= 10^5\nsource, target, original, and changed consist of lowercase English letters.\noriginal and changed contain at most 50 distinct letters.\noriginal and changed are in the same order.\n1 <= cost.length <= 100\n1 <= cost[i] <= 100\n\n\n", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        dis = [[inf] * 26 for _ in range(26)]\n        for i in range(26):\n            dis[i][i] = 0\n\n        for x, y, c in zip(original, changed, cost):\n            x = ord(x) - ord('a')\n            y = ord(y) - ord('a')\n            dis[x][y] = min(dis[x][y], c)\n\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/74", "content": "\n\n", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/75", "content": "\nThe code is as follows:\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        inf = 10 ** 18\n        memo = {}\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == len(source):\n                return 0\n            if i not in memo:\n                ans = inf\n                for j in range(i, len(source)):\n                    if source[i:j+1] in original:\n                        k = original.index(source[i:j+1])\n                        if changed[k] == source[i:j+1]:\n                            ans = min(ans, dfs(j+1) + cost[k])\n                        else:\n                            ans = min(ans, dfs(j+1) + cost[k] + 1)\n                memo[i] = ans\n            return memo[i]\n\n        ans = dfs(0)\n        return ans if ans < inf else -1\n\n", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "cpp/0", "content": "", "groundtruth": "class Solution {public:static const int mod = 1e9 + 7;int specialPerm(vector<int>& nums) {int n = nums.size();vector<vector<int>> f(1 << n, vector<int>(n, -1));function<int(int, int)> dfs = [&](int state, int i) {if (f[state][i] != -1) {return f[state][i];}if (state == (1 << i)) {return 1;}f[state][i] = 0;for (int j = 0; j < n; j++) {if (i == j || !(state >> j & 1)) {continue;}if (nums[i] % nums[j] != 0 && nums[j] % nums[i] != 0) {continue;}f[state][i] = (f[state][i] + dfs(state ^ (1 << i), j)) % mod;}return f[state][i];};int res = 0;for (int i = 0; i < n; i++) {res = (res + dfs((1 << n) - 1, i)) % mod;}return res;}};"}
{"task_id": "cpp/1", "content": "\n \n\nExample 1:\n\nInput: cost = [1,5,10], time = [2,3,4]\nOutput: 9\nExplanation: \nThe cost of painting the walls is:\nPaint the first wall by the paid painter for 1 unit of time and 1 cost, total cost is 1.\nPaint the second wall by the paid painter for 5 units of time and 5 costs, total cost is 5 + 1 = 6.\nPaint the third wall by the paid painter for 10 units of time and 10 costs, total cost is 10 + 6 = 16.\nThe minimum total cost is 16.\n\n\n \n\nConstraints:\n\nn == cost.length == time.length\n1 <= n <= 10^4\n1 <= cost[i], time[i] <= 10^4\n", "groundtruth": "class Solution {public:int paintWalls(vector<int>& cost, vector<int>& time) {int n = cost.size();vector<int> f(n * 2 + 1, INT_MAX / 2);f[n] = 0;for (int i = 0; i < n; ++i) {vector<int> g(n * 2 + 1, INT_MAX / 2);for (int j = 0; j <= n * 2; ++j) {// 付费g[min(j + time[i], n * 2)] = min(g[min(j + time[i], n * 2)], f[j] + cost[i]);// 免费if (j > 0) {g[j - 1] = min(g[j - 1], f[j]);}}f = move(g);}return *min_element(f.begin() + n, f.end());}};"}
{"task_id": "cpp/2", "content": "\nThe given code is as follows:\nclass Solution {public:string smallestString(string s) {char target = 'a';auto it = std::find_if(s.begin(), s.end(), [target](char c) {return c != target;});int indexOfFirstNonA = std::distance(s.begin(), it);if (indexOfFirstNonA == s.length()) {return s.substr(0, s.length() - 1) + 'z';}size_t indexOfFirstA_AfterFirstNonA = s.find('a', indexOfFirstNonA);if (____) {indexOfFirstA_AfterFirstNonA = s.length();}string res;for (int i = 0; i < s.length(); ++i) {if (____) {res.push_back(static_cast<char>(s[i] - 1));} else {res.push_back(s[i]);}}return res;}};\n\nThe completed code is as follows:\nclass Solution {public:string smallestString(string s) {char target = 'a';auto it = std::find_if(s.begin(), s.end(), [target](char c) {return c != target;});int indexOfFirstNonA = std::distance(s.begin(), it);if (indexOfFirstNonA == s.length()) {return s.substr(0, s.length() - 1) + 'z';}size_t indexOfFirstA_AfterFirstNonA = s.find('a', indexOfFirstNonA);if (indexOfFirstA_AfterFirstNonA == s.length()) {indexOfFirstA_AfterFirstNonA = s.length();}string res;for (int i = 0; i < s.length(); ++i) {if (i >= indexOfFirstNonA && i < indexOfFirstA_AfterFirstNonA) {res.push_back(static_cast<char>(s[i] - 1));} else {res.push_back(s[i]);}}return res;}};\n\nThe completed code is as follows:\nclass Solution {public:string smallestString(string s) {char target = 'a';auto it = std::find_if(s.begin(), s.end(), [target](char", "groundtruth": "class Solution {public:string smallestString(string s) {char target = 'a';auto it = std::find_if(s.begin(), s.end(), [target](char c) {return c != target;});int indexOfFirstNonA = std::distance(s.begin(), it);if (indexOfFirstNonA == s.length()) {return s.substr(0, s.length() - 1) + 'z';}size_t indexOfFirstA_AfterFirstNonA = s.find('a', indexOfFirstNonA);if (indexOfFirstA_AfterFirstNonA == string::npos) {indexOfFirstA_AfterFirstNonA = s.length();}string res;for (int i = 0; i < s.length(); ++i) {if (indexOfFirstNonA <= i && i < indexOfFirstA_AfterFirstNonA) {res.push_back(static_cast<char>(s[i] - 1));} else {res.push_back(s[i]);}}return res;}};"}
{"task_id": "cpp/3", "content": "", "groundtruth": "class Solution {public:long long minCost(vector<int>& nums, int x) {int n = nums.size();vector<int> f(nums);long long ans = accumulate(f.begin(), f.end(), 0LL);for (int k = 1; k < n; ++k) {for (int i = 0; i < n; ++i) {f[i] = min(f[i], nums[(i + k) % n]);}ans = min(ans, static_cast<long long>(k) * x + accumulate(f.begin(), f.end(), 0LL));}return ans;}};"}
{"task_id": "cpp/4", "content": "\n", "groundtruth": "class Solution {public:vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {vector<pair<int, int>> sortedNums;vector<tuple<int, int, int>> sortedQueries;for (int i = 0; i < nums1.size(); i++) {sortedNums.emplace_back(nums1[i], nums2[i]);}sort(sortedNums.begin(), sortedNums.end(), greater<pair<int, int>>());for (int i = 0; i < queries.size(); i++) {sortedQueries.emplace_back(i, queries[i][0], queries[i][1]);}sort(sortedQueries.begin(), sortedQueries.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b) {return get<1>(a) > get<1>(b);});vector<pair<int, int>> stk;vector<int> answer(queries.size(), -1);int j = 0;for (auto &[i, x, y] : sortedQueries) {while (j < sortedNums.size() && sortedNums[j].first >= x) {auto [num1, num2] = sortedNums[j];while (!stk.empty() && stk.back().second <= num1 + num2) {stk.pop_back();}if (stk.empty() || stk.back().first < num2) {stk.emplace_back(num2, num1 + num2);}j++;}int k = lower_bound(stk.begin(), stk.end(), make_pair(y, 0)) - stk.begin();if (k < stk.size()) {answer[i] = stk[k].second;}}return answer;}};"}
{"task_id": "cpp/5", "content": "", "groundtruth": "class Solution {public:int longestSemiRepetitiveSubstring(string s) {int ans = 1, left = 0, same = 0, n = s.length();for (int right = 1; right < n; right++) {if (s[right] == s[right - 1] && ++same > 1) {for (left++; s[left] != s[left - 1]; left++);same = 1;}ans = max(ans, right - left + 1);}return ans;}};"}
{"task_id": "cpp/6", "content": "The code is incomplete because the positions of robots have not been determined. You should complete the code to determine the positions of robots and then find the sum of distances between all the pairs of robots.\nThe position of robot i is represented by pos[i] (where 0 <= i < n).\nIf two robots collide, their positions will be represented by pos[i] and pos[j] (where 0 <= i, j < n and i != j).\n\nNote:\nThe positions of the robots are given in an array. The direction in which the robots move is given by a string.\nThe number of robots and the direction in which they move is given.\nThe distance between two robots will be calculated by their positions.\n\nExample 1:\nInput: nums = [4,3,2,1], s = \"LRL\", d = 2\nOutput: 6\nExplanation: The positions of the robots after 2 seconds are:\nRobot 0: 4 -> 6 -> 7 (7 units to the right, relative to the starting position 4)\nRobot 1: 3 -> 3 -> 2 (2 units to the left, relative to the starting position 3)\nRobot 2: 2 -> 2 -> 2 (no change, since it is already at position 2)\nRobot 3: 1 -> 1 -> 1 (no change, since it is already at position 1)\nThe distances between the pairs of robots after 2 seconds are:\nRobot 0 and Robot 1: 3 - 3 = 0\nRobot 0 and Robot 2: 7 - 2 = 5\nRobot 0 and Robot 3: 7 - 1 = 6\nRobot 1 and Robot 2: 3 - 2 = 1\nRobot 1 and Robot 3: 3 - 1 = 2\nRobot 2 and Robot 3: 2 - 1 = 1\nThe sum of these distances is 6.\n\nExample 2:\nInput: nums = [1,2,3,4], s = \"LLR\", d = 1\nOutput: 4\nExplanation: The positions of the", "groundtruth": "class Solution {public:static constexpr int mod = 1e9 + 7;int sumDistance(vector<int>& nums, string s, int d) {int n = nums.size();vector<long long> pos(n);for (int i = 0; i < n; i++) {if (s[i] == 'L') {pos[i] = (long long) nums[i] - d;} else {pos[i] = (long long) nums[i] + d;}}sort(pos.begin(), pos.end());long long res = 0;for (int i = 1; i < n; i++) {res += 1ll * (pos[i] - pos[i - 1]) * i % mod * (n - i) % mod;res %= mod;}return res;}};"}
{"task_id": "cpp/7", "content": "\n \n\nExample 1:\n\nInput: grid = [[0,0],[0,1]]\nOutput: [0,1]\nExplanation: The subset of rows with indexes 0 and 1 is a good subset because their sum of columns is at most half of the length of the subset.\nExample 2:\n\nInput: grid = [[0,0],[1,1]]\nOutput: [0,1]\nExplanation: The subset of rows with indexes 0 and 1 is a good subset because their sum of columns is at most half of the length of the subset.\nExample 3:\n\nInput: grid = [[0,0],[0,1],[1,1],[1,0]]\nOutput: [0,1,2,3]\nExplanation: The subset of rows with indexes 0, 1, 2, and 3 is a good subset because their sum of columns is at most half of the length of the subset.\n \n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\ngrid[i][j] is either 0 or 1\n\n \n\nFollow up: Could you find a solution with minimum number of rows?\n\n \n\nNote:\n\nThis problem is the same as Problem 932 on LeetCode.\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n", "groundtruth": "class Solution {public:vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {vector<int> ans;unordered_map<int, int> mp;int m = grid.size();int n = grid[0].size();for (int j = 0; j < m; j++) {int st = 0;for (int i = 0; i < n; i++) {st |= (grid[j][i] << i);}mp[st] = j;}if (mp.count(0)) {ans.push_back(mp[0]);return ans;}for (auto [x, i]: mp) {for (auto [y, j]: mp) {if (!(x & y)) {return {min(i, j), max(i, j)};}}}return ans;}};"}
{"task_id": "cpp/8", "content": "\nNote: The returned answer is guaranteed to fit in a signed 64-bit integer.\nExample 1:\nInput: n = 3, queries = [[1,1,1],[2,2,2],[3,3,3]]\nOutput: 15\nExplanation:\nInitially, the matrix is all 0's.\nApplying the first query: queries[0] = [1, 1, 1]:\nThe matrix becomes [[1, 1, 1], [0, 0, 0], [0, 0, 0]].\nApplying the second query: queries[1] = [2, 2, 2]:\nThe matrix becomes [[1, 1, 1], [2, 2, 2], [0, 0, 0]].\nApplying the third query: queries[2] = [3, 3, 3]:\nThe matrix becomes [[1, 1, 1], [2, 2, 2], [3, 3, 3]].\nThe sum of all the elements in the matrix is 15.\nExample 2:\nInput: n = 2, queries = [[1,1,1],[2,2,2]]\nOutput: 4\nExplanation:\nInitially, the matrix is all 0's.\nApplying the first query: queries[0] = [1, 1, 1]:\nThe matrix becomes [[1, 1], [1, 1]].\nApplying the second query: queries[1] = [2, 2, 2]:\nThe matrix becomes [[2, 2], [2, 2]].\nThe sum of all the elements in the matrix is 4.\n\nConstraints:\n\n1 <= n <= 500\n1 <= queries.length <= 500\nqueries[i].length == 3\n0 <= queries[i][0] <= 1\n0 <= queries[i][1] < n\n0 <= queries[i][2] <= 1000\nAll values in queries are unique.\n\n", "groundtruth": "class Solution {public:long long matrixSumQueries(int n, vector<vector<int>> &queries) {long long ans = 0;unordered_set<int> vis[2];for (int i = queries.size() - 1; i >= 0; i--) {auto &q = queries[i];int type = q[0], index = q[1], val = q[2];if (!vis[type].count(index)) { // 后面（>i）没有对这一行/列的操作// 这一行/列还剩下 n-vis[type^1].size() 个可以填入的格子ans += (long long) (n - vis[type ^ 1].size()) * val;vis[type].insert(index);}}return ans;}};"}
{"task_id": "cpp/9", "content": "\nExample 1:\nInput: num1 = \"1010\", num2 = \"1010\", min_sum = 1, max_sum = 2\nOutput: 4\nExplanation: 1010, 1011, 1012, 1013 are good numbers.\nExample 2:\nInput: num1 = \"1010\", num2 = \"1010\", min_sum = 1, max_sum = 3\nOutput: 8\nExplanation: 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017 are good numbers.\nExample 3:\nInput: num1 = \"1010\", num2 = \"1010\", min_sum = 1, max_sum = 4\nOutput: 9\nExplanation: 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018 are good numbers.\n\nConstraints:\nnum1.length == num2.length == 4\nnum1 <= num2\n1 <= min_sum <= max_sum <= 10\n", "groundtruth": "class Solution {static constexpr int N = 23;static constexpr int M = 401;static constexpr int MOD = 1e9 + 7;int d[N][M];string num;int min_sum;int max_sum;int dfs(int i, int j, bool limit) {if (j > max_sum) {return 0;}if (i == -1) {return j >= min_sum;}if (!limit && d[i][j] != -1) {return d[i][j];}int res = 0;int up = limit ? num[i] - '0' : 9;for (int x = 0; x <= up; x++) {res = (res + dfs(i - 1, j + x, limit && x == up)) % MOD;}if (!limit) {d[i][j] = res;}return res;}int get(string num) {reverse(num.begin(), num.end());this->num = num;return dfs(num.size() - 1, 0, true);}// 求解 num - 1，先把最后一个非 0 字符减去 1，再把后面的 0 字符变为 9string sub(string num) {int i = num.size() - 1;while (num[i] == '0') {i--;}num[i]--;i++;while (i < num.size()) {num[i] = '9';i++;}return num;}public:int count(string num1, string num2, int min_sum, int max_sum) {memset(d, -1, sizeof d);this->min_sum = min_sum;this->max_sum = max_sum;return (get(num2) - get(sub(num1)) + MOD) % MOD;}};"}
{"task_id": "cpp/10", "content": "", "groundtruth": "class Solution {public:int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {int n = mat.size();int m = mat[0].size();unordered_map<int, pair<int, int>> mp;for (int i = 0; i < n; ++i) {for (int j = 0; j < m; ++j) {mp[mat[i][j]] = {i, j};}}vector<int> rowCnt(n, 0);vector<int> colCnt(m, 0);for (int i = 0; i < arr.size(); ++i) {auto& v = mp[arr[i]];++rowCnt[v.first];if (rowCnt[v.first] == m) {return i;}++colCnt[v.second];if (colCnt[v.second] == n) {return i;}}return -1;}};"}
{"task_id": "cpp/11", "content": "", "groundtruth": "class Solution {public:int minimumCost(vector<int> &start, vector<int> &target, vector <vector<int>> &specialRoads) {using LL = long long;LL t = (LL) target[0] << 32 | target[1];unordered_map<LL, int> dis = {{(LL) start[0] << 32 | start[1], 0}, {t, INT_MAX}};unordered_set<LL> vis;for (;;) {LL v = -1;int dv = -1;for (auto &[p, d]: dis)if (!vis.count(p) && (dv < 0 || d < dv))v = p, dv = d;if (v == t) return dv; // 到终点的最短路已确定vis.insert(v);int vx = v >> 32, vy = v & UINT32_MAX;// 更新到终点的最短路dis[t] = min(dis[t], dv + target[0] - vx + target[1] - vy);for (auto &r: specialRoads) {int d = dv + abs(r[0] - vx) + abs(r[1] - vy) + r[4];LL w = (LL) r[2] << 32 | r[3];if (!dis.count(w) || d < dis[w])dis[w] = d;}}}};"}
{"task_id": "cpp/12", "content": "\n\n\nNote: The input string will only contain lower case letters.\nExample 1:\nInput: s = \"aabcb\", k = 4\nOutput: \"aabcc\"\nExplanation: The longest beautiful subString is \"aabcc\".\nExample 2:\nInput: s = \"aabcbaa\", k = 3\nOutput: \"aabccba\"\nExplanation: The longest beautiful subString is \"aabccba\".\n\n\nConstraints:\n\n1 <= s.length <= 500\n1 <= k <= 10\ns consists of lower case English letters.\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    string smallestBeautifulString(string s, int k) {\n        for (int i = s.length() - 1; i >= 0; --i) {\n            unordered_set<char> blockedCharacters;\n            for (int j = 1; j <= 2; ++j) {\n                if (i - j >= 0) {\n                    blockedCharacters.insert(s[i - j]);\n                }\n            }\n            for (int j = 1; j <= 3; ++j) {\n                if (s[i] - 'a' + j + 1 <= k && blockedCharacters.find(s[i] + j) == blockedCharacters.end()) {\n                    return generate(s, i, j);\n                }\n            }\n        }\n        return \"\";\n    }\n\n    string generate(string s, int idx, int offset) {\n        s[idx] += offset;\n        for (int i = idx + 1; i < s.length(); ++i) {\n            unordered_set<char> blockedCharacters;\n            for (int j = 1; j <= 2; ++j) {\n                if (i - j >= 0) {\n                    blockedCharacters.insert(s[i - j]);\n                }\n            }\n            for (int j = 0; j < 3; ++j) {\n                if (blockedCharacters.find('a' + j) == blockedCharacters.end()) {\n                    s[i]", "groundtruth": "class Solution {public:string smallestBeautifulString(string s, int k) {for (int i = s.length() - 1; i >= 0; --i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {____}}for (int j = 1; j <= 3; ++j) {if (s[i] - 'a' + j + 1 <= k && blockedCharacters.find(s[i] + j) == blockedCharacters.end()) {return generate(s, i, j);}}}return \"\";}string generate(string s, int idx, int offset) {s[idx] += offset;for (int i = idx + 1; i < s.length(); ++i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {blockedCharacters.insert(s[i - j]);}}for (int j = 0; j < 3; ++j) {if (____) {s[i] = 'a' + j;break;}}}return s;}};"}
{"task_id": "cpp/13", "content": "\nclass Solution {public:\n    vector<int> findThePrefixCommonArray(vector<int> &a, vector<int> &b) {\n        int n = a.size();\n        vector<int> ans(n);\n        long long p = 0, q = 0;\n        for (int i = 0; i < n; ++i) {\n            p |= 1LL << a[i];\n            q |= 1LL << b[i];\n        }\n        for (int i = 0; i < n; ++i) {\n            if (p & q) {\n                ans[i] = 1;\n                p ^= 1LL << a[i];\n                q ^= 1LL << b[i];\n            }\n        }\n        return ans;\n    }\n};\n", "groundtruth": "class Solution {public:vector<int> findThePrefixCommonArray(vector<int> &a, vector<int> &b) {int n = a.size();vector<int> ans(n);long long p = 0, q = 0;for (int i = 0; i < n; ++i) {p |= 1LL << a[i];q |= 1LL << b[i];ans[i] = __builtin_popcountll(p & q);}return ans;}};"}
{"task_id": "cpp/14", "content": "Example 1:\nInput: grid = [[0,0,0,0,0,0],[0,1,1,0,0,0],[0,1,1,0,0,0],[0,0,0,0,0,0],[0,0,0,1,1,0],[0,0,0,1,1,0]]\nOutput: 16\nExplanation:\n- Catch fish at (0, 0)\n- Catch fish at (0, 1)\n- Catch fish at (1, 0)\n- Catch fish at (1, 1)\n- Catch fish at (2, 0)\n- Catch fish at (2, 1)\nExample 2:\nInput: grid = [[0,0,0,0,0,0]]\nOutput: 0\n \n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 50\ngrid[i][j] is either 0 or 1.\n\n\n\n\n\n\n\n\nclass Solution {\n    static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\npublic:\n    int findMaxFish(vector<vector<int>> &grid) {\n        int m = grid.size(), n = grid[0].size(), ans = 0;\n        function<int(int, int)> dfs = [&](int x, int y) -> int {\n            if (x < 0 || x >= m || y < 0 || y >= n) return 0;\n            int sum = grid[x][y];\n            grid[x][y] = 0; // 标记成访问过\n            for (auto &d: dirs) // 四方向移动\n                sum += dfs(x + d[0], y + d[1]);\n            return sum;\n        };\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                ans = max(ans, dfs(i, j));", "groundtruth": "class Solution {static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};public:int findMaxFish(vector<vector<int>> &grid) {int m = grid.size(), n = grid[0].size(), ans = 0;function<int(int, int)> dfs = [&](int x, int y) -> int {if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)return 0;int sum = grid[x][y];grid[x][y] = 0; // 标记成访问过for (auto &d: dirs) // 四方向移动sum += dfs(x + d[0], y + d[1]);return sum;};for (int i = 0; i < m; ++i)for (int j = 0; j < n; ++j)ans = max(ans, dfs(i, j));return ans;}};"}
{"task_id": "cpp/15", "content": "\nclass BIT {\n    vector<int> tree;\npublic:\n    BIT(int n) : tree(n) {}\n    // 将下标 i 上的数加一\n    void inc(int i) {\n        while (i < tree.size()) {\n            ++tree[i];\n            i += i & -i;\n        }\n    }\n    // 返回闭区间 [1, i] 的元素和\n    int sum(int x) {\n        int res = 0;\n        while (x > 0) {\n            res += tree[x];\n            x &= x - 1;\n        }\n        return res;\n    }\n    // 返回闭区间 [left, right] 的元素和\n    int query(int left, int right) {\n        return sum(right) - sum(left - 1);\n    }\n};\n\nclass Solution {\npublic:\n    long long countOperationsToEmptyArray(vector<int> &nums) {\n        int n = nums.size(), id[n];\n        iota(id, id + n, 0);\n        sort(id, id + n, [&](int i, int j) {\n            return nums[i] < nums[j];\n        });\n        long long ans = n; // 先把 n 计入答案\n        BIT t(n + 1); // 下标从 1 开始\n        int pre = 1; // 上一个最小值的位置，初始为 1\n        for (int k = 0; k < n; ++k) {\n            int i = id[k] + 1; // 下标从 1 开始\n            if (i >= pre) // 从 pre 移动到 i，跳过已经删除的数\n                t.inc(i);\n            else // 从 pre 移动到 n，再从 1 移动到 i，跳过已经删除的数\n                t.inc(n + 1 - pre + i);\n            // 删除 i\n           ", "groundtruth": "// 树状数组模板class BIT {vector<int> tree;public:BIT(int n) : tree(n) {}// 将下标 i 上的数加一void inc(int i) {while (i < tree.size()) {++tree[i];i += i & -i;}}// 返回闭区间 [1, i] 的元素和int sum(int x) {int res = 0;while (x > 0) {res += tree[x];x &= x - 1;}return res;}// 返回闭区间 [left, right] 的元素和int query(int left, int right) {return sum(right) - sum(left - 1);}};class Solution {public:long long countOperationsToEmptyArray(vector<int> &nums) {int n = nums.size(), id[n];iota(id, id + n, 0);sort(id, id + n, [&](int i, int j) {return nums[i] < nums[j];});long long ans = n; // 先把 n 计入答案BIT t(n + 1); // 下标从 1 开始int pre = 1; // 上一个最小值的位置，初始为 1for (int k = 0; k < n; ++k) {int i = id[k] + 1; // 下标从 1 开始if (i >= pre) // 从 pre 移动到 i，跳过已经删除的数ans += i - pre - t.query(pre, i);else // 从 pre 移动到 n，再从 1 移动到 i，跳过已经删除的数ans += n - pre + i - k + t.query(i, pre - 1);t.inc(i); // 删除 ipre = i;}return ans;}};"}
{"task_id": "cpp/16", "content": "\n\nInput: nums = [1,2,3], k = 1, x = 2\nOutput: [2,2,2]\nExplanation: The first subarray is [1], the second is [2], and the third is [3].\nThe beauty of the first subarray is 2 because the second number in the subarray is 2, and there are fewer than 2 negative numbers in the subarray.\nThe beauty of the second subarray is 2 because the second number in the subarray is 2, and there are fewer than 2 negative numbers in the subarray.\nThe beauty of the third subarray is 2 because there is only one number in the subarray, and there are no negative numbers in the subarray.\nInput: nums = [1,2,3], k = 2, x = 1\nOutput: [0,0,0]\nExplanation: The first subarray is [1,2], the second is [2,3], and the third is [3].\nThe beauty of the first subarray is 0 because there is only one number in the subarray, and there are no negative numbers in the subarray.\nThe beauty of the second subarray is 0 because there is only one number in the subarray, and there are no negative numbers in the subarray.\nThe beauty of the third subarray is 0 because there is only one number in the subarray, and there are no negative numbers in the subarray.\nInput: nums = [-1,-1,1,2,3], k = 3, x = 2\nOutput: [2,2,2,0,0]\nExplanation: The first subarray is [-1,-1,1], the second is [-1,1,2], the third is [1,2,3], the fourth is [2,3], and the fifth is [3].\nThe beauty of the first subarray is 2 because the third number in the subarray is 2, and there are fewer than 2 negative numbers in the subarray.\nThe beauty of the second subarray is 2 because the third number in the subarray is 2, and there are fewer than 2 negative numbers in the subarray.\nThe beauty of the third subarray is 2 because the third number in the sub", "groundtruth": "class Solution {public:vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x) {const int BIAS = 50;int cnt[BIAS * 2 + 1]{}, n = nums.size();for (int i = 0; i < k - 1; ++i) // 先往窗口内添加 k-1 个数++cnt[nums[i] + BIAS];vector<int> ans(n - k + 1);for (int i = k - 1; i < n; ++i) {++cnt[nums[i] + BIAS]; // 进入窗口（保证窗口有恰好 k 个数）int left = x;for (int j = 0; j < BIAS; ++j) { // 暴力枚举负数范围 [-50,-1]left -= cnt[j];if (left <= 0) { // 找到美丽值ans[i - k + 1] = j - BIAS;break;}}--cnt[nums[i - k + 1] + BIAS]; // 离开窗口}return ans;}};"}
{"task_id": "cpp/17", "content": "The input is assumed to be legal.\n \n\nExample 1:\nInput: nums = [1,2,3]\nOutput: 2\nExplanation: One optimal solution is to make nums = [1, 1, 1].\nThe other optimal solution is to make nums = [1, 2, 1].\nBoth have the same GCD value.\nExample 2:\nInput: nums = [1,2,3,4,5,6]\nOutput: 5\nExplanation: One optimal solution is to make nums = [1, 2, 3, 4, 5, 6].\nExample 3:\nInput: nums = [1,2,3,4,5,6,7,8,9,10]\nOutput: -1\nExplanation: It is impossible to make all the elements equal to 1.\n \n\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n\n```\n/*\n * @lc app=leetcode id=2061 lang=cpp\n *\n * [2061] Minimum Number of Operations to Make a Subsequence\n */\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n        int n = nums.size(), gcd_all = 0, cnt1 = 0;\n        for (int x: nums) {\n            gcd_all = gcd(gcd_all, x);\n            if (x == 1) cnt1++;\n        }\n        if (gcd_all > 1) return -1;\n        if (cnt1) return n - cnt1;\n        int min_size = n;\n        for (int i = 0; i < n; ++i) {\n            int g = 0;\n            for (int j = i; j < n; ++j) {\n                g = gcd(g, nums[j]);\n                if (g == 1) {\n                    min_size = min(min_size, j - i + 1);\n                    break;\n                }\n            }\n", "groundtruth": "class Solution {public:int minOperations(vector<int> &nums) {int n = nums.size(), gcd_all = 0, cnt1 = 0;for (int x: nums) {gcd_all = gcd(gcd_all, x);cnt1 += x == 1;}if (gcd_all > 1) return -1;if (cnt1) return n - cnt1;int min_size = n;for (int i = 0; i < n; ++i) {int g = 0;for (int j = i; j < n; ++j) {g = gcd(g, nums[j]);if (g == 1) {// 这里本来是 j-i+1，把 +1 提出来合并到 return 中min_size = min(min_size, j - i);break;}}}return min_size + n - 1;}};"}
{"task_id": "cpp/18", "content": "\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6], divisors = [1,2,3,4,5,6]\nOutput: 6\nExplanation: The divisibility score of 6 is 6 because for each integer in nums, there is an integer in divisors that divides it evenly.\nExample 2:\n\nInput: nums = [1,2,3,4,5,6], divisors = [1,2,3]\nOutput: 3\nExplanation: The divisibility score of 3 is 3 because for each integer in nums, there is an integer in divisors that divides it evenly.\nExample 3:\n\nInput: nums = [1,2,3,4,5,6], divisors = [11,12,13]\nOutput: 1\nExplanation: The only divisor in divisors that divides all the integers in nums is 1.\n \n\nConstraints:\n\n1 <= nums.length <= 10^5\n1 <= nums[i], divisors[i] <= 10^5\nnums and divisors are strictly increasing.\n\n \n\nFollow up: Can you do this in O(n) time?\n", "groundtruth": "class Solution {public:int maxDivScore(vector<int>& nums, vector<int>& divisors) {int cnt = -1, ans = 0;for (int i = 0; i < divisors.size(); i++) {int tmp = 0;for (int j = 0; j < nums.size(); j++) {if (nums[j] % divisors[i] == 0) {tmp++;}}if (tmp > cnt || (tmp == cnt && divisors[i] < ans)) {ans = divisors[i];cnt = tmp;}}return ans;}};"}
{"task_id": "cpp/19", "content": "\nclass Solution {public:int addMinimum(string word) {int n = word.size();vector<int> d(n + 1);for (int i = 1; i <= n; i++) {if (i >= 2 && word[i - 2] == word[i - 1] && word[i - 1] == word[i]) {d[i] = d[i - 2] + 1;}}for (int i = 1; i <= n; i++) {if (word[i - 1] == 'a' || word[i - 1] == 'b' || word[i - 1] == 'c') {d[i] = min(d[i], d[i - 1] + 1);}}return d[n];}};\n", "groundtruth": "class Solution {public:int addMinimum(string word) {int n = word.size();vector<int> d(n + 1);for (int i = 1; i <= n; i++) {d[i] = d[i - 1] + 2;if (i > 1 && word[i - 1] > word[i - 2]) {d[i] = d[i - 1] - 1;}}return d[n];}};"}
{"task_id": "cpp/20", "content": "", "groundtruth": "class Solution {public:int minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips) {vector<vector<int>> next(n);for (auto &edge : edges) {next[edge[0]].push_back(edge[1]);next[edge[1]].push_back(edge[0]);}vector<int> count(n);function<bool(int, int, int)> dfs = [&](int node, int parent, int end) -> bool {if (node == end) {count[node]++;return true;}for (int child : next[node]) {if (child == parent) {continue;}if (dfs(child, node, end)) {count[node]++;return true;}}return false;};for (auto &trip: trips) {dfs(trip[0], -1, trip[1]);}function<pair<int, int>(int, int)> dp = [&](int node, int parent) -> pair<int, int> {pair<int, int> res = {price[node] * count[node], price[node] * count[node] / 2};for (int child : next[node]) {if (child == parent) {continue;}auto [x, y] = dp(child, node);res.first += min(x, y); // node 没有减半，因此可以取子树的两种情况的最小值res.second += x; // node 减半，只能取子树没有减半的情况}return res;};auto [x, y] = dp(0, -1);return min(x, y);}};"}
{"task_id": "cpp/21", "content": "\n \n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [1,2,3]\nExplanation: The conversion array is [1, 2, 3]:\n- nums[0] = 1 is converted to 1 + max(nums[0..0]) = 1 + 1 = 2\n- nums[1] = 2 is converted to 2 + max(nums[0..1]) = 2 + 2 = 4\n- nums[2] = 3 is converted to 3 + max(nums[0..2]) = 3 + 3 = 6\nThe score of the prefix nums[0..0] is 1, and the score of the prefix nums[0..1] is 2.\nThe score of the prefix nums[0..2] is 3.\nExample 2:\n\nInput: nums = [100,100,100]\nOutput: [100,200,300]\nExplanation: The conversion array is [100, 200, 300]:\n- nums[0] = 100 is converted to 100 + max(nums[0..0]) = 100 + 100 = 200\n- nums[1] = 100 is converted to 100 + max(nums[0..1]) = 100 + 200 = 300\nThe score of the prefix nums[0..0] is 100, and the score of the prefix nums[0..1] is 200.\nThe score of the prefix nums[0..2] is 300.\n\n \n\nConstraints:\n\nn == nums.length\n1 <= n <= 105\n1 <= nums[i] <= 105\n\n", "groundtruth": "class Solution {public:vector<long long> findPrefixScore(vector<int>& nums) {vector<long long> ans;int tmp = nums[0];ans.push_back(nums[0] * 2);for (int i = 1; i < nums.size(); ++i) {if (nums[i] > tmp) tmp = nums[i];ans.push_back(nums[i] + tmp + ans[i - 1]);}return ans;}};"}
{"task_id": "cpp/22", "content": "\n\nExample 1:\nInput: root = [1,2,3,4,5,6,7]\nOutput: [1,2,3,4,5,6,7]\n\nExample 2:\nInput: root = [1,2,3,4,5]\nOutput: [1,2,3,4,5]\n\nConstraints:\nThe number of nodes in the tree is in the range [1, 2000].\nEach node in the tree has a distinct value between 1 and 100.\n\n\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    TreeNode* replaceValueInTree(TreeNode* root) {\n        vector<TreeNode*> q = {root};\n        root->val = 0;\n        while (!q.empty()) {\n            vector<TreeNode*> q2;\n            int sum = 0;\n            for (auto fa : q) {\n                if (fa->left) {\n                    q2.push_back(fa->left);\n                    sum += fa->left->val;\n                }\n                if (fa->right) {\n                    q2.push_back(fa->right);\n                    sum += fa->right->val;\n                }\n            }\n            for (auto fa : q) {\n                int child_sum = (fa->left ? fa->left->val : 0) + (fa->right ? fa->right->val : 0);\n                if (fa->left) {\n                    fa->left->val = sum - child_sum;\n                }\n                if (fa->right) {\n                    fa->right->val = sum - child_sum;\n                }\n            }\n            q = move(q2);\n        }\n        return root;\n    }\n};\n", "groundtruth": "class Solution {public:TreeNode* replaceValueInTree(TreeNode* root) {vector<TreeNode*> q = {root};root->val = 0;while (!q.empty()) {vector<TreeNode*> q2;int sum = 0;for (auto fa : q) {if (fa->left) {q2.push_back(fa->left);sum += fa->left->val;}if (fa->right) {q2.push_back(fa->right);sum += fa->right->val;}}for (auto fa : q) {int child_sum = (fa->left ? fa->left->val : 0) +(fa->right ? fa->right->val : 0);if (fa->left) {fa->left->val = sum - child_sum;}if (fa->right) {fa->right->val = sum - child_sum;}}q = move(q2);}return root;}};"}
{"task_id": "cpp/23", "content": "\nclass Graph {\npublic:\n    using pii = pair<int, int>;\n    Graph(int n, vector<vector<int>>& edges) {\n        this->graph = vector<vector<pii>>(n);\n        for (auto &vec : edges) {\n            int x = vec[0];\n            int y = vec[1];\n            int cost = vec[2];\n            graph[x].emplace_back(y, cost);\n        }\n    }\n\n    void addEdge(vector<int> edge) {\n        int x = edge[0];\n        int y = edge[1];\n        int cost = edge[2];\n        graph[x].emplace_back(y, cost);\n    }\n\n    int shortestPath(int node1, int node2) {\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\n        vector<int> dist(graph.size(), INT_MAX);\n        dist[node1] = 0;\n        pq.emplace(0, node1);\n        while (!pq.empty()) {\n            auto [cost, cur] = pq.top();\n            pq.pop();\n            if (cur == node2) {\n                return cost;\n            }\n            for (auto &next : graph[cur]) {\n                int ncost = next.second;\n                if (dist[next.first] > cost + ncost) {\n                    dist[next.first] = cost + ncost;\n                    pq.emplace(dist[next.first], next.first);\n                }\n            }\n        }\n        return -1;\n    }\n\nprivate:\n    vector<vector<pii>> graph;\n};", "groundtruth": "class Graph {public:using pii = pair<int, int>;Graph(int n, vector<vector<int>>& edges) {this->graph = vector<vector<pii>>(n);for (auto &vec : edges) {int x = vec[0];int y = vec[1];int cost = vec[2];graph[x].emplace_back(y, cost);}}void addEdge(vector<int> edge) {int x = edge[0];int y = edge[1];int cost = edge[2];graph[x].emplace_back(y, cost);}int shortestPath(int node1, int node2) {priority_queue<pii, vector<pii>, greater<pii>> pq;vector<int> dist(graph.size(), INT_MAX);dist[node1] = 0;pq.emplace(0, node1);while (!pq.empty()) {auto [cost, cur] = pq.top();pq.pop();if (cur == node2) {return cost;}for (auto [next, ncost] : graph[cur]) {if (dist[next] > cost + ncost) {dist[next] = cost + ncost;pq.emplace(cost + ncost, next);}}}return -1;}private:vector<vector<pii>> graph;};"}
{"task_id": "cpp/24", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {public:vector<long long> distance(vector<int> &nums) {int n = nums.size();unordered_map<int, vector<int>> groups;for (int i = 0; i < n; ++i)groups[nums[i]].push_back(i); // 相同元素分到同一组，记录下标vector<long long> ans(n);long long s[n + 1];s[0] = 0;for (auto &[_, a]: groups) {int m = a.size();for (int i = 0; i < m; ++i)s[i + 1] = s[i] + a[i]; // 前缀和for (int i = 0; i < m; ++i) {long long target = a[i];long long left = target * i - s[i]; // 蓝色面积long long right = s[m] - s[i] - target * (m - i); // 绿色面积ans[target] = left + right;}}return ans;}};"}
{"task_id": "cpp/25", "content": "\nExample 1:\nInput: nums = [2,3,5], p = 2\nOutput: 2\nExplanation: The optimal choice is to pick the following minima:\n- Index 1 (minimum of nums[1] - nums[0] = 2)\n- Index 2 (minimum of nums[2] - nums[1] = 3)\nThe maximum difference between the chosen minima is 2.\n\nExample 2:\nInput: nums = [1,5,2,4,3], p = 3\nOutput: 3\nExplanation: The optimal choice is to pick the following minima:\n- Index 1 (minimum of nums[1] - nums[0] = 4)\n- Index 2 (minimum of nums[2] - nums[1] = 2)\n- Index 4 (minimum of nums[4] - nums[3] = 1)\nThe maximum difference between the chosen minima is 3.\n\nExample 3:\nInput: nums = [1,5,2,4,3], p = 5\nOutput: 4\nExplanation: The optimal choice is to pick the following minima:\n- Index 1 (minimum of nums[1] - nums[0] = 4)\n- Index 2 (minimum of nums[2] - nums[1] = 2)\n- Index 3 (minimum of nums[3] - nums[2] = 1)\n- Index 4 (minimum of nums[4] - nums[3] = 1)\n- Index 5 (minimum of nums[5] - nums[4] = 0)\nThe maximum difference between the chosen minima is 4.\n\nConstraints:\n1 <= p <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n", "groundtruth": "class Solution {public:int minimizeMax(vector<int> &nums, int p) {sort(nums.begin(), nums.end());int left = -1, right = nums.back() - nums[0]; // 开区间while (left + 1 < right) { // 开区间int mid = left + (right - left) / 2, cnt = 0;for (int i = 0; i < nums.size() - 1; ++i)if (nums[i + 1] - nums[i] <= mid) { // 都选++cnt;++i;}(cnt >= p ? right : left) = mid;}return right;}};"}
{"task_id": "cpp/26", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {public:int minimumVisitedCells(vector<vector<int>>& grid) {int m = grid.size(), n = grid[0].size();vector<vector<int>> dist(m, vector<int>(n, -1));dist[0][0] = 1;vector<priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>> row(m), col(n);auto update = [](int& x, int y) {if (x == -1 || y < x) {x = y;}};for (int i = 0; i < m; ++i) {for (int j = 0; j < n; ++j) {while (!row[i].empty() && row[i].top().second + grid[i][row[i].top().second] < j) {row[i].pop();}if (!row[i].empty()) {update(dist[i][j], dist[i][row[i].top().second] + 1);}while (!col[j].empty() && col[j].top().second + grid[col[j].top().second][j] < i) {col[j].pop();}if (!col[j].empty()) {update(dist[i][j], dist[col[j].top().second][j] + 1);}if (dist[i][j] != -1) {row[i].emplace(dist[i][j], j);col[j].emplace(dist[i][j], i);}}}return dist[m - 1][n - 1];}};"}
{"task_id": "cpp/27", "content": "\n\n\nclass Solution {\npublic:\n    vector<vector<int>> findMatrix(vector<int> &nums) {\n        unordered_map<int, int> cnt;\n        for (int x: nums) ++cnt[x];\n        vector<vector<int>> ans;\n        while (!cnt.empty()) {\n            vector<int> row;\n            for (auto it = cnt.begin(); it != cnt.end();) {\n                row.push_back(it->first);\n                if (--it->second == 0) cnt.erase(it);\n                else ++it;\n            }\n            ans.push_back(row);\n        }\n        return ans;\n    }\n};\n\n", "groundtruth": "class Solution {public:vector<vector<int>> findMatrix(vector<int> &nums) {unordered_map<int, int> cnt;for (int x: nums) ++cnt[x];vector<vector<int>> ans;while (!cnt.empty()) {vector<int> row;for (auto it = cnt.begin(); it != cnt.end();) {row.push_back(it->first);if (--it->second == 0) it = cnt.erase(it);else ++it;}ans.push_back(row);}return ans;}};"}
{"task_id": "cpp/28", "content": "", "groundtruth": "class Solution {public:int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {int ans = 0;int n = reward1.size();vector<int> diffs(n);for (int i = 0; i < n; i++) {ans += reward2[i];diffs[i] = reward1[i] - reward2[i];}sort(diffs.begin(), diffs.end());for (int i = 1; i <= k; i++) {ans += diffs[n - i];}return ans;}};"}
{"task_id": "cpp/29", "content": "\n \n\nExample 1:\n\nInput: n = 3, p = 2, banned = [], k = 2\nOutput: [0,0,1]\nExplanation: The original array arr is [1,0,0].\nAfter 0 reverse operations the array becomes [0,0,1].\nAfter 0 reverse operations the array becomes [0,1,0].\nAfter 1 reverse operation the array becomes [1,0,0].\nExample 2:\n\nInput: n = 5, p = 1, banned = [3], k = 3\nOutput: [-1,-1,-1,-1,-1]\nExplanation: It is impossible to make all the array elements equal.\nExample 3:\n\nInput: n = 6, p = 1, banned = [0,2,3], k = 3\nOutput: [1,1,2,2,1,-1]\nExplanation: The original array arr is [1,0,2,0,3,0].\nAfter 1 reverse operation the array becomes [0,0,2,0,3,0].\nAfter 2 reverse operations the array becomes [0,2,2,0,3,0].\nAfter 3 reverse operations the array becomes [2,2,2,0,3,0].\nAfter 4 reverse operations the array becomes [2,2,2,3,3,0].\nIt is impossible to reverse the sub-array of size 3 starting from the position 3 to make the array elements equal.\n \n\nConstraints:\n\n1 <= n <= 105\n0 <= p < n\n0 <= banned.length <= min(n - 1, 100)\n0 <= banned[i] < n\n0 <= k <= n\nAll the values of banned are unique.\n\n\n", "groundtruth": "class Solution {public:vector<int> minReverseOperations(int n, int p, vector<int> &banned, int k) {unordered_set<int> ban{banned.begin(), banned.end()};set<int> sets[2];for (int i = 0; i < n; ++i)if (i != p && !ban.count(i))sets[i % 2].insert(i);sets[0].insert(n);sets[1].insert(n); // 哨兵vector<int> ans(n, -1);vector<int> q = {p};for (int step = 0; !q.empty(); ++step) {vector<int> nq;for (int i: q) {ans[i] = step;// 从 mn 到 mx 的所有位置都可以翻转到int mn = max(i - k + 1, k - i - 1);int mx = min(i + k - 1, n * 2 - k - i - 1);auto &s = sets[mn % 2];for (auto it = s.lower_bound(mn); *it <= mx; it = s.erase(it))nq.push_back(*it);}q = move(nq);}return ans;}};"}
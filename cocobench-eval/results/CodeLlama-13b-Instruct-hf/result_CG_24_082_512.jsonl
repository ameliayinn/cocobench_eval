{"task_id": "java/0", "content": "\nclass Solution {    public int findChampion(int n, int[][] edges) {        int[] degree = new int[n];        for (int[] e : edges) {            degree[e[1]]++;        }        int champion = -1;        for (int i = 0; i < n; i++) {            if (degree[i] == 0) {                if (champion == -1) {                    champion = i;                } else {                    return -1;                }            }        }        return champion;    }}", "groundtruth": "class Solution {    public int findChampion(int n, int[][] edges) {        int[] degree = new int[n];        for (int[] e : edges) {            degree[e[1]]++;        }        int champion = -1;        for (int i = 0; i < n; i++) {            if (degree[i] == 0) {                if (champion == -1) {                    champion = i;                } else {                    return -1;                }            }        }        return champion;    }}"}
{"task_id": "java/1", "content": "\n\n\nclass Solution {\n    public long maximumScoreAfterOperations(int[][] edges, int[] values) {\n        List<Integer>[] g = new ArrayList[values.length];\n        Arrays.setAll(g, e -> new ArrayList<>());\n        g[0].add(-1);\n        for (int[] e : edges) {\n            int x = e[0], y = e[1];\n            g[x].add(y);\n            g[y].add(x);\n        }\n        long ans = 0;\n        for (int v : values) {\n            ans += v;\n        }\n        return ans;\n    }\n}\n", "groundtruth": "class Solution {    public long maximumScoreAfterOperations(int[][] edges, int[] values) {        List<Integer>[] g = new ArrayList[values.length];        Arrays.setAll(g, e -> new ArrayList<>());        g[0].add(-1);         for (int[] e : edges) {            int x = e[0], y = e[1];            g[x].add(y);            g[y].add(x);        }        long ans = 0;        for (int v : values) {            ans += v;        }        return ans - dfs(0, -1, g, values);    }    private long dfs(int x, int fa, List<Integer>[] g, int[] values) {        if (g[x].size() == 1) {             return values[x];        }        long loss = 0;         for (int y : g[x]) {            if (y != fa) {                loss += dfs(y, x, g, values);             }        }        return Math.min(values[x], loss);     }}"}
{"task_id": "java/2", "content": "\n\nclass Solution {\n    public String triangleType(int[] nums) {\n        Arrays.sort(nums);\n        int x = nums[0];\n        int y = nums[1];\n        int z = nums[2];\n        if (x + y <= z) { // 排序后，只需比较 x+y 和 z\n            return \"none\";\n        }\n        if (x == z) { // 排序了，说明 y 也和 x z 相等\n            return \"equilateral\";\n        }\n        if (y == z) { // 排序了，说明 x 也和 y z 相等\n            return \"isosceles\";\n        }\n        return \"scalene\";\n    }\n}\n\n", "groundtruth": "class Solution {    public String triangleType(int[] nums) {        Arrays.sort(nums);        int x = nums[0];        int y = nums[1];        int z = nums[2];        if (x + y <= z) { // 排序后，只需比较 x+y 和 z            return 'none';        }        if (x == z) { // 排序了，说明 y 也和 x z 相等            return 'equilateral';        }        if (x == y || y == z) {            return 'isosceles';        }        return 'scalene';    }}"}
{"task_id": "java/3", "content": "\n", "groundtruth": "class Solution {    public int numberOfPairs(int[][] points) {        int pairs = 0;        Arrays.sort(points, (a, b) -> {            if (a[0] != b[0]) {                return a[0] - b[0];            } else {                return b[1] - a[1];            }        });        int n = points.length;        for (int i = 0; i < n; i++) {            for (int j = i + 1; j < n; j++) {                if (points[i][1] >= points[j][1] && isGood(points, i, j)) {                    pairs++;                }            }        }        return pairs;    }    public boolean isGood(int[][] points, int index1, int index2) {        int n = points.length;        for (int i = 0; i < n; i++) {            if (i == index1 || i == index2) {                continue;            }            if (points[i][0] >= points[index1][0] && points[i][0] <= points[index2][0] && points[i][1] >= points[index2][1] && points[i][1] <= points[index1][1]) {                return false;            }        }        return true;    }}"}
{"task_id": "java/4", "content": "", "groundtruth": "class Solution {    public long maximumSubarraySum(int[] nums, int k) {        long ans = Long.MIN_VALUE;        long sum = 0;        Map<Integer, Long> minS = new HashMap<>();        for (int x : nums) {            long s1 = minS.getOrDefault(x - k, Long.MAX_VALUE / 2);            long s2 = minS.getOrDefault(x + k, Long.MAX_VALUE / 2);            ans = Math.max(ans, sum + x - Math.min(s1, s2));            minS.merge(x, sum, Math::min);            sum += x;        }        return ans > Long.MIN_VALUE / 4 ? ans : 0;    }}"}
{"task_id": "java/5", "content": "Example 1:\nInput: s = \"0110\"\nOutput: 2\nExplanation: The substrings with dominant 1's are [\"011\"] and [\"110\"].\nExample 2:\nInput: s = \"1111\"\nOutput: 1\nNote:\n\nThe length of s is in the range [1, 50000].\ns only consists of '0' and '1' characters.\n\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    int numberOfSubstrings(string s) {\n        int n = s.size(), res = 0;\n        vector<int> zeros(n, 0), ones(n, 0);\n        for (int i = 0; i < n; ++i) {\n            if (s[i] == '0') ++zeros[i];\n            else ++ones[i];\n        }\n        for (int i = 1; i < n; ++i) {\n            zeros[i] += zeros[i - 1];\n            ones[i] += ones[i - 1];\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = i; j < n; ++j) {\n                int zero = zeros[j] - (i > 0 ? zeros[i - 1] : 0);\n                int one = ones[j] - (i > 0 ? ones[i - 1] : 0);\n                if (one >= zero * zero) ++res;\n            }\n        }\n        return res;\n    }\n};\n", "groundtruth": "class Solution {    public int numberOfSubstrings(String S) {        char[] s = S.toCharArray();        int n = s.length;        int m = 0;        int[] a = new int[n + 1];        for (int i = 0; i < n; i++) {            if (s[i] == '0') {                a[m++] = i;            }        }        int tot1 = n - m;        a[m] = n; // 哨兵        int ans = 0;        int i = 0; // >= left 的第一个 0 的下标是 a[i]        for (int left = 0; left < n; left++) {            if (s[left] == '1') {                ans += a[i] - left; // 不含 0 的子串个数            }            for (int k = i; k < m; k++) {                int cnt0 = k - i + 1;                if (cnt0 * cnt0 > tot1) {                    break;                }                int cnt1 = a[k] - left - (k - i);                ans += Math.max(a[k + 1] - a[k] - Math.max(cnt0 * cnt0 - cnt1, 0), 0);            }            if (s[left] == '0') {                i++; // 这个 0 后面不会再枚举到了            }        }        return ans;    }}"}
{"task_id": "java/6", "content": "\nPlease note that the above incomplete code is written in the Java language.", "groundtruth": "class Solution {\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        boolean[] vis = new boolean[circles.length];\n        for (int i = 0; i < circles.length; i++) {\n            long x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            if (inCircle(x, y, r, 0, 0) || // 圆 i 包含矩形左下角\n                inCircle(x, y, r, X, Y) || // 圆 i 包含矩形右上角\n                // 圆 i 是否与矩形上边界/左边界相交相切\n                !vis[i] && (x <= X && Math.abs(y - Y) <= r ||\n                            y <= Y && x <= r ||\n                            y > Y && inCircle(x, y, r, 0, Y)) && dfs(i, X, Y, circles, vis)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n    private boolean inCircle(long ox, long oy, long r, long x, long y) {\n        return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r;\n    }\n\n    private boolean dfs(int i, int X, int Y, int[][] circles, boolean[] vis) {\n        long x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];\n        // 圆 i 是否与矩形右边界/下边界相交相切\n        if (y1 <= Y && Math.abs(x1 - X) <= r1 ||\n            x1 <= X && y1 <= r1 ||\n            x1 > X && inCircle(x1, y1, r1, X, 0)) {\n            return true;\n        }\n        vis[i] = true;\n        for (int j = 0; j < circles.length; j++) {\n            long x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];\n            // 在两圆相交相切的前提下，点 A 是否严格在矩形内\n            if (!vis[j] &&\n                (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) &&\n                x1 * r2 + x2 * r1 < (r1 + r2) * X &&\n                y1 * r2 + y2 * r1 < (r1 + r2) * Y &&\n                dfs(j, X, Y, circles, vis)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/7", "content": "\n \n\nNote: \n\nThe number of flowers in the field is equal to n + m, and the number of flowers on each side must be greater than or equal to 1 and less than or equal to the total number of flowers.\nThe result is the number of possible pairs (x, y) that satisfy the conditions.\nThe answer is guaranteed to fit within the range of a long.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {\n    public long flowerGame(int n, int m) {\n        long a = ((long)n/2) * ((long)m-((long)m/2));\n        long b = ((long)m/2) * ((long)n-((long)n/2));\n        return a + b;\n    }\n}\n"}
{"task_id": "java/8", "content": "\nclass Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0;\n            int and = -1;\n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++;\n                } else {\n                    and = -1;\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b;\n                mask ^= 1 << b;\n            }\n        }\n        return ans;\n    }\n}", "groundtruth": "class Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; // 操作次数\n            int and = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++; // 合并 x，操作次数加一\n                } else {\n                    and = -1; // 准备合并下一段\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; // 答案的这个比特位必须是 1\n                mask ^= 1 << b; // 后面不考虑这个比特位\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/9", "content": "The format of the output is: The result of the given example.\n", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n        return result;\n    }\n}\n"}
{"task_id": "java/10", "content": "\n\n\nExample 1:\nInput: n = 5, x = 1, y = 3\nOutput: [3,2,2,4,2]\n\nExample 2:\nInput: n = 3, x = 2, y = 3\nOutput: [2,4,3]\n\nExample 3:\nInput: n = 2, x = 2, y = 3\nOutput: [3,2]\n\n\nConstraints:\n\n3 <= n <= 10^4\n1 <= x, y <= n\nx != y\n", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        \n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n\n        return result;\n    }\n}\n"}
{"task_id": "java/11", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {\n    public boolean canSortArray(int[] nums) {\n        int lastCnt = 0;\n        int lastGroupMax = 0;\n        int curGroupMax = 0;\n        for (int num : nums) {\n            int curCnt = Integer.bitCount(num);\n            if (curCnt == lastCnt) {\n                curGroupMax = Math.max(curGroupMax, num);\n            } else {\n                lastCnt = curCnt;\n                lastGroupMax = curGroupMax;\n                curGroupMax = num;\n            }\n            if (num < lastGroupMax) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "java/12", "content": "\nExample:\nInput: nums = [2,10,4,6,1,3,4,8]\nOutput: 4\nExplanation: \nOne optimal solution is to:\n- Select nums[0] and nums[1] (2 and 10). \n- Insert the result of 2 % 10 at the end of nums, which is 2. \n- Delete nums[0] and nums[1] from nums.\n- Select nums[0] and nums[2] (10 and 4). \n- Insert the result of 10 % 4 at the end of nums, which is 2. \n- Delete nums[0] and nums[2] from nums.\n- Select nums[0] and nums[3] (4 and 6). \n- Insert the result of 4 % 6 at the end of nums, which is 2. \n- Delete nums[0] and nums[3] from nums.\n- Select nums[0] and nums[4] (6 and 1). \n- Insert the result of 6 % 1 at the end of nums, which is 0. \n- Delete nums[0] and nums[4] from nums.\n- Select nums[0] and nums[5] (1 and 3). \n- Insert the result of 1 % 3 at the end of nums, which is 1. \n- Delete nums[0] and nums[5] from nums.\n- Select nums[0] and nums[6] (3 and 4). \n- Insert the result of 3 % 4 at the end of nums, which is 1. \n- Delete nums[0] and nums[6] from nums.\n- Select nums[0] and nums[7] (4 and 8). \n- Insert the result of 4 % 8 at the end of nums, which is 4. \n- Delete nums[0] and nums[7] from nums.\nAfter these operations, nums will contain [2,2,2,2,2], which has", "groundtruth": "class Solution {\n    public int minimumArrayLength(int[] nums) {\n        int m = Integer.MAX_VALUE;\n        for (int x : nums) {\n            m = Math.min(m, x);\n        }\n\n        for (int x : nums) {\n            if (x % m > 0) {\n                return 1;\n            }\n        }\n\n        int cnt = 0;\n        for (int x : nums) {\n            if (x == m) {\n                cnt++;\n            }\n        }\n        return (cnt + 1) / 2;\n    }\n}\n"}
{"task_id": "java/13", "content": "\n", "groundtruth": "class Solution {\n    public long minimumCost(int[] nums, int k, int dist) {\n        k--;\n        sumL = nums[0];\n        for (int i = 1; i < dist + 2; i++) {\n            sumL += nums[i];\n            L.merge(nums[i], 1, Integer::sum);\n        }\n        sizeL = dist + 1;\n        while (sizeL > k) {\n            l2r();\n        }\n\n        long ans = sumL;\n        for (int i = dist + 2; i < nums.length; i++) {\n            // 移除 out\n            int out = nums[i - dist - 1];\n            if (L.containsKey(out)) {\n                sumL -= out;\n                sizeL--;\n                removeOne(L, out);\n            } else {\n                removeOne(R, out);\n            }\n\n            // 添加 in\n            int in = nums[i];\n            if (in < L.lastKey()) {\n                sumL += in;\n                sizeL++;\n                L.merge(in, 1, Integer::sum);\n            } else {\n                R.merge(in, 1, Integer::sum);\n            }\n\n            // 维护大小\n            if (sizeL == k - 1) {\n                r2l();\n            } else if (sizeL == k + 1) {\n                l2r();\n            }\n\n            ans = Math.min(ans, sumL);\n        }\n        return ans;\n    }\n\n    private long sumL;\n    private int sizeL;\n    private final TreeMap<Integer, Integer> L = new TreeMap<>();\n    private final TreeMap<Integer, Integer> R = new TreeMap<>();\n\n    private void l2r() {\n        int x = L.lastKey();\n        removeOne(L, x);\n        sumL -= x;\n        sizeL--;\n        R.merge(x, 1, Integer::sum);\n    }\n\n    private void r2l() {\n        int x = R.firstKey();\n        removeOne(R, x);\n        sumL += x;\n        sizeL++;\n        L.merge(x, 1, Integer::sum);\n    }\n\n    private void removeOne(Map<Integer, Integer> m, int x) {\n        int cnt = m.get(x);\n        if (cnt > 1) {\n            m.put(x, cnt - 1);\n        } else {\n            m.remove(x);\n        }\n    }\n}\n"}
{"task_id": "java/14", "content": "The given code does not pass all test cases. Please complete the code to pass all test cases.\nNote: You can use the following code template:\nclass Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n\n    }\n}\n\n\nNote:\n\nAll strings consist of lowercase letters.\n1 <= s.length <= 1000\n1 <= a.length, b.length <= 10\na and b consist of lowercase letters.\n0 <= k <= 100\n\n\n", "groundtruth": "class Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        char[] text = s.toCharArray();\n        List<Integer> posA = kmp(text, a.toCharArray());\n        List<Integer> posB = kmp(text, b.toCharArray());\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i : posA) {\n            int bi = lowerBound(posB, i);\n            if (bi < posB.size() && posB.get(bi) - i <= k ||\n                bi > 0 && i - posB.get(bi - 1) <= k) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n\n    private List<Integer> kmp(char[] text, char[] pattern) {\n        int m = pattern.length;\n        int[] pi = new int[m];\n        int c = 0;\n        for (int i = 1; i < m; i++) {\n            char v = pattern[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            pi[i] = c;\n        }\n\n        List<Integer> res = new ArrayList<>();\n        c = 0;\n        for (int i = 0; i < text.length; i++) {\n            char v = text[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            if (c == m) {\n                res.add(i - m + 1);\n                c = pi[c - 1];\n            }\n        }\n        return res;\n    }\n\n    // 开区间写法\n    private int lowerBound(List<Integer> nums, int target) {\n        int left = -1, right = nums.size(); // 开区间 (left, right)\n        while (left + 1 < right) { // 区间不为空\n            // 循环不变量：\n            // nums[left] < target\n            // nums[right] >= target\n            int mid = (left + right) >>> 1;\n            if (nums.get(mid) < target) {\n                left = mid; // 范围缩小到 (mid, right)\n            } else {\n                right = mid; // 范围缩小到 (left, mid)\n            }\n        }\n        return right;\n    }\n}\n"}
{"task_id": "java/15", "content": "", "groundtruth": "class Solution {\n    public long findMaximumNumber(long k, int x) {\n        this.x = x;\n        long left = 0;\n        long right = (k + 1) << x;\n        while (left + 1 < right) {\n            long mid = (left + right) >>> 1;\n            if (countDigitOne(mid) <= k) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    private int x;\n    private long num;\n    private long memo[][];\n\n    private long countDigitOne(long num) {\n        this.num = num;\n        int m = 64 - Long.numberOfLeadingZeros(num);\n        memo = new long[m][m + 1];\n        for (long[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return dfs(m - 1, 0, true);\n    }\n\n    private long dfs(int i, int cnt1, boolean isLimit) {\n        if (i < 0) return cnt1;\n        if (!isLimit && memo[i][cnt1] != -1) return memo[i][cnt1];\n        int up = isLimit ? (int) (num >> i & 1) : 1;\n        long res = 0;\n        for (int d = 0; d <= up; d++) {\n            res += dfs(i - 1, cnt1 + (d == 1 && (i + 1) % x == 0 ? 1 : 0), isLimit && d == up);\n        }\n        if (!isLimit) memo[i][cnt1] = res;\n        return res;\n    }\n}\n"}
{"task_id": "java/16", "content": "\nI tried to solve it in the below way\n\n\\begin{code}\nclass Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}\n\\end{code}\n\nBut i got the answer as [1,10,11].\n\nThe correct answer for the same is [1,10,111]\n\nPlease tell me where I am going wrong\n\nComment: I don't understand the problem description.  What is a \"valid string\"?\n\nComment: @TimBiegeleisen valid string is a string of binary where all the substrings of length 2 contain at least one 1\n\nAnswer: The only change needed is to start with `int mask = 1;` instead of \\begin{code}\nint mask = (1 << n) - 1;\n\\end{code}\n\nThe reason for this is that `Integer.toBinaryString` returns the string with the MSB first, so that is what the mask should be based on.\n\nAlso, the line `int x = mask ^ i;` should be `int x = (1 << n) | i;`, because the goal is to find all the binary strings that are valid, and not to filter them out.\n\nThe `if` statement can remain unchanged.\n\n\\begin{code}\nclass Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = (1 << n) | i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString(x).substring(1));\n            }\n        }", "groundtruth": "class Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/17", "content": "\n\n \n\nExample 1:\n\nInput: grid = [[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"]]\nOutput: 4\nExplanation: There are 4 submatrices that meet the requirement:\n- [[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"]]\n- [[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"]]\n- [[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"]]\n- [[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\"]]\nExample 2:\n\nInput: grid = [[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"Y\"],[\"X\",\"X\",\"Y\"]]\nOutput: 6\nExplanation: There are 6 submatrices that meet the requirement:\n- [[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"Y\"],[\"X\",\"X\",\"Y\"]]\n- [[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"Y\"],[\"X\",\"X\",\"Y\"]]\n- [[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"Y\"],[\"X\",\"X\",\"Y\"]]\n- [[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"Y\"],[\"X\",\"X\",\"Y\"]]\n- [[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"Y\"],[\"X\",\"X\",\"Y\"]]\n- [[\"X\",\"X\",\"X\"],[\"X\",\"X\",\"Y\"],[\"X\",\"X\",\"Y\"]]\nExample 3:\n\nInput: grid = [[\"X\",\"Y\",\"X\"],[\"Y\",\"X\",\"X\"],[\"Y\",\"Y\",\"Y\"]]\nOutput: 3\nExplanation: There are 3 submatrices that meet the requirement:\n- [[\"X\",\"Y\",\"X\"],[\"Y\",\"X\",\"X\"],[\"Y\",\"Y\",\"Y\"]]\n- [[\"Y\",\"X\",\"X\"],[\"Y\",\"X\",\"X\"],[\"Y\",\"Y\",\"Y\"]]\n- [[\"Y\",\"Y\",\"Y\"],[\"Y\",\"X\",\"X\"],[\"Y\",\"Y\",\"Y\"]]\n \n\nConstraints:\n\nm == grid.length\nn", "groundtruth": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] sum = new int[m + 1][n + 1][2];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1][0] = sum[i + 1][j][0] + sum[i][j + 1][0] - sum[i][j][0];\n                sum[i + 1][j + 1][1] = sum[i + 1][j][1] + sum[i][j + 1][1] - sum[i][j][1];\n                if (grid[i][j] != '.') {\n                    sum[i + 1][j + 1][grid[i][j] & 1]++;\n                }\n                if (sum[i + 1][j + 1][0] > 0 && sum[i + 1][j + 1][0] == sum[i + 1][j + 1][1]) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/18", "content": "", "groundtruth": "class Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n        char[] t = target.toCharArray();\n        int n = t.length;\n\n        final int MOD = 1_070_777_777;\n        final int BASE = (int) 8e8 + new Random().nextInt((int) 1e8);\n        int[] powBase = new int[n + 1];\n        int[] preHash = new int[n + 1];\n        powBase[0] = 1;\n        for (int i = 0; i < n; i++) {\n            powBase[i + 1] = (int) ((long) powBase[i] * BASE % MOD);\n            preHash[i + 1] = (int) (((long) preHash[i] * BASE + t[i]) % MOD);\n        }\n\n        Map<Integer, Map<Integer, Integer>> minCost = new TreeMap<>();\n        for (int i = 0; i < words.length; i++) {\n            long h = 0;\n            for (char b : words[i].toCharArray()) {\n                h = (h * BASE + b) % MOD;\n            }\n            minCost.computeIfAbsent(words[i].length(), k -> new HashMap<>())\n                   .merge((int) h, costs[i], Integer::min);\n        }\n\n        int[] f = new int[n + 1];\n        Arrays.fill(f, Integer.MAX_VALUE / 2);\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (Map.Entry<Integer, Map<Integer, Integer>> e : minCost.entrySet()) {\n                int len = e.getKey();\n                if (len > i) {\n                    break;\n                }\n                int subHash = (int) (((preHash[i] - (long) preHash[i - len] * powBase[len]) % MOD + MOD) % MOD);\n                f[i] = Math.min(f[i], f[i - len] + e.getValue().getOrDefault(subHash, Integer.MAX_VALUE / 2));\n            }\n        }\n        return f[n] == Integer.MAX_VALUE / 2 ? -1 : f[n];\n    }\n}\n"}
{"task_id": "java/19", "content": "\n \n\nExample 1:\n\n\nInput: nums = [1,2,3], head = [1,2,3,4,5,6]\nOutput: [4,5,6]\nExplanation: \nThe nodes that exist in nums are marked in red:\n[1,2,3,4,5,6]\nWe should delete nodes 1, 2, and 3.\nThe resulting list is [4,5,6].\nExample 2:\n\nInput: nums = [1,2,3,4], head = [1,2,3,4]\nOutput: []\nExplanation:\nThe nodes that exist in nums are marked in red:\n[1,2,3,4]\nWe should delete nodes 1, 2, 3, and 4.\nThe resulting list is empty.\n \n\nConstraints:\n\n1 <= nums.length <= head.length <= 1000\n1 <= nums[i], the value of each node in the linked list <= 1000\n\nAccepted\n155,091\nSubmissions\n250,243\n\n*/\n\n// version 1: 虽然速度比较慢，但是逻辑非常简单，容易理解\nclass Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                int val = cur.next.val;\n                cur.next = cur.next.next;\n                cur = cur.next;\n                cur.val = val;\n            } else {\n                cur = cur.next;\n            }\n        }\n        return dummy.next;\n    }\n}\n\n\n// version 2", "groundtruth": "class Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur.next.next; // 删除\n            } else {\n                cur = cur.next; // 向后移动\n            }\n        }\n        return dummy.next;\n    }\n}\n"}
{"task_id": "java/20", "content": "\nThe code is as follows:\nclass Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        int[][][][] dp = new int[m][n][m][n];\n        for (int i1 = 0; i1 < m; i1++) {\n            for (int j1 = 0; j1 < n; j1++) {\n                for (int i2 = 0; i2 < m; i2++) {\n                    Arrays.fill(dp[i1][j1][i2], Integer.MAX_VALUE);\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][i][j] = 0;\n            }\n        }\n        for (int rowCount = 1; rowCount <= m; rowCount++) {\n            for (int colCount = 1; colCount <= n; colCount++) {\n                for (int i1 = 0, i2 = rowCount - 1; i2 < m; i1++, i2++) {\n                    for (int j1 = 0, j2 = colCount - 1; j2 < n; j1++, j2++) {\n                        for (int midRow = i1; midRow < i2; midRow++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], horizontalCut[midRow] + dp[i1][j1][midRow][j2] + dp[midRow + 1][j1][i2][j2]);\n                        }\n                        for (int midCol = j1; midCol < j2; midCol++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], verticalCut[midCol] + dp[i1][j1][i2][midCol] + dp[i1][midCol + ", "groundtruth": "class Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        int[][][][] dp = new int[m][n][m][n];\n        for (int i1 = 0; i1 < m; i1++) {\n            for (int j1 = 0; j1 < n; j1++) {\n                for (int i2 = 0; i2 < m; i2++) {\n                    Arrays.fill(dp[i1][j1][i2], Integer.MAX_VALUE);\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][i][j] = 0;\n            }\n        }\n        for (int rowCount = 1; rowCount <= m; rowCount++) {\n            for (int colCount = 1; colCount <= n; colCount++) {\n                for (int i1 = 0, i2 = rowCount - 1; i2 < m; i1++, i2++) {\n                    for (int j1 = 0, j2 = colCount - 1; j2 < n; j1++, j2++) {\n                        for (int midRow = i1; midRow < i2; midRow++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], horizontalCut[midRow] + dp[i1][j1][midRow][j2] + dp[midRow + 1][j1][i2][j2]);\n                        }\n                        for (int midCol = j1; midCol < j2; midCol++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], verticalCut[midCol] + dp[i1][j1][i2][midCol] + dp[i1][midCol + 1][i2][j2]);\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][0][m - 1][n - 1];\n    }\n}\n"}
{"task_id": "java/21", "content": "The following is an example:\nExample 1:\nInput: s = \"a\"\nOutput: true\nExplanation: Alice starts by removing the substring \"a\".\nSince the remaining string s = \"\", Bob doesn't have a turn to make any more moves.\nSince Alice has won the game, Alice wins the game.\n\nConstraints:\n\n1 <= s.length <= 10^5\ns[i] is a lowercase English letter.", "groundtruth": "class Solution {\n    public boolean doesAliceWin(String s) {\n        for (char c : s.toCharArray()) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/22", "content": "\nPlease fill in the blank with a boolean expression indicating whether the character at position i + 1 can be moved to the end of the string or another '1'.\n\nNote: The character at position i + 1 is '0'.\n\n\nThe output should be an integer.\n\nInput: S = \"010010\"\nOutput: 1\n\n\nNote:\n\nS contains only '0' and '1'.\n1 <= S.length <= 10000\n", "groundtruth": "class Solution {\n    public int maxOperations(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int cnt1 = 0;\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == '1') {\n                cnt1++;\n            } else if (i > 0 && s[i - 1] == '1') {\n                ans += cnt1;\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/23", "content": "", "groundtruth": "class Solution {\n    public long minimumOperations(int[] nums, int[] target) {\n        long s = target[0] - nums[0];\n        long ans = Math.abs(s);\n        for (int i = 1; i < nums.length; i++) {\n            int k = (target[i] - target[i - 1]) - (nums[i] - nums[i - 1]);\n            if (k > 0) {\n                ans += s >= 0 ? k : Math.max(k + s, 0);\n            } else {\n                ans -= s <= 0 ? k : Math.min(k + s, 0);\n            }\n            s += k;\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/24", "content": "\nThe code is as follows:\nclass Solution {\n    private static final int MX = 31622;\n    private static final int[] PI = new int[MX + 1];\n\n    static {\n        for (int i = 2; i <= MX; i++) {\n            if (PI[i] == 0) { // i 是质数\n                PI[i] = PI[i - 1] + 1;\n                for (int j = i * i; j <= MX; j += i) {\n                    PI[j] = -1; // 标记 i 的倍数为合数\n                }\n            } else {\n                PI[i] = PI[i - 1];\n            }\n        }\n    }\n\n    public int nonSpecialCount(int l, int r) {\n        int cnt = 0;\n        for (int i = l; i <= r; i++) {\n            int pcnt = PI[i];\n            if (pcnt == 0) continue;\n            for (int j = i + i; j <= r; j += i) {\n                if (PI[j] > 0) pcnt++;\n            }\n            if (pcnt > 1) cnt++;\n        }\n        return cnt;\n    }\n}", "groundtruth": "class Solution {\n    private static final int MX = 31622;\n    private static final int[] PI = new int[MX + 1];\n\n    static {\n        for (int i = 2; i <= MX; i++) {\n            if (PI[i] == 0) { // i 是质数\n                PI[i] = PI[i - 1] + 1;\n                for (int j = i * i; j <= MX; j += i) {\n                    PI[j] = -1; // 标记 i 的倍数为合数\n                }\n            } else {\n                PI[i] = PI[i - 1];\n            }\n        }\n    }\n\n    public int nonSpecialCount(int l, int r) {\n        return r - l + 1 - (PI[(int) Math.sqrt(r)] - PI[(int) Math.sqrt(l - 1)]);\n    }\n}\n"}
{"task_id": "python/0", "content": "\nConstraints:\n\n1 <= n <= 10^5\ngrid[i][j] is an integer in the range [0, n2 - 1].\nEach element in grid is unique.\n0 <= value <= n2 - 1\nEach call to adjacentSum or diagonalSum is guaranteed to contain value.\nAt most 10^4 calls will be made to adjacentSum and diagonalSum.", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n    "}
{"task_id": "python/1", "content": "\n# code\n\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass NeighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n\n# test\n\nclass Test(unittest.TestCase):\n    def test(self):\n        grid = [[0, 1, 0],\n                [1, 0, 1],\n                [0, 1, 0]]\n        ns = NeighborSum(grid)\n        self.assertEqual(ns.adjacentSum(0), 1)\n        self.assertEqual(ns.adjacentSum(1), 1)\n        self.assertEqual(ns.adjacentSum(2), 1)\n        self.assertEqual(ns.adjacentSum(3), 2)\n        self.assertEqual(ns.adjacentSum(4), 2)\n        self.assertEqual(ns.adjacentSum(5), 2)\n        self.assertEqual(ns.adjacentSum(6), 2)\n        self.assertEqual(ns.adjacentSum(7), 2)\n        self.assertEqual(ns.adjacentSum(8), 1)\n        self.assertEqual(ns.diagonalSum(0), 2)\n        self.", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n "}
{"task_id": "python/2", "content": "\n### 1. 디렉토리 정의\n\n디렉토리 순서는 상, 하, 좌, 우, 대각선 상, 대각선 하, 대각선 좌, 대각선 우 순서이다. \n\n### 2. adjacentSum()\n\n상, 하, 좌, 우 이웃 원소 값을 각각 더한다. \n\n### 3. diagonalSum()\n\n대각선 상, 대각선 하, 대각선 좌, 대각선 우 이웃 원소 값을 각각 더한다. \n\n### 4. diagonalSum() 분석\n\n이 함수는 대각선 이웃 원소 값을 더해야 한다. 그러므로 대각선 순서에 따라서 각 원소의 위치 정보를 변경해야 한다. 대각선 순서는 다음과 같다. \n\n- 대각선 상: (1, 1), (-1, -1)\n- 대각선 하: (1, -1), (-1, 1)\n- 대각선 좌: (1, -1), (-1, 1)\n- 대각선 우: (1, 1), (-1, -1)\n\n따라서 다음과 같이 각 원소 위치 정보를 변경해야 한다. \n\n- 대각", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/3", "content": "\nThe given code is as follows:\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[] for _ in range(n)]\n        vis = [0] * n\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n  "}
{"task_id": "python/4", "content": "", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/5", "content": "\n\n\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/6", "content": "The input and output format is as follows:\nInput: n = 3, queries = [[1,2],[2,3],[3,1]]\nOutput: [4,5,6]\nExplanation:\nAfter the first query:\n 0 --- 1 --- 2\nAfter the second query:\n 0 --- 1 --- 2\n  \\ | | |\n  1 --- 2 --- 3\nAfter the third query:\n 0 --- 1 --- 2\n  \\ | | |\n  1 --- 2 --- 3\nNote that the third edge between 1 and 2 is not added until the third query.\nInput: n = 4, queries = [[1,3],[2,3],[1,4],[2,4],[1,5],[2,5]]\nOutput: [4,5,6,7,8,9]\nExplanation:\nAfter the first query:\n 0 --- 1 --- 2\n  \\ | | |\n  1 --- 2 --- 3\nAfter the second query:\n 0 --- 1 --- 2\n  \\ | | |\n  1 --- 2 --- 3\n  \\ | | |\n  2 --- 3 --- 4\nAfter the third query:\n 0 --- 1 --- 2\n  \\ | | |\n  1 --- 2 --- 3\n  \\ | | |\n  2 --- 3 --- 4\n  \\ | | |\n  3 --- 4 --- 5\nNote that the third edge between 1 and 3 is not added until the third query.\nNote that the fourth edge between 2 and 4 is not added until the fourth query.\nNote that the fifth edge between 1 and 5 is not added until the fifth query.\nNote that the sixth edge between 2 and 5 is not added until the sixth query.\nInput: n = 5, queries = [[1,2],[3,4],[1,5],[5,2]]\nOutput: [3,2,2,4,2]\nExplanation:\nAfter the first query:\n 0 --- 1 --- 2\nAfter the second query:\n 0 --- 1 --- 2\n  \\ | | |\n  1 --- 2 --- 3\n  \\ | | |\n  ", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/7", "content": "", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/8", "content": "\n \n\nExample 1:\n\nInput: n = 5, queries = [[1,2],[2,3],[1,4],[1,5],[1,3]]\nOutput: [2,1,2,3,2]\nExplanation: The shortest path after the first query is: 0 -> 1 -> 2. The shortest path after the second query is: 0 -> 1 -> 2 -> 3. The shortest path after the third query is: 0 -> 1 -> 4. The shortest path after the fourth query is: 0 -> 1 -> 4 -> 5. The shortest path after the fifth query is: 0 -> 1 -> 4 -> 5 -> 3.\nExample 2:\n\nInput: n = 7, queries = [[1,2],[3,4],[5,6],[7,7]]\nOutput: [2,3,4,4]\nExplanation: The shortest path after the first query is: 0 -> 1 -> 2. The shortest path after the second query is: 0 -> 1 -> 2 -> 3 -> 4. The shortest path after the third query is: 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6. The shortest path after the fourth query is: 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\nExample 3:\n\nInput: n = 20, queries = [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20]]\nOutput: [3,3,3,3,3,3,3,3,3,3]\n \n\nConstraints:\n\n2 <= n <= 10^4\n1 <= queries.length <= 10^5\nqueries[i].length == 2\n0 <= ui < vi <= n - 1\nui != vi\nqueries[i][0] < queries[i][1]\n \n\nFollow up: Could you find the answer for any number of queries?\n\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/9", "content": "", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/10", "content": "\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n               ", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/11", "content": "", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/12", "content": "\n## 2.3 \n\nWrite a program that prints a list of names.\n\nInput:\n\nEnter a name:\nTom\nEnter a name:\nJerry\nEnter a name:\nScooby\nEnter a name:\nShaggy\nEnter a name:\nVelma\nEnter a name:\nDaphne\nEnter a name:\nFred\n\nOutput:\n\nThe list of names is:\nFred\nDaphne\nVelma\nShaggy\nScooby\nJerry\nTom\n\n## 2.4\n\nA company has n employees with a unique employee identifier (ID) for each employee. The company has a tree structure of managers and employees, and each manager has exactly one direct subordinate. A direct subordinate is also a manager of another employee. The company has given you a list of all employee IDs in a list.\n\nYou are required to find the maximum number of levels in the company's tree structure.\n\nFor example, if the company has three employees (1, 2, and 3) with the following relationships:\n\nEmployee 1 is the manager of employee 2.\nEmployee 2 is the manager of employee 3.\nIn this case, the maximum number of levels in the tree structure is 2.\n\nWrite a function that takes in an array of employee IDs and returns the maximum number of levels in the tree structure.\n\n## 2.5\n\nA company has n employees with a unique employee identifier (ID) for each employee. The company has a tree structure of managers and employees, and each manager has exactly one direct subordinate. A direct subordinate is also a manager of another employee. The company has given you a list of all employee IDs in a list.\n\nYou are required to find the number of employees in the company's tree structure that are managers.\n\nFor example, if the company has three employees (1, 2, and 3) with the following relationships:\n\nEmployee 1 is the manager of employee 2.\nEmployee 2 is the manager of employee 3.\nIn this case, the number of managers in the tree structure is 2.\n\nWrite a function that takes in an array of employee IDs and returns the number of managers in the tree structure.\n\n## 2.6\n\nA", "groundtruth": " class Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\n        double=0\n        for it in nums:\n            if it>=10: \n                double=double+it \n            else:\n                single=single+it  \n        \n        return single !=double\n "}
{"task_id": "python/13", "content": "\n\n```python\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n```\n\n## 1210. 穿过迷宫的最小代价\n\n有一个 N x N 的迷宫，迷宫的限制条件如下：\n\n1. 迷宫中每个格子上有一个非负整数。\n2. 在迷宫的最左上角和最右下角之间有一个出口。\n3. 每个格子上的数字代表这个格子的难度。\n4. 你在迷宫的最左上角开始。\n5. 你的目标是到达迷宫的最右下角。\n\n每当你进入一个格子时，你的代价就是这个格子中的数字。你最终的代价是你完成从迷宫最左上角开始到最右下角结束的所有步骤的代价之和。\n\n你需要找到到达迷宫最右下角的最小代价。如果你无法到达最右下角，请返回-1。\n\n输入: [[1,2,3],[4,5,6]]\n输出: 12\n\n输入: [[1,2,3],[4,1,6]]\n输出: 13\n\n输入: [[1,2,3,4],[1,1,1,1],[1,1,1,1],[1,1,1,1]]\n输出: 8\n\n输入: [[1,2,3,4],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n"}
{"task_id": "python/14", "content": "\n", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n "}
{"task_id": "python/15", "content": "\n\nInput\nThe input consists of one line with a binary string s. The length of s does not exceed 100000.\n\nOutput\nPrint the number of substrings with dominant ones.\n\nSample Input 1\n0000000000\n\nSample Output 1\n1\n\nSample Input 2\n000010110100000001001010000100000010100001001111100010000001011010100101101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101000010110101", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n "}
{"task_id": "python/16", "content": "\nExample 1:\n\nInput: s = \"011001\"\nOutput: 5\nExplanation: The 5 substrings with dominant 1 are underlined below:\n\"011001\"\n\"01100\"\n\"11001\"\n\"1100\"\n\"1001\"\nExample 2:\n\nInput: s = \"111111\"\nOutput: 21\nExplanation: Each substring of length 1 contains only 1's and so is dominant.\nExample 3:\n\nInput: s = \"000000\"\nOutput: 1\n \n\nConstraints:\n\ns.length == 105\ns[i] is either '0' or '1'.\n", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/17", "content": "The code is as follows:\n\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += cnt1 > cnt0\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/18", "content": "\n", "groundtruth": " class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n    "}
{"task_id": "python/19", "content": "\nNote:\n\nThere will be at most 10000 circles.\nEach circle will be given in the format [x, y, r], where [x, y] is the coordinate of the circle's center, and r is the circle's radius.\nIt is guaranteed that the sum of the radiuses of all circles is less than or equal to 10000.\n", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/20", "content": "\n\n\nThe format of the input and output data is as follows:\n\nInput:\nThe first line of input contains two space-separated integers xCorner and yCorner, denoting the coordinates of the top right corner of the rectangle.\nThe second line of input contains an integer n, denoting the number of circles.\nThe next n lines of input contain three space-separated integers xi, yi, and ri, denoting the coordinates of the center of the circle and its radius respectively.\nOutput:\nOutput \"Yes\" if there is a path from the bottom left corner to the top right corner that satisfies the given conditions. Otherwise, output \"No\".\n\n\n\nSample Input:\n6 4\n3\n1 2 1\n2 2 1\n3 3 1\nSample Output:\nYes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/21", "content": "\nExample 1:\nInput: grid = [[1,1,0],[0,1,0],[0,1,1]]\nOutput: 0\nExplanation: The champion team with the strongest team is team 0.\n\nExample 2:\nInput: grid = [[1,0,0],[0,1,0],[1,1,1]]\nOutput: 0\n\nExample 3:\nInput: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: 1\n\nConstraints:\n\nn == grid.length\nn == grid[i].length\n2 <= n <= 100\ngrid[i][j] is either 0 or 1.\nThere is at least one team in the tournament.\n\n'''\n\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] == 1 and grid[j][i] == 0:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n", "groundtruth": "\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] == 1 and grid[j][i] == 0:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n"}
{"task_id": "python/22", "content": "\n\n# Definition for a directed graph node\n# class DirectedGraphNode:\n#     def __init__(self, label):\n#         self.label = label\n#         self.neighbors = []\n\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/23", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/24", "content": "\nThe input format is as follows:\n\nThe first line contains a single integer n, the number of nodes in the tree.\nThe next line contains n - 1 space-separated integers ai, bi, where ai and bi are 1-indexed and represent that there is an edge between node ai and node bi.\nThe third line contains n space-separated integers, where the ith integer represents the value associated with the ith node.\nOutput Format\n\nReturn the maximum score you can obtain after performing these operations on the tree any number of times so that it remains healthy.\n\nNote: The input is given such that it is possible to remain healthy.\n\nSample Input 0\n\n3\n1 2\n10 20 30\nSample Output 0\n\n100\nExplanation 0\n\nInitially, the tree is:\n\nThe root node has value 10 and the sum of values on the path from the root to any leaf node is 10.\n\nPerform the following operation:\n\nPick node 2 with value 20 and add it to the score.\nThe tree becomes:\n\nThe sum of values on the path from the root to any leaf node is now 10, which is different than zero.\n\nTherefore, the maximum score that can be obtained is 100.\n\nConstraints\n\n1 <= n <= 100,000\n2 <= edges.length <= 100,000\nedges[i].length == 2\n0 <= edges[i][j] <= n\nAll pairs (edges[i][0], edges[i][1]) are distinct.\nAll pairs (edges[i][0], edges[i][1]) are not equal.\n0 <= values.length <= 100,000\n0 <= values[i] <= 100\nThe tree formed by edges and values is a valid tree.\n\nThe tree is rooted at node 0.\nThe tree has exactly one node for each value in values.\nThe input is given such that it is possible to remain healthy.\n\n", "groundtruth": "\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/25", "content": "", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/26", "content": "", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/27", "content": "\nThe correct answer for this problem is\n\n    def __init__(self, n: int):\n        self.tree = [-inf] * (n + 1)\n\n    def update(self, i: int, val: int) -> None:\n        while i <= n:\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i -= i & -i\n        return mx\n\nNote that the index of the array tree must be n + 1 in order to support queries up to index n.\n\nThe correct answer for this problem is\n\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))\n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1\n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nThis solution is correct.\n", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/28", "content": "\nThe correct code is as follows:\n\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(1 for num in nums if num & 1 << i)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n\n", "groundtruth": "\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/29", "content": "", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/30", "content": "\n", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/31", "content": "\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 105\n1 <= k <= 109\n\n", "groundtruth": "\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/32", "content": "", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/33", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/34", "content": "\nThe output should be an integer that represents the maximum points you can get after collecting the coins from all the tree nodes.\n\nExplanation:\n\nNode 0 collects all the coins and gets 2 coins - 2 = 0 points.\nNode 1 collects all the coins and gets 2 coins - 2 = 0 points.\nNode 2 collects all the coins and gets 2 coins - 2 = 0 points.\nNode 3 collects all the coins and gets 2 coins - 2 = 0 points.\nNode 4 collects all the coins and gets 2 coins - 2 = 0 points.\nNode 5 collects all the coins and gets 2 coins - 2 = 0 points.\nNode 6 collects all the coins and gets 2 coins - 2 = 0 points.\nNode 7 collects all the coins and gets 2 coins - 2 = 0 points.\nNode 8 collects all the coins and gets 2 coins - 2 = 0 points.\nNode 9 collects all the coins and gets 2 coins - 2 = 0 points.\nNode 10 collects all the coins and gets 2 coins - 2 = 0 points.\nNode 11 collects all the coins and gets 2 coins - 2 = 0 points.\nNode 12 collects all the coins and gets 2 coins - 2 = 0 points.\n\nThe maximum points you can get is 0.\n\nExample 2:\n\nInput: edges = [[1,2],[1,3],[2,4],[2,5]], coins = [10,10,10,10,10], k = 5\nOutput: 65\nExplanation:\nNode 0 collects all the coins and gets 10 - 5 = 5 points.\nNode 1 collects all the coins and gets 10 - 5 = 5 points.\nNode 2 collects all the coins and gets 10 - 5 = 5 points.\nNode 3 collects all the coins and gets 10 - 5 =", "groundtruth": " class Solution:     def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:         g = [[] for _ in coins]         for x, y in edges:             g[x].append(y)             g[y].append(x)         @cache         def dfs(i: int, j: int, fa: int) -> int:             res1 = (coins[i] >> j) - k             res2 = coins[i] >> (j + 1)             for ch in g[i]:                 if ch != fa:                     res1 += dfs(ch, j, i)                      if j < 13:                          res2 += dfs(ch, j + 1, i)              return max(res1, res2)         return dfs(0, 0, -1) "}
{"task_id": "python/35", "content": "\nThe input is a non-empty array nums of length n (1 <= n <= 105). nums consists of only positive integers.\nThe output is a single integer representing the sum of the squares of distinct counts of all subarrays of nums modulo 109 + 7.\n\nExample 1:\nInput: nums = [1,2,3,2,1]\nOutput: 4\nExplanation:\nSubarray [1] has a distinct count of 1, so we add 1^2 = 1 to the answer.\nSubarrays [1, 2], [2, 3], and [2, 1] each have distinct counts of 2, so we add 2^2 = 4 to the answer.\nSubarray [1, 2, 3, 2, 1] has a distinct count of 3, so we add 3^2 = 9 to the answer.\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: 10\nExplanation: Each subarray has a distinct count of 1, so we add 1^2 + 2^2 + 3^2 + 4^2 = 10 to the answer.\n\n\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/36", "content": "\n\n \nExample 1:\n\nInput: nums = [1,2,3,2]\nOutput: 47\nExplanation: The answer is 32 for the first subarray, 22 for the second, 22 for the third, and 43 for the fourth. Then, the sum of the squares of the distinct counts of all subarrays is 32 + 22 + 22 + 43 = 105.\n\n\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 100\n \n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/37", "content": "The code is:\n```java\nclass Solution {\n    public int sumCounts(int[] nums) {\n        int n = nums.length;\n        int[] sum = new int[n * 4];\n        int[] todo = new int[n * 4];\n        do(1, 0, n - 1, 1);\n        int ans = 0, s = 0;\n        Map<Integer, Integer> last = new HashMap<>();\n        for (int i = 1; i <= n; i++) {\n            int x = nums[i - 1];\n            int j = last.getOrDefault(x, 0);\n            s += (i - j) * (i - j - 1) / 2;\n            ans += s;\n            last.put(x, i);\n        }\n        return ans;\n    }\n\n    void do(int o, int l, int r, int add) {\n        if (l == r) {\n            sum[o] += add;\n            return;\n        }\n        int m = l + r >>> 1;\n        if (todo[o]) {\n            do(o * 2, l, m, todo[o]);\n            do(o * 2 + 1, m + 1, r, todo[o]);\n            todo[o] = 0;\n        }\n        sum[o] += sum[o * 2] + sum[o * 2 + 1];\n    }\n\n    int query_and_add1(int o, int l, int r, int L, int R) {\n        if (L <= l && r <= R) {\n            int res = sum[o];\n            do(o, l, r, 1);\n            return res;\n        }\n        int m = l + r >>> 1;\n        int add = todo[o];\n        if (add) {\n            do(o * 2, l, m, add);\n            do(o * 2 + 1, m + 1, r, add);\n            todo[o] = 0;\n        }\n        int res = 0;\n        if (L <= m) {", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/38", "content": "\n\nInput Format\n\nA single line containing a binary string \n\n.\n\nConstraints\n\n\n\n\nOutput Format\n\nPrint a single integer denoting the minimum number of changes required to make the string  beautiful.\n\nSample Input 0\n\n00000\nSample Output 0\n\n1\nExplanation 0\n\nThe following are the  ways to make  beautiful:\n\n\n\n\nThe minimum number of changes required to make  beautiful is .\n\nSample Input 1\n\n0000000000\nSample Output 1\n\n0\nExplanation 1\n\nThe following is  itself:\n\n\n\n\nThe minimum number of changes required to make  beautiful is .\n\nSample Input 2\n\n001010\nSample Output 2\n\n2\nExplanation 2\n\nThe following are the  ways to make  beautiful:\n\n\n\n\nThe minimum number of changes required to make  beautiful is .\n\nSample Input 3\n\n0000000000000000\nSample Output 3\n\n0\nExplanation 3\n\nThe following is  itself:\n\n\n\n\nThe minimum number of changes required to make  beautiful is .\n\nSample Input 4\n\n1111000011110000\nSample Output 4\n\n3\nExplanation 4\n\nThe following are the  ways to make  beautiful:\n\n\n\n\nThe minimum number of changes required to make  beautiful is .\n\n\n", "groundtruth": " class Solution:     def minChanges(self, s: str) -> int:         cnt = 0         for i in range(0, len(s), 2):             if len(set(s[i:i + 2])) > 1:                 cnt += 1                 print(s)         return cnt "}
{"task_id": "python/39", "content": "\n \n\nExample 1:\n\nInput: nums = [3,2,1,4,4,3,2,1,4], target = 11\nOutput: 4\nExplanation: The longest subsequence that sums up to target is [3,2,1,4].\n\nExample 2:\n\nInput: nums = [1,2,3,4,4,3,2,1], target = 10\nOutput: 4\n\nExample 3:\n\nInput: nums = [1,2,3,4,5,6,7,8,9,10], target = 100\nOutput: -1\n \n\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 1000\n1 <= target <= 1000\n\n'''\n\n\n\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        f = [0] + [-inf] * target\n        s = 0\n        for x in nums:\n            s = max(s, x - 1, key=f.__getitem__)\n            for j in range(s, x - 1, -1):\n                if f[j] < f[j - x] + 1:\n                    f[j] = f[j - x] + 1\n            f[x] = max(f[x], f[x - s] + 1)\n        return f[-1] if f[-1] > 0 else -1", "groundtruth": " class Solution:     def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:         f = [0] + [-inf] * target         s = 0         for x in nums:             s = min(s + x, target)             for j in range(s, x - 1, -1):                 # f[j] = max(f[j], f[j - x] + 1)                 if f[j] < f[j - x] + 1:                     f[j] = f[j - x] + 1         return f[-1] if f[-1] > 0 else -1 "}
{"task_id": "python/40", "content": "\n", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/41", "content": "\n", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/42", "content": "\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int n;\n    cin >> n;\n    string s1, s2;\n    cin >> s1 >> s2;\n    vector<int> c1(26), c2(26);\n    for(int i = 0; i < 26; ++i)\n    {\n        c1[i] = c2[i] = 0;\n    }\n    for(int i = 0; i < n; ++i)\n    {\n        c1[s1[i] - 'a']++;\n        c2[s2[i] - 'a']++;\n    }\n    int ans = 0;\n    for(int i = 0; i < 26; ++i)\n    {\n        ans += abs(c1[i] - c2[i]);\n    }\n    cout << ans;\n    return 0;\n}\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/43", "content": "\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int n;\n    cin >> n;\n    string source, target;\n    cin >> source >> target;\n    vector<string> original(n), changed(n);\n    for (int i = 0; i < n; i++)\n        cin >> original[i] >> changed[i];\n    vector<int> cost(n);\n    for (int i = 0; i < n; i++)\n        cin >> cost[i];\n    Solution obj;\n    int ans = obj.minimumCost(source, target, original, changed, cost);\n    cout << ans;\n    return 0;\n}\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/44", "content": "\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)         for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/45", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                      continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/46", "content": "\n\nThe answer is in Python3\n\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/47", "content": "The length of source and target will be in the range [1, 10^5].\nThe length of original, changed, and cost will be the same, which is equal to n.\nsource, target, and original[i] will only contain lowercase English letters, and target will not contain any character that is not present in source.\nAll characters in original[i] are distinct.\nAll characters in changed[i] are distinct.\ncost[i] is an integer in the range [0, 1000].\nThere is at least one valid way to convert source to target.\nExample 1:\nInput: source = \"abc\", target = \"bcd\", original = [\"ab\",\"bc\",\"cd\"], changed = [\"bc\",\"cd\",\"cd\"], cost = [1,2,3]\nOutput: 4\nExplanation:\nThe original string source is \"abc\".\nThe target string target is \"bcd\".\nThe strings original[i] and changed[i] are [\"ab\",\"bc\",\"cd\"] and [\"bc\",\"cd\",\"cd\"] respectively.\nThe cost of converting the string original[i] to the string changed[i] is [1,2,3].\nThe cost of converting \"abc\" to \"bcd\" is 4, which is the minimum cost to change the string.\nExample 2:\nInput: source = \"abcd\", target = \"cdabcdab\", original = [\"ab\",\"bc\",\"cd\",\"ab\"], changed = [\"bc\",\"cd\",\"ab\",\"ab\"], cost = [1,2,3,4]\nOutput: 3\nExplanation:\nThe original string source is \"abcd\".\nThe target string target is \"cdabcdab\".\nThe strings original[i] and changed[i] are [\"ab\",\"bc\",\"cd\",\"ab\"] and [\"bc\",\"cd\",\"ab\",\"ab\"] respectively.\nThe cost of converting the string original[i] to the string changed[i] is [1,2,3,4].\nThe cost of converting \"abcd\" to \"cdabcdab\" is 3, which is the minimum cost to change the string.\nExample 3:\nInput: source = \"abcd\", target = \"cabcd\", original = [\"ab\",\"bc\",\"cd\",\"ab\"], changed = [\"bc\",\"cd\",\"ab\",\"ab\"], cost = [", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/48", "content": "\n", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/49", "content": "\n\n \n\nExample 1:\n\nInput\n[\"NeighborSum\", \"adjacentSum\", \"adjacentSum\", \"adjacentSum\", \"adjacentSum\", \"adjacentSum\", \"adjacentSum\", \"adjacentSum\", \"adjacentSum\", \"adjacentSum\", \"diagonalSum\", \"diagonalSum\", \"diagonalSum\", \"diagonalSum\", \"diagonalSum\", \"diagonalSum\", \"diagonalSum\", \"diagonalSum\", \"diagonalSum\", \"diagonalSum\"]\n[[[[3, 4, 5], [3, 4, 6], [3, 1, 5]]], [5], [1], [2], [3], [4], [6], [5], [4], [5], [5], [4], [5], [6], [1], [2], [3], [6], [5]]\nOutput\n[null, 8, 0, 0, 1, 0, 1, 7, 0, 0, 3, 8, 0, 0, 0, 0, 3]\n\nExplanation\nNeighborSum neighborSum = new NeighborSum([[3, 4, 5], [3, 4, 6], [3, 1, 5]]);\nneighborSum.adjacentSum(5); // return 8; no adjacent element.\nneighborSum.adjacentSum(1); // return 0; no adjacent element.\nneighborSum.adjacentSum(2); // return 0; no adjacent element.\nneighborSum.adjacentSum(3); // return 1; only adjacent element is 4.\nneighborSum.adjacentSum(4); // return 0; no adjacent element.\nneighborSum.adjacentSum(6); // return 1; only adjacent element is 5.\nneighborSum.adjacentSum(5); // return 7; adjacent elements are 6, 4, and 3.\nneighborSum.adjacentSum(4); // return 0; no adjacent element.\nneighborSum.diagonalSum(5); // return 3; adjacent elements", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/50", "content": "\nThe code is as follows:\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([(0, 0)])\n            while q:\n                v, d = q.popleft()\n                for to in g[v]:\n                    if vis[to] == -1:\n                        vis[to] = d + 1\n                        q.append((to, d + 1))\n            return vis[-1]\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/51", "content": "\nThe code format may be different from the sample code provided. The goal is to make the code run correctly.\n\n# test case 1:\nn = 5\nqueries = [[1, 2], [2, 3], [3, 4]]\n# correct output: [2, 3, 4]\n\n# test case 2:\nn = 10\nqueries = [[2, 4], [4, 5], [6, 8], [1, 9], [10, 3], [1, 2], [6, 9], [1, 7], [6, 5], [4, 8]]\n# correct output: [3, 3, 3, 3, 3, 2, 2, 2, 2, 2]\n\n# test case 3:\nn = 1000\nqueries = [[____, ____], [____, ____], [____, ____], [____, ____], [____, ____], [____, ____], [____, ____], [____, ____], [____, ____], [____, ____]]\n# correct output: [____, ____, ____, ____, ____, ____, ____, ____, ____, ____]\n", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/52", "content": "", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/53", "content": "\n\n\n", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/54", "content": "\nNote: You can assume that nums has at least one element.\n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: false\nExplanation: Alice cannot win this game.\n\nExample 2:\n\nInput: nums = [1,2,3,-1,-2,-3,5]\nOutput: true\nExplanation: Alice can take all the odd numbers and the sum of the odd numbers is 1 + 2 + 3 + 5 = 11 which is greater than Bob's sum of 1 + 2 + 3 = 6.\n\nExample 3:\n\nInput: nums = [-1,-2,-3]\nOutput: false\nExplanation: The sum of all numbers in nums is negative which means that Alice cannot win this game.\n\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 100\n\n\n\n\n\n\n\n\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        nums.sort()\n        # odd numbers\n        s1 = sum(nums[::2])\n        # even numbers\n        s2 = sum(nums[1::2])\n        # Alice wins\n        return s1 > s2 or (s1 == s2 and nums[-1] % 2 == 1)", "groundtruth": "\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\ndouble=0\nfor it in nums:\nif it>=10: \ndouble=double+it \nelse:\nsingle=single+it  \n        \nreturn single !=double\n "}
{"task_id": "python/55", "content": "\n\n### Solution:\n\n    class Solution:\n        def numberOfSubstrings(self, s: str) -> int:\n            ans = 0\n            n = len(s)\n            l = 0\n            r = 0\n            for r in range(n):\n                if s[r] == '1':\n                    continue\n                else:\n                    zero_count = r - l\n                    if zero_count > 1:\n                        one_count = 0\n                        for i in range(l, r):\n                            if s[i] == '1':\n                                one_count += 1\n                        if one_count * one_count >= zero_count:\n                            ans += 1\n                    l = r\n            return ans\n\n", "groundtruth": "\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/56", "content": "\nNote:\n\n    1 <= circles.length <= 100\n    circles[i].length == 3\n    1 <= xi, yi <= 100\n    1 <= ri <= 100\n\nExample 1:\n\n    Input: xCorner = 2, yCorner = 1, circles = [[1,1,2],[2,1,1]]\n    Output: false\n\nExample 2:\n\n    Input: xCorner = 1, yCorner = 1, circles = [[1,1,1]]\n    Output: true\n\nExample 3:\n\n    Input: xCorner = 1, yCorner = 2, circles = [[1,1,1]]\n    Output: false\n\nExample 4:\n\n    Input: xCorner = 2, yCorner = 2, circles = [[1,1,1]]\n    Output: true\n\nExample 5:\n\n    Input: xCorner = 2, yCorner = 1, circles = [[1,1,1]]\n    Output: false\n", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/57", "content": "", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/58", "content": "\nThe code is as follows:\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        if visited[start]:\n            return 0\n        visited[start] = True\n        for neighbor in graph[start]:\n            count = self.dfs(graph, neighbor, visited)\n            if count == 0:\n                return 0\n        return 1\n\n###\n# Test case 1:\n# Input: n = 7, edges = [[0, 1], [1, 2], [3, 4], [4, 5], [6, 4]]\n# Output: 5\n# Explanation:\n# The above figure represents the given DAG.\n# In this diagram, each team has a unique number from 0 to 6, and each arrow points from the team with a higher number to the team with a lower number, representing that the former team is stronger than the latter team.\n# The champion will be team 5 because there is no team that is stronger than it.\n#\n# Test case 2:\n# Input: n = 8, edges = [[0, 1], [1, 2], [2, 3], [4, 5], [5, 6], [6, 7], [7, 0], [1, 7]]\n# Output: -1\n# Explanation:\n# The above figure represents the given DAG.\n# In this diagram, there are several teams that can be the champion.\n#\n# Test case 3:\n# Input: n = 1, edges = []\n# Output: 0\n# Explanation:\n# The above figure represents the given DAG.\n# Since there is only one team,", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/59", "content": "\n### 题目\n\n在一个排名赛中，有 n 支队伍，编号为 0 到 n - 1 。给你一个下标从 0 开始的 2D 整数数组 edges，其中 edges[i] = [ui, vi] 表示队伍 ui 和队伍 vi 之间存在一条队伍关系，如果队伍 ui 强于队伍 vi ，那么队伍 ui 就是队伍 vi 的父队伍。\n\n队伍 0 号总是比赛中的冠军。在比赛中，如果存在一支队伍比另一支队伍强，那么前者将成为冠军。比赛中的冠军是唯一的。如果不存在唯一的冠军，那么冠军就是 -1 。\n\n请你返回赛事中的冠军。如果有多个冠军，你只需要返回其中 任意 一支队伍即可。\n\n### 解题思路\n\n本题的关键在于如何判断一个队伍是否唯一。我们可以用一个布尔数组来标记每个队伍，如果这个队伍不唯一，那么布尔数组中对应位置就会有多个 true。\n\n另外，我们还可以使用队伍关系的反向图来进行判断。如果在反向图中存在两条从队伍 a 指向队伍 b 的边，那么队伍 b 就", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/60", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/61", "content": "\n", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/62", "content": "\nConstraints\n\n1 ≤ n ≤ 105\n1 ≤ nums[i] ≤ 100\n\nOutput Format\n\nReturn an integer denoting the maximum possible sum of elements in a balanced subsequence of nums.\n\nSample Input 0\n\nnums = [2, 1, 5, 3, 4]\nSample Output 0\n\n9\nExplanation 0\n\nThere are 2 balanced subsequence of length 1 in nums:\n\n[2], sum = 2\n[4], sum = 4\nThe maximum possible sum of elements in a balanced subsequence of nums is 4.\n\nSample Input 1\n\nnums = [1, 2, 3, 4, 5]\nSample Output 1\n\n15\nExplanation 1\n\nThere are 4 balanced subsequence of length 3 in nums:\n\n[2, 3, 4], sum = 9\n[2, 3, 5], sum = 10\n[3, 4, 5], sum = 12\n[4, 5], sum = 9\nThe maximum possible sum of elements in a balanced subsequence of nums is 15.\n\"\"\"\n\nfrom bisect import bisect_left\n\n\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))\n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1\n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        i += 1\n        while i < len(self.tree):\n            self.tree[i] = max", "groundtruth": "class Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/63", "content": "\nNote: The return value is a 32-bit integer.\n\n# code\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        count = [0] * 32\n        for num in nums:\n            for i in range(32):\n                if num & (1 << i) != 0:\n                    count[i] += 1\n        res = 0\n        for i in range(32):\n            if count[i] >= k:\n                res |= (1 << i)\n        return res\n", "groundtruth": "class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/64", "content": "\nConstraints:\n1 <= nums1.length, nums2.length <= 10^5\n1 <= nums1[i], nums2[i] <= 10^4\nnums1 and nums2 do not contain 0s.\n", "groundtruth": "class Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n\n"}
{"task_id": "python/65", "content": "", "groundtruth": "class Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/66", "content": "\n# Definition for a point.\n# class Point:\n#     def __init__(self, x: int, y: int):\n#         self.x = x\n#         self.y = y\n\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            if not g[i]:\n                return coins[i]\n            ans = 0\n            for node in g[i]:\n                if node != fa:\n                    ___ = dfs(node, 0, i)\n                    ans += max(____)\n            return ans + coins[i]\n        \n        return dfs(0, 0, -1)\n", "groundtruth": "class Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/67", "content": "\n\n", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/68", "content": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if l <= L <= r:\n                if L <= R:\n                    return query_and_add1(o * 2, l, (l + r) // 2, L, R) + \\\n                        query_and_add1(o * 2 + 1, (l + r) // 2 + 1, r, L, R)\n                else:\n                    return query_and_add1(o * 2, l, (l + r) // 2, L, R)\n            else:\n                return 0\n\n        def update(o: int, l: int, r: int, L: int, R: int, add: int) -> None:\n            if l <= L <= r:\n                if L <= R:\n                    update(o * 2, l, (l + r) // 2, L, R, add)\n                    update(o * 2 + 1, (l + r) // 2 + 1, r, L, R, add)\n                else:\n                    update(o * 2, l, (l + r) // 2, L, R, add)\n\n        for i in range(n):\n            if nums[i] in todo:\n                do(1, 0, n - 1, -todo[nums[i]])\n                update(1, ", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/69", "content": "\nThe given incomplete code is a function named minChanges with one argument: s, a string.\n\nThe function minChanges should return an integer that represents the minimum number of changes required to make the string s beautiful.\n\nNote: The given incomplete code should not be modified.\n\nInput Format\nThe only argument given is the string s.\nOutput Format\nReturn the minimum number of changes required to make the string s beautiful.\nConstraints\n1≤length(s)≤1000\ns is a binary string having an even length.\nExample Input\ns = \"110011101101100\"\nExample Output\n2\nExample Explanation\nWe can change the first \"1\" to \"0\" and the last \"0\" to \"1\" to make the string beautiful.\n\n", "groundtruth": "\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        cnt = 0\n        for i in range(0, len(s), 2):\n            if len(set(s[i:i + 2])) > 1:\n                cnt += 1\n                \n        print(s)\n        return cnt\n"}
{"task_id": "python/70", "content": "\nInput: nums = [1,2,3,4], target = 4\nOutput: 3\n\nInput: nums = [2,3,4], target = 1\nOutput: -1\n\nInput: nums = [1,1,1,1,1,1,1,1,1], target = 1\nOutput: 9\n\nInput: nums = [1,2,3,4,5,6,7,8,9], target = 9\nOutput: 9\n\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 1000\n1 <= target <= 1000\n", "groundtruth": "\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        f = [0] + [-inf] * target\n        s = 0\n        for x in nums:\n            s = min(s + x, target)\n            for j in range(s, x - 1, -1):\n                # f[j] = max(f[j], f[j - x] + 1)\n                if f[j] < f[j - x] + 1:\n                    f[j] = f[j - x] + 1\n        return f[-1] if f[-1] > 0 else -1\n"}
{"task_id": "python/71", "content": "\nThe test cases are as follows:\n\n\nTest case 1:\n\nm = 5\nn = 7\nhFences = [1, 4]\nvFences = [2, 6]\n\nTest case 2:\n\nm = 2\nn = 2\nhFences = [1]\nvFences = [1]\n\nTest case 3:\n\nm = 100\nn = 100\nhFences = [1, 10, 50, 90]\nvFences = [1, 10, 50, 90]\n\nTest case 4:\n\nm = 500\nn = 500\nhFences = [1, 10, 50, 90, 100, 110, 150, 190, 200, 210, 250, 290, 300, 310, 350, 390, 400, 410, 450, 490, 500]\nvFences = [1, 10, 50, 90, 100, 110, 150, 190, 200, 210, 250, 290, 300, 310, 350, 390, 400, 410, 450, 490, 500]\n\nNote: The input arrays hFences and vFences will be in sorted order.\n\nThe code for this solution is as follows:\n\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/72", "content": "\n## Input\nThe first line of input contains an integer t denoting the number of test cases. Then t test cases follow.\nThe first line of each test case contains four space-separated integers m, n, k, and l where 2 ≤ m, n ≤ 100, 1 ≤ k, l ≤ 10, and k + l ≤ 100.\nThe second line contains k space-separated integers hFences[i] where 1 ≤ i ≤ k.\nThe third line contains l space-separated integers vFences[i] where 1 ≤ i ≤ l.\n\n## Output\nFor each test case, output a single line containing one integer, the maximum area of a square field that can be formed by removing some fences or -1 if it is impossible to make a square field.\n\n## Constraints\n\n1 ≤ t ≤ 100,000\n2 ≤ m, n ≤ 100\n1 ≤ k, l ≤ 10\n1 ≤ hFences[i], vFences[i] ≤ min(m, n)\n\n## Subtasks\n\nSubtask #1 (100 points): Original constraints\n\n## Example Input\n1\n4 4 3 2\n1 2 4\n1 3\n## Example Output\n9\n\n## Explanation\nIn the example, we have a 4 x 4 field with horizontal fences at coordinates (1, 1), (1, 2), (1, 4), (2, 1), (2, 2), (2, 4), (3, 1), (3, 2), (3, 4), (4, 1), (4, 2), (4, 4), and vertical fences at coordinates (1, 1), (1, 3), (2, 1), (2, 3), (3, 1), (3, 3), (4, 1), (4, 3). The largest square field that can be formed by removing some fences is the square with side length 2 starting at coordinate (1, 1). The area of this square is 22 = 9.\n\n# Explanation", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/73", "content": "\n### Constraints:\n\n- 2 <= source.length, target.length <= 10^5\n- source.length == target.length\n- 1 <= source.length <= 10^5\n- original.length == changed.length\n- original.length == cost.length\n- 1 <= original.length <= 10^5\n- original[i] and changed[i] are lowercase English letters.\n- cost.length == original.length\n- 1 <= cost[i] <= 10^5\n- source and target only consists of lowercase English letters.\n\n### Examples\n\nExample 1:\n\n### Input: source = \"aba\", target = \"caa\", original = [\"a\",\"b\"], changed = [\"a\",\"c\"], cost = [1,2]\n### Output: 4\n### Explanation: One of the ways to convert source to target is:\n- Change the first character 'a' to 'c' with a cost of 1\n- Change the second character 'b' to 'a' with a cost of 2\n- The minimum cost to convert source to target is 1 + 2 = 3\n\n### Example 2:\n\n### Input: source = \"aab\", target = \"bba\", original = [\"a\",\"b\"], changed = [\"b\",\"a\"], cost = [1,2]\n### Output: 4\n### Explanation: One of the ways to convert source to target is:\n- Change the first character 'a' to 'b' with a cost of 1\n- Change the second character 'a' to 'b' with a cost of 2\n- The minimum cost to convert source to target is 1 + 2 = 3\n\n### Example 3:\n\n### Input: source = \"aab\", target = \"bba\", original = [\"a\",\"b\"], changed = [\"b\",\"a\"], cost = [1,2]\n### Output: 4\n### Explanation: One of the ways to convert source to target is:\n- Change the first character 'a' to 'b' with a cost of 1\n- Change the second character 'a' to 'b' with a cost of 2\n- The minimum cost to", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        dis = [[inf] * 26 for _ in range(26)]\n        for i in range(26):\n            dis[i][i] = 0\n\n        for x, y, c in zip(original, changed, cost):\n            x = ord(x) - ord('a')\n            y = ord(y) - ord('a')\n            dis[x][y] = min(dis[x][y], c)\n\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/74", "content": "\n\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, neighbors: List[Node] = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\nclass Solution:\n    def cloneGraph(self, node: 'Node') -> 'Node':\n        if not node:\n            return None\n        copied = Node(node.val)\n        copied_dict = {node: copied}\n        queue = deque([node])\n        while queue:\n            node = queue.popleft()\n            copied = copied_dict[node]\n            for neighbor in node.neighbors:\n                if neighbor not in copied_dict:\n                    copied_dict[neighbor] = Node(neighbor.val)\n                    queue.append(neighbor)\n                copied.neighbors.append(copied_dict[neighbor])\n        return copied_dict[node]\n", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/75", "content": "", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "cpp/0", "content": "\nConstraints\n-----------\n- n == nums.length\n- 1 ≤ n ≤ 10\n- 1 ≤ nums[i] ≤ 100\n- nums contains n distinct positive integers.\n\nExamples\n--------\nExample 1:\nInput: nums = [1,2,3]\nOutput: 2\nExplanation:\nThe special permutations of length 3 are:\n1. [1,2,3] (nums[0] % nums[1] == 0)\n2. [1,3,2] (nums[0] % nums[2] == 0)\nThe total number of special permutations is 2.\n\nExample 2:\nInput: nums = [2,2,2]\nOutput: 3\nExplanation:\nThe special permutations of length 3 are:\n1. [2,2,2] (nums[0] % nums[1] == 0)\n2. [2,2,2] (nums[1] % nums[2] == 0)\n3. [2,2,2] (nums[2] % nums[0] == 0)\nThe total number of special permutations is 3.\n\nExample 3:\nInput: nums = [1,1,1]\nOutput: 6\nExplanation:\nThe special permutations of length 3 are:\n1. [1,1,1] (nums[0] % nums[1] == 0)\n2. [1,1,1] (nums[1] % nums[2] == 0)\n3. [1,1,1] (nums[2] % nums[0] == 0)\n4. [1,1,1] (nums[0] % nums[1] == 0)\n5. [1,1,1] (nums[1] % nums[2] == 0)\n6. [1,1,1] (nums[2] % nums[0] == 0)\nThe total number of special permutations is 6.\n\n*/\n\nclass Solution {\npublic:\nstatic", "groundtruth": "class Solution {public:static const int mod = 1e9 + 7;int specialPerm(vector<int>& nums) {int n = nums.size();vector<vector<int>> f(1 << n, vector<int>(n, -1));function<int(int, int)> dfs = [&](int state, int i) {if (f[state][i] != -1) {return f[state][i];}if (state == (1 << i)) {return 1;}f[state][i] = 0;for (int j = 0; j < n; j++) {if (i == j || !(state >> j & 1)) {continue;}if (nums[i] % nums[j] != 0 && nums[j] % nums[i] != 0) {continue;}f[state][i] = (f[state][i] + dfs(state ^ (1 << i), j)) % mod;}return f[state][i];};int res = 0;for (int i = 0; i < n; i++) {res = (res + dfs((1 << n) - 1, i)) % mod;}return res;}};"}
{"task_id": "cpp/1", "content": "\n\n\nNote:\n\ncost.length == time.length == n\n1 <= n <= 10^4\n1 <= cost[i] <= 10^4\n1 <= time[i] <= 10^4\n\n\n\nExample 1:\n\nInput: cost = [1,2,3,4], time = [1,2,3,4]\nOutput: 4\nExplanation: \nThe minimum cost to paint all the walls is 4.\nOne optimal way to paint the walls is:\nPaint the 1st wall with the paid painter for 1 unit of time and cost 1.\nPaint the 2nd wall with the paid painter for 2 units of time and cost 2.\nPaint the 3rd wall with the paid painter for 3 units of time and cost 3.\nPaint the 4th wall with the paid painter for 4 units of time and cost 4.\nExample 2:\n\nInput: cost = [1,2,3,4,5,6,7,8,9,10], time = [1,2,3,4,5,6,7,8,9,10]\nOutput: 40\nExplanation:\nThe minimum cost to paint all the walls is 40.\nOne optimal way to paint the walls is:\nPaint the 1st wall with the paid painter for 1 unit of time and cost 1.\nPaint the 2nd wall with the paid painter for 2 units of time and cost 2.\nPaint the 3rd wall with the paid painter for 3 units of time and cost 3.\nPaint the 4th wall with the paid painter for 4 units of time and cost 4.\nPaint the 5th wall with the paid painter for 5 units of time and cost 5.\nPaint the 6th wall with the paid painter for 6 units of time and cost 6.\nPaint the 7th wall with the paid painter for 7 units of time and cost 7.\nPaint the 8th wall with the paid painter for 8 units of time and cost 8.\nPaint the 9th wall with the paid painter for 9 units of time and cost 9.\nPaint the 10th wall with the paid painter for ", "groundtruth": "class Solution {public:int paintWalls(vector<int>& cost, vector<int>& time) {int n = cost.size();vector<int> f(n * 2 + 1, INT_MAX / 2);f[n] = 0;for (int i = 0; i < n; ++i) {vector<int> g(n * 2 + 1, INT_MAX / 2);for (int j = 0; j <= n * 2; ++j) {// 付费g[min(j + time[i], n * 2)] = min(g[min(j + time[i], n * 2)], f[j] + cost[i]);// 免费if (j > 0) {g[j - 1] = min(g[j - 1], f[j]);}}f = move(g);}return *min_element(f.begin() + n, f.end());}};"}
{"task_id": "cpp/2", "content": "\n \n\nExample 1:\nInput: s = \"ab\"\nOutput: \"ba\"\nExplanation: The lexicographically smallest string is \"ba\", which occurs before \"ab\" in the dictionary.\nExample 2:\nInput: s = \"leetcode\"\nOutput: \"codeleet\"\nExplanation: We could convert the string to \"leetcoded\" or \"codeleet\" which occurs before \"leetcode\" in the dictionary.\nExample 3:\nInput: s = \"aabbccd\"\nOutput: \"abccd\"\nExplanation: We could convert the string to \"aabbccd\" or \"abccd\" which occurs before \"aabbccd\" in the dictionary.\n\nConstraints:\n\n1 <= s.length <= 100\ns consists of lowercase English letters.\n", "groundtruth": "class Solution {public:string smallestString(string s) {char target = 'a';auto it = std::find_if(s.begin(), s.end(), [target](char c) {return c != target;});int indexOfFirstNonA = std::distance(s.begin(), it);if (indexOfFirstNonA == s.length()) {return s.substr(0, s.length() - 1) + 'z';}size_t indexOfFirstA_AfterFirstNonA = s.find('a', indexOfFirstNonA);if (indexOfFirstA_AfterFirstNonA == string::npos) {indexOfFirstA_AfterFirstNonA = s.length();}string res;for (int i = 0; i < s.length(); ++i) {if (indexOfFirstNonA <= i && i < indexOfFirstA_AfterFirstNonA) {res.push_back(static_cast<char>(s[i] - 1));} else {res.push_back(s[i]);}}return res;}};"}
{"task_id": "cpp/3", "content": "\n#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\nusing namespace std;\nclass Solution {\npublic:\n    long long minCost(vector<int>& nums, int x) {\n        int n = nums.size();\n        vector<int> f(nums);\n        long long ans = 0;\n        for (int k = 1; k < n; ++k) {\n            for (int i = 0; i < n; ++i) {\n                f[i] = min(f[i], nums[(i + k) % n]);\n            }\n            ans += ____;\n        }\n        return ans;\n    }\n};\nint main() {\n    vector<int> nums = {3,2,1,4};\n    int x = 2;\n    Solution solution;\n    cout << solution.minCost(nums, x) << endl;\n    return 0;\n}", "groundtruth": "class Solution {public:long long minCost(vector<int>& nums, int x) {int n = nums.size();vector<int> f(nums);long long ans = accumulate(f.begin(), f.end(), 0LL);for (int k = 1; k < n; ++k) {for (int i = 0; i < n; ++i) {f[i] = min(f[i], nums[(i + k) % n]);}ans = min(ans, static_cast<long long>(k) * x + accumulate(f.begin(), f.end(), 0LL));}return ans;}};"}
{"task_id": "cpp/4", "content": "\nNote: The input/output format and example 3 are different from other examples. For the input, it is given that the answer to the ith query is -1.\n\n\n", "groundtruth": "class Solution {public:vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {vector<pair<int, int>> sortedNums;vector<tuple<int, int, int>> sortedQueries;for (int i = 0; i < nums1.size(); i++) {sortedNums.emplace_back(nums1[i], nums2[i]);}sort(sortedNums.begin(), sortedNums.end(), greater<pair<int, int>>());for (int i = 0; i < queries.size(); i++) {sortedQueries.emplace_back(i, queries[i][0], queries[i][1]);}sort(sortedQueries.begin(), sortedQueries.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b) {return get<1>(a) > get<1>(b);});vector<pair<int, int>> stk;vector<int> answer(queries.size(), -1);int j = 0;for (auto &[i, x, y] : sortedQueries) {while (j < sortedNums.size() && sortedNums[j].first >= x) {auto [num1, num2] = sortedNums[j];while (!stk.empty() && stk.back().second <= num1 + num2) {stk.pop_back();}if (stk.empty() || stk.back().first < num2) {stk.emplace_back(num2, num1 + num2);}j++;}int k = lower_bound(stk.begin(), stk.end(), make_pair(y, 0)) - stk.begin();if (k < stk.size()) {answer[i] = stk[k].second;}}return answer;}};"}
{"task_id": "cpp/5", "content": "Example 1:\nInput: s = \"abab\"\nOutput: 2\nExplanation: The longest semi-repetitive substring is \"ab\".\nExample 2:\nInput: s = \"aaa\"\nOutput: 3\nExplanation: The longest semi-repetitive substring is \"aaa\".\nExample 3:\nInput: s = \"aaaaa\"\nOutput: 5\nExplanation: The longest semi-repetitive substring is \"aaaaa\".\nExample 4:\nInput: s = \"abcabcabc\"\nOutput: 3\nExplanation: The longest semi-repetitive substring is \"abc\".\nExample 5:\nInput: s = \"abcabcabcabc\"\nOutput: 4\nExplanation: The longest semi-repetitive substring is \"abcabc\".\nConstraints:\n1 <= s.length <= 105\ns consists of lowercase English letters.\n", "groundtruth": "class Solution {public:int longestSemiRepetitiveSubstring(string s) {int ans = 1, left = 0, same = 0, n = s.length();for (int right = 1; right < n; right++) {if (s[right] == s[right - 1] && ++same > 1) {for (left++; s[left] != s[left - 1]; left++);same = 1;}ans = max(ans, right - left + 1);}return ans;}};"}
{"task_id": "cpp/6", "content": "\n\nExample 1:\nInput: nums = [1,2,3,4], s = \"RR\", d = 1\nOutput: 2\nExplanation: After one second, all the robots will move one unit to right, so the distance between robot 0 and robot 1 is 1, between robot 0 and robot 2 is 2 and between robot 0 and robot 3 is 3.\nExample 2:\nInput: nums = [5,4,3,2,1], s = \"LMLMLMLMM\", d = 2\nOutput: 19\nExplanation: After two seconds, the positions of the robots are:\n- 0th robot: [4, 1, 2, 3, 5]\n- 1st robot: [3, 2, 1, 0, 4]\n- 2nd robot: [2, 1, 0, 4, 3]\n- 3rd robot: [1, 0, 4, 3, 2]\n- 4th robot: [0, 4, 3, 2, 1]\n\nTherefore the sum of distances between the pairs of robots is 1 + 1 + 1 + 1 + 1 = 5.\n\nExample 3:\nInput: nums = [1,1,1,1], s = \"LLRR\", d = 2\nOutput: 3\nExplanation: After two seconds, the positions of the robots are:\n- 0th robot: [0, 1, 1, 1]\n- 1st robot: [1, 0, 1, 1]\n- 2nd robot: [1, 1, 0, 1]\n- 3rd robot: [1, 1, 1, 0]\n\nTherefore the sum of distances between the pairs of robots is 3.\n \n\nConstraints:\nnums.length == n\n1 <= n <= 100\n0 <= nums[i] <= 100\ns.length == n\ns[i] is either 'L' or 'R'.\n0 <= d <= 100\n*/\n", "groundtruth": "class Solution {public:static constexpr int mod = 1e9 + 7;int sumDistance(vector<int>& nums, string s, int d) {int n = nums.size();vector<long long> pos(n);for (int i = 0; i < n; i++) {if (s[i] == 'L') {pos[i] = (long long) nums[i] - d;} else {pos[i] = (long long) nums[i] + d;}}sort(pos.begin(), pos.end());long long res = 0;for (int i = 1; i < n; i++) {res += 1ll * (pos[i] - pos[i - 1]) * i % mod * (n - i) % mod;res %= mod;}return res;}};"}
{"task_id": "cpp/7", "content": "\nExample 1:\nInput: grid = [[1,0,0,0,1],[0,0,0,1,0],[1,0,1,0,1],[0,0,0,0,0],[1,0,1,0,1]]\nOutput: [1,4,9]\nExplanation: The following sets of rows are a good subset:\n- [1,4,9]: The sum of each column is at most half of the length of the subset.\n- [4,9]: The sum of each column is at most half of the length of the subset.\n- [1,4]: The sum of each column is at most half of the length of the subset.\n- [1,9]: The sum of each column is at most half of the length of the subset.\n- [4,1]: The sum of each column is at most half of the length of the subset.\n- [9,4]: The sum of each column is at most half of the length of the subset.\n- [9,1]: The sum of each column is at most half of the length of the subset.\nOnly one subset is returned because we want only one unique solution.\n\nExample 2:\nInput: grid = [[1,0,0],[1,1,0],[1,1,1]]\nOutput: [0,1,2]\nExplanation: The following sets of rows are a good subset:\n- [0,1,2]: The sum of each column is at most half of the length of the subset.\nOnly one subset is returned because we want only one unique solution.\n\nExample 3:\nInput: grid = [[1,1,1,1,1,1,1]]\nOutput: [0]\nExplanation: The only good subset is [0].\n\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 10^5\ngrid[i][j] is either 0 or 1.\n\n\n```\n/*\n * @lc app=leetcode id=1435 lang=cpp\n *\n * [1435] Maximum Number of Events That Can Be Attended\n */\n\n// @lc code=start\n\nclass Solution {\npublic:\n", "groundtruth": "class Solution {public:vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {vector<int> ans;unordered_map<int, int> mp;int m = grid.size();int n = grid[0].size();for (int j = 0; j < m; j++) {int st = 0;for (int i = 0; i < n; i++) {st |= (grid[j][i] << i);}mp[st] = j;}if (mp.count(0)) {ans.push_back(mp[0]);return ans;}for (auto [x, i]: mp) {for (auto [y, j]: mp) {if (!(x & y)) {return {min(i, j), max(i, j)};}}}return ans;}};"}
{"task_id": "cpp/8", "content": "\nclass Solution {\npublic:\n    long long matrixSumQueries(int n, vector<vector<int>> &queries) {\n        long long ans = 0;\n        unordered_set<int> vis[2];\n        for (int i = queries.size() - 1; i >= 0; i--) {\n            auto &q = queries[i];\n            int type = q[0], index = q[1], val = q[2];\n            if (!vis[type].count(index)) {\n                // 后面（>i）没有对这一行/列的操作\n                // 这一行/列还剩下 n-vis[type^1].size() 个可以填入的格子\n                // ____vis[type].insert(index);\n            }\n        }\n        return ans;\n    }\n};\n", "groundtruth": "class Solution {public:long long matrixSumQueries(int n, vector<vector<int>> &queries) {long long ans = 0;unordered_set<int> vis[2];for (int i = queries.size() - 1; i >= 0; i--) {auto &q = queries[i];int type = q[0], index = q[1], val = q[2];if (!vis[type].count(index)) { // 后面（>i）没有对这一行/列的操作// 这一行/列还剩下 n-vis[type^1].size() 个可以填入的格子ans += (long long) (n - vis[type ^ 1].size()) * val;vis[type].insert(index);}}return ans;}};"}
{"task_id": "cpp/9", "content": "Example 1:\nInput: num1 = \"52\", num2 = \"72\", min_sum = 1, max_sum = 20\nOutput: 4\nExplanation: The 4 good integers are 53, 54, 55, and 56.\nExample 2:\nInput: num1 = \"0\", num2 = \"0\", min_sum = 1, max_sum = 1000000000\nOutput: 1\nExplanation: The only good integer is 1.\nConstraints:\nnum1 and num2 are positive integers, represented as strings.\nnum1.length == num2.length\n1 <= num1.length <= 10\n1 <= num1[i], num2[i] <= 1000\n1 <= min_sum <= max_sum <= 1000\nExample 3:\nInput: num1 = \"1\", num2 = \"1\", min_sum = 1, max_sum = 1\nOutput: 1\n \nRelated Topics\nMath\nString\nDynamic Programming\nSimilar Questions\nCount Number of Nice Subarrays\n", "groundtruth": "class Solution {static constexpr int N = 23;static constexpr int M = 401;static constexpr int MOD = 1e9 + 7;int d[N][M];string num;int min_sum;int max_sum;int dfs(int i, int j, bool limit) {if (j > max_sum) {return 0;}if (i == -1) {return j >= min_sum;}if (!limit && d[i][j] != -1) {return d[i][j];}int res = 0;int up = limit ? num[i] - '0' : 9;for (int x = 0; x <= up; x++) {res = (res + dfs(i - 1, j + x, limit && x == up)) % MOD;}if (!limit) {d[i][j] = res;}return res;}int get(string num) {reverse(num.begin(), num.end());this->num = num;return dfs(num.size() - 1, 0, true);}// 求解 num - 1，先把最后一个非 0 字符减去 1，再把后面的 0 字符变为 9string sub(string num) {int i = num.size() - 1;while (num[i] == '0') {i--;}num[i]--;i++;while (i < num.size()) {num[i] = '9';i++;}return num;}public:int count(string num1, string num2, int min_sum, int max_sum) {memset(d, -1, sizeof d);this->min_sum = min_sum;this->max_sum = max_sum;return (get(num2) - get(sub(num1)) + MOD) % MOD;}};"}
{"task_id": "cpp/10", "content": "\nclass Solution {\npublic:\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\n        int n = mat.size();\n        int m = mat[0].size();\n        unordered_map<int, pair<int, int>> mp;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                mp[mat[i][j]] = {i, j};\n            }\n        }\n        vector<int> rowCnt(n, 0);\n        vector<int> colCnt(m, 0);\n        for (int i = 0; i < arr.size(); ++i) {\n            auto v = mp[arr[i]];\n            ++rowCnt[v.first];\n            if (rowCnt[v.first] == m) {\n                return i;\n            }\n            ++colCnt[v.second];\n            if (colCnt[v.second] == n) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n", "groundtruth": "class Solution {public:int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {int n = mat.size();int m = mat[0].size();unordered_map<int, pair<int, int>> mp;for (int i = 0; i < n; ++i) {for (int j = 0; j < m; ++j) {mp[mat[i][j]] = {i, j};}}vector<int> rowCnt(n, 0);vector<int> colCnt(m, 0);for (int i = 0; i < arr.size(); ++i) {auto& v = mp[arr[i]];++rowCnt[v.first];if (rowCnt[v.first] == m) {return i;}++colCnt[v.second];if (colCnt[v.second] == n) {return i;}}return -1;}};"}
{"task_id": "cpp/11", "content": "\nExample 1:\nInput: start = [1,2], target = [3,4], specialRoads = [[1,2,3,4,5]]\nOutput: 5\n\nExample 2:\nInput: start = [1,1], target = [2,2], specialRoads = [[1,1,2,2,1]]\nOutput: 1\n\nExample 3:\nInput: start = [1,1], target = [2,2], specialRoads = [[1,1,2,2,10]]\nOutput: 1\n\nConstraints:\nstart.length == 2\ntarget.length == 2\n1 <= startx, starty, targetx, targety <= 10^5\nspecialRoads.length <= 10^5\nspecialRoads[i].length == 5\n1 <= xi, yi, xi', yi' <= 10^5\n1 <= costi <= 10^5\nAll (xi, yi) are distinct.\nAll (xi', yi') are distinct.\nThere are at most 10^5 special roads.\nThe given graph is a connected graph.\n", "groundtruth": "class Solution {public:int minimumCost(vector<int> &start, vector<int> &target, vector <vector<int>> &specialRoads) {using LL = long long;LL t = (LL) target[0] << 32 | target[1];unordered_map<LL, int> dis = {{(LL) start[0] << 32 | start[1], 0}, {t, INT_MAX}};unordered_set<LL> vis;for (;;) {LL v = -1;int dv = -1;for (auto &[p, d]: dis)if (!vis.count(p) && (dv < 0 || d < dv))v = p, dv = d;if (v == t) return dv; // 到终点的最短路已确定vis.insert(v);int vx = v >> 32, vy = v & UINT32_MAX;// 更新到终点的最短路dis[t] = min(dis[t], dv + target[0] - vx + target[1] - vy);for (auto &r: specialRoads) {int d = dv + abs(r[0] - vx) + abs(r[1] - vy) + r[4];LL w = (LL) r[2] << 32 | r[3];if (!dis.count(w) || d < dis[w])dis[w] = d;}}}};"}
{"task_id": "cpp/12", "content": "\nThe example is as follows:\n\nInput: s = \"aab\", k = 3\nOutput: \"aacb\"\nExplanation:\nThe string \"aab\" is beautiful because it consists of the first three letters of the English lowercase alphabet.\nIt does not contain any substring of length 2 or more which is a palindrome.\nThe lexicographically smallest string of length 3, which is larger than \"aab\" and is beautiful, is \"aacb\".\n\nInput: s = \"aabc\", k = 3\nOutput: \"\"\nExplanation:\nThe string \"aabc\" is not beautiful because it contains the substring \"abc\".\nThe lexicographically smallest string of length 3, which is larger than \"aabc\" and is beautiful, is an empty string.\n\nInput: s = \"abc\", k = 2\nOutput: \"abdc\"\nExplanation:\nThe string \"abc\" is beautiful because it consists of the first two letters of the English lowercase alphabet.\nIt does not contain any substring of length 2 or more which is a palindrome.\nThe lexicographically smallest string of length 2, which is larger than \"abc\" and is beautiful, is \"abdc\".\n\n\n \n\nNote:\n\nThe length of s will be in the range [1, 1000].\nk will be in the range [1, 1000].\ns will consist of lowercase letters.\n", "groundtruth": "class Solution {public:string smallestBeautifulString(string s, int k) {for (int i = s.length() - 1; i >= 0; --i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {____}}for (int j = 1; j <= 3; ++j) {if (s[i] - 'a' + j + 1 <= k && blockedCharacters.find(s[i] + j) == blockedCharacters.end()) {return generate(s, i, j);}}}return \"\";}string generate(string s, int idx, int offset) {s[idx] += offset;for (int i = idx + 1; i < s.length(); ++i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {blockedCharacters.insert(s[i - j]);}}for (int j = 0; j < 3; ++j) {if (____) {s[i] = 'a' + j;break;}}}return s;}};"}
{"task_id": "cpp/13", "content": "Example 1:\nInput:\na = [2, 1, 3, 5]\nb = [1, 2, 3, 4]\nOutput:\n[1, 2, 3]\nExplanation:\nThe prefix common array of A and B is [1, 2, 3].\n\nExample 2:\nInput:\na = [2, 1, 2, 4, 3, 5]\nb = [1, 2, 3, 4, 5]\nOutput:\n[1, 2, 3, 4, 5]\nExplanation:\nThe prefix common array of A and B is [1, 2, 3, 4, 5].\n\n \n\nConstraints:\n\n1 <= n <= 105\n1 <= A[i], B[i] <= n\nA and B consist of each integer from 1 to n exactly once.\n\n\n\n \n\n \n\n \n\n\n", "groundtruth": "class Solution {public:vector<int> findThePrefixCommonArray(vector<int> &a, vector<int> &b) {int n = a.size();vector<int> ans(n);long long p = 0, q = 0;for (int i = 0; i < n; ++i) {p |= 1LL << a[i];q |= 1LL << b[i];ans[i] = __builtin_popcountll(p & q);}return ans;}};"}
{"task_id": "cpp/14", "content": "Example:\nInput: grid = [[1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ", "groundtruth": "class Solution {static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};public:int findMaxFish(vector<vector<int>> &grid) {int m = grid.size(), n = grid[0].size(), ans = 0;function<int(int, int)> dfs = [&](int x, int y) -> int {if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)return 0;int sum = grid[x][y];grid[x][y] = 0; // 标记成访问过for (auto &d: dirs) // 四方向移动sum += dfs(x + d[0], y + d[1]);return sum;};for (int i = 0; i < m; ++i)for (int j = 0; j < n; ++j)ans = max(ans, dfs(i, j));return ans;}};"}
{"task_id": "cpp/15", "content": "\n \n\nExample 1:\n\nInput: nums = [2,1,3,4,5]\nOutput: 5\nExplanation: The array is initially [2,1,3,4,5].\n1. The first element has the smallest value, so remove it and answer is 1.\nThe array is now [1,3,4,5].\n2. 4 is the smallest value, so remove it and answer is 2.\nThe array is now [1,3,5].\n3. 5 is the smallest value, so remove it and answer is 3.\nThe array is now [1,3].\n4. 3 is the smallest value, so remove it and answer is 4.\nThe array is now [1].\n5. 1 is the smallest value, so remove it and answer is 5.\nThe array is now [].\nThus, we return 5.\nExample 2:\n\nInput: nums = [1,1,1]\nOutput: 3\nExplanation: The array is initially [1,1,1].\n1. The first element has the smallest value, so remove it and answer is 1.\nThe array is now [1,1].\n2. The second element has the smallest value, so remove it and answer is 2.\nThe array is now [1].\n3. The third element has the smallest value, so remove it and answer is 3.\nThe array is now [].\nThus, we return 3.\n\n \n\nConstraints:\n\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\nAll the elements of nums are unique.\n\n```\n/*\n * @lc app=leetcode id=1953 lang=cpp\n *\n * [1953] Minimum Operations to Make a Subsequence\n */\n\n// @lc code=start\n#include <bits/stdc++.h>\nusing namespace std;\nclass BIT {\npublic:\n    vector<int> tree;\n\n    BIT(int n) : tree(n) {}\n\n    void inc(int i) {\n        while (i < tree.size()) {\n            ++", "groundtruth": "// 树状数组模板class BIT {vector<int> tree;public:BIT(int n) : tree(n) {}// 将下标 i 上的数加一void inc(int i) {while (i < tree.size()) {++tree[i];i += i & -i;}}// 返回闭区间 [1, i] 的元素和int sum(int x) {int res = 0;while (x > 0) {res += tree[x];x &= x - 1;}return res;}// 返回闭区间 [left, right] 的元素和int query(int left, int right) {return sum(right) - sum(left - 1);}};class Solution {public:long long countOperationsToEmptyArray(vector<int> &nums) {int n = nums.size(), id[n];iota(id, id + n, 0);sort(id, id + n, [&](int i, int j) {return nums[i] < nums[j];});long long ans = n; // 先把 n 计入答案BIT t(n + 1); // 下标从 1 开始int pre = 1; // 上一个最小值的位置，初始为 1for (int k = 0; k < n; ++k) {int i = id[k] + 1; // 下标从 1 开始if (i >= pre) // 从 pre 移动到 i，跳过已经删除的数ans += i - pre - t.query(pre, i);else // 从 pre 移动到 n，再从 1 移动到 i，跳过已经删除的数ans += n - pre + i - k + t.query(i, pre - 1);t.inc(i); // 删除 ipre = i;}return ans;}};"}
{"task_id": "cpp/16", "content": "The code is as follows:\nclass Solution {public:vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x) {const int BIAS = 50;int cnt[BIAS * 2 + 1]{}, n = nums.size();for (int i = 0; i < k - 1; ++i) // 先往窗口内添加 k-1 个数____vector<int> ans(n - k + 1);for (int i = k - 1; i < n; ++i) {++cnt[nums[i] + BIAS]; // 进入窗口（保证窗口有恰好 k 个数）int left = x;for (int j = 0; j < BIAS; ++j) { // 暴力枚举负数范围 [-50,-1]____if (left <= 0) { // 找到美丽值ans[i - k + 1] = j - BIAS;break;}}--cnt[nums[i - k + 1] + BIAS]; // 离开窗口}return ans;}};\n \n \n\n \n\nNote:\n\n1 <= nums.length <= 5 * 10^4\n-50 <= nums[i] <= 50\n1 <= k <= nums.length\n1 <= x <= k\n \n\nFollow up: Could you solve the problem in O(n log k) time?\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\n        int BIAS = 50;\n        int cnt[BIAS*2+1]{}, n = nums.size();\n        for (int i = 0; i < k - 1; ++i) // 先往窗口内添加 k-1 个数____vector<int> ans(n - k + 1", "groundtruth": "class Solution {public:vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x) {const int BIAS = 50;int cnt[BIAS * 2 + 1]{}, n = nums.size();for (int i = 0; i < k - 1; ++i) // 先往窗口内添加 k-1 个数++cnt[nums[i] + BIAS];vector<int> ans(n - k + 1);for (int i = k - 1; i < n; ++i) {++cnt[nums[i] + BIAS]; // 进入窗口（保证窗口有恰好 k 个数）int left = x;for (int j = 0; j < BIAS; ++j) { // 暴力枚举负数范围 [-50,-1]left -= cnt[j];if (left <= 0) { // 找到美丽值ans[i - k + 1] = j - BIAS;break;}}--cnt[nums[i - k + 1] + BIAS]; // 离开窗口}return ans;}};"}
{"task_id": "cpp/17", "content": "\n \n\nNote:\n\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n\n\n \n\nExample 1:\n\nInput: nums = [2,4,8,2]\nOutput: 4\nExplanation: The operations are:\n- 2 and 4 are replaced with 2. nums = [2,2,8,2].\n- 2 and 8 are replaced with 4. nums = [2,2,4,2].\n- 2 and 4 are replaced with 2. nums = [2,2,2,2].\nAll elements in nums are now equal to 2.\nExample 2:\n\nInput: nums = [3,2,3,4,3]\nOutput: -1\nExplanation: The operations are:\n- 3 and 3 are replaced with 3. nums = [3,2,3,4,3].\n- 3 and 4 are replaced with 3. nums = [3,2,3,3,3].\n- 3 and 3 are replaced with 3. nums = [3,2,3,3,3].\n- 2 and 3 are replaced with 3. nums = [3,3,3,3,3].\n- 3 and 3 are replaced with 3. nums = [3,3,3,3,3].\n- 3 and 3 are replaced with 3. nums = [3,3,3,3,3].\n- 3 and 3 are replaced with 3. nums = [3,3,3,3,3].\n- 3 and 3 are replaced with 3. nums = [3,3,3,3,3].\n- 3 and 3 are replaced with 3. nums = [3,3,3,3,3].\n- 3 and 3 are replaced with 3. nums = [3,3,3,3,3].\n- 3 and 3 are replaced with 3. nums = [3,3,3,3,3].\n- 3 and 3 are replaced with 3. nums =", "groundtruth": "class Solution {public:int minOperations(vector<int> &nums) {int n = nums.size(), gcd_all = 0, cnt1 = 0;for (int x: nums) {gcd_all = gcd(gcd_all, x);cnt1 += x == 1;}if (gcd_all > 1) return -1;if (cnt1) return n - cnt1;int min_size = n;for (int i = 0; i < n; ++i) {int g = 0;for (int j = i; j < n; ++j) {g = gcd(g, nums[j]);if (g == 1) {// 这里本来是 j-i+1，把 +1 提出来合并到 return 中min_size = min(min_size, j - i);break;}}}return min_size + n - 1;}};"}
{"task_id": "cpp/18", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {public:int maxDivScore(vector<int>& nums, vector<int>& divisors) {int cnt = -1, ans = 0;for (int i = 0; i < divisors.size(); i++) {int tmp = 0;for (int j = 0; j < nums.size(); j++) {if (nums[j] % divisors[i] == 0) {tmp++;}}if (tmp > cnt || (tmp == cnt && divisors[i] < ans)) {ans = divisors[i];cnt = tmp;}}return ans;}};"}
{"task_id": "cpp/19", "content": "\n### 分析\n\n首先，当字符串中存在'a','b','c'时，这时候插入其他字符，字符串就不再是合法的了，所以这时候的插入次数最小。\n\n其次，当字符串中不存在'a','b','c'时，插入字符的次数和字符串长度一样。\n\n因此，当word中不存在'a','b','c'时，直接返回n。\n\n当word中存在'a','b','c'时，遍历字符串，对每个字符进行判断。如果字符是'a'或'b'，则将d[i]减1，然后将'c'的位置加1。这时候如果字符串中的字符都是'a'或'b'，则说明字符串不合法，需要插入'c'，因此返回d[n]。\n\n时间复杂度：O(n)\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int addMinimum(string word) {\n        int n = word.size();\n        vector<int> d(n + 1);\n        for (int i = 1; i <= n; i++) {\n            if (word[i - 1] == 'a' || word[i - 1] == 'b') {\n                d[i] = d[i - 1] - 1;\n            } else if (word[i - 1] == 'c') {\n                d[i] = d[i - 1] + 1;\n            }\n        }\n        return d[n];\n    }\n};\n```\n\n", "groundtruth": "class Solution {public:int addMinimum(string word) {int n = word.size();vector<int> d(n + 1);for (int i = 1; i <= n; i++) {d[i] = d[i - 1] + 2;if (i > 1 && word[i - 1] > word[i - 2]) {d[i] = d[i - 1] - 1;}}return d[n];}};"}
{"task_id": "cpp/20", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {public:int minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips) {vector<vector<int>> next(n);for (auto &edge : edges) {next[edge[0]].push_back(edge[1]);next[edge[1]].push_back(edge[0]);}vector<int> count(n);function<bool(int, int, int)> dfs = [&](int node, int parent, int end) -> bool {if (node == end) {count[node]++;return true;}for (int child : next[node]) {if (child == parent) {continue;}if (dfs(child, node, end)) {count[node]++;return true;}}return false;};for (auto &trip: trips) {dfs(trip[0], -1, trip[1]);}function<pair<int, int>(int, int)> dp = [&](int node, int parent) -> pair<int, int> {pair<int, int> res = {price[node] * count[node], price[node] * count[node] / 2};for (int child : next[node]) {if (child == parent) {continue;}auto [x, y] = dp(child, node);res.first += min(x, y); // node 没有减半，因此可以取子树的两种情况的最小值res.second += x; // node 减半，只能取子树没有减半的情况}return res;};auto [x, y] = dp(0, -1);return min(x, y);}};"}
{"task_id": "cpp/21", "content": "Example:\nInput: nums = [3,4,5,5,1]\nOutput: [3,7,9,13,15]\nExplanation: The score of the prefix nums[0..i] is the sum of the conversion array of nums[0..i].\nThe conversion array of nums[0..i] is [3,3,3,3,3] so the score is 3 + 3 + 3 + 3 + 3 = 15.\nThe conversion array of nums[0..i] is [3,4,4,4,4] so the score is 3 + 4 + 4 + 4 + 4 = 15.\nThe conversion array of nums[0..i] is [3,4,5,5,5] so the score is 3 + 4 + 5 + 5 + 5 = 18.\nThe conversion array of nums[0..i] is [3,4,5,5,5] so the score is 3 + 4 + 5 + 5 + 5 = 18.\nThe conversion array of nums[0..i] is [3,4,5,5,5] so the score is 3 + 4 + 5 + 5 + 5 = 18.\nConstraints:\n2 <= nums.length <= 1000\n1 <= nums[i] <= 105\n", "groundtruth": "class Solution {public:vector<long long> findPrefixScore(vector<int>& nums) {vector<long long> ans;int tmp = nums[0];ans.push_back(nums[0] * 2);for (int i = 1; i < nums.size(); ++i) {if (nums[i] > tmp) tmp = nums[i];ans.push_back(nums[i] + tmp + ans[i - 1]);}return ans;}};"}
{"task_id": "cpp/22", "content": "\nExample:\n\nInput: root = [1,2,3,4,5,6,7]\nOutput: [10,20,30,40,50,60,70]\n \n\nNote:\n\nThe number of nodes in the tree is between 1 and 100.\nEach node in the tree has a unique value between 1 and 100.\n\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    TreeNode* replaceValueInTree(TreeNode* root) {\n        vector<TreeNode*> q = {root};\n        root->val = 0;\n        while (!q.empty()) {\n            vector<TreeNode*> q2;\n            int sum = 0;\n            for (auto fa : q) {\n                if (fa->left) {\n                    q2.push_back(fa->left);\n                    sum += fa->left->val;\n                }\n                if (fa->right) {\n                    q2.push_back(fa->right);\n                    sum += fa->right->val;\n                }\n            }\n            for (auto fa : q) {\n                int child_sum = (fa->left ? fa->left->val : 0) + (fa->right ? fa->right->val : 0);\n                if (fa->left) {\n                    fa->left->val = sum - child_sum;\n                }\n                if (fa->right) {\n                    fa->right->val = sum - child_sum;\n                }\n            }\n            q = move(q2);\n        }\n        return root;\n    }\n};", "groundtruth": "class Solution {public:TreeNode* replaceValueInTree(TreeNode* root) {vector<TreeNode*> q = {root};root->val = 0;while (!q.empty()) {vector<TreeNode*> q2;int sum = 0;for (auto fa : q) {if (fa->left) {q2.push_back(fa->left);sum += fa->left->val;}if (fa->right) {q2.push_back(fa->right);sum += fa->right->val;}}for (auto fa : q) {int child_sum = (fa->left ? fa->left->val : 0) +(fa->right ? fa->right->val : 0);if (fa->left) {fa->left->val = sum - child_sum;}if (fa->right) {fa->right->val = sum - child_sum;}}q = move(q2);}return root;}};"}
{"task_id": "cpp/23", "content": "\nThe input format:\nThe first line contains an integer n (1 <= n <= 1000) that indicates the number of nodes in the graph. The next line contains n - 1 pairs of integers, where the i-th pair is edgei = [fromi, toi, edgeCosti] (0 <= fromi, toi < n, 1 <= edgeCosti <= 1000) indicating that there is an edge from fromi to toi with the cost edgeCosti.\nThe output format:\nThe only line contains an integer indicating the minimum cost of a path from node1 to node2. If no path exists, return -1.\n\nSample Input 1:\n3\n0 1 1\n1 2 1\n2 0 1\n1\nSample Output 1:\n-1\n\nSample Input 2:\n4\n0 1 1\n0 2 1\n1 3 1\n2 3 1\n0\nSample Output 2:\n3\n\nSample Input 3:\n4\n0 1 1\n0 2 1\n1 3 1\n2 3 1\n2\nSample Output 3:\n-1\n\nSample Input 4:\n4\n0 1 1\n0 2 1\n1 3 1\n2 3 1\n1\nSample Output 4:\n2\n\nSample Input 5:\n4\n0 1 1\n0 2 1\n1 3 1\n2 3 1\n2\nSample Output 5:\n3\n\nSample Input 6:\n5\n0 1 1\n0 2 1\n1 3 1\n2 3 1\n3 4 1\n2\nSample Output 6:\n-1\n\nNote: For the sample cases, assume that there is no edge between two nodes if there is no edge in the graph.\n", "groundtruth": "class Graph {public:using pii = pair<int, int>;Graph(int n, vector<vector<int>>& edges) {this->graph = vector<vector<pii>>(n);for (auto &vec : edges) {int x = vec[0];int y = vec[1];int cost = vec[2];graph[x].emplace_back(y, cost);}}void addEdge(vector<int> edge) {int x = edge[0];int y = edge[1];int cost = edge[2];graph[x].emplace_back(y, cost);}int shortestPath(int node1, int node2) {priority_queue<pii, vector<pii>, greater<pii>> pq;vector<int> dist(graph.size(), INT_MAX);dist[node1] = 0;pq.emplace(0, node1);while (!pq.empty()) {auto [cost, cur] = pq.top();pq.pop();if (cur == node2) {return cost;}for (auto [next, ncost] : graph[cur]) {if (dist[next] > cost + ncost) {dist[next] = cost + ncost;pq.emplace(cost + ncost, next);}}}return -1;}private:vector<vector<pii>> graph;};"}
{"task_id": "cpp/24", "content": "\n\nInput: nums = [1,2,3,4,5,6,10]\nOutput: [1,1,1,1,1,1,0]\n\n\n\nclass Solution {\npublic:\n    vector<long long> distance(vector<int> &nums) {\n        int n = nums.size();\n        unordered_map<int, vector<int>> groups;\n        for (int i = 0; i < n; ++i) groups[nums[i]].push_back(i);\n        // 相同元素分到同一组，记录下标\n        vector<long long> ans(n);\n        long long s[n + 1];\n        s[0] = 0;\n        for (auto &[_, a]: groups) {\n            int m = a.size();\n            for (int i = 0; i < m; ++i) s[i + 1] = s[i] + a[i];\n            // 前缀和\n            for (int i = 0; i < m; ++i) {\n                long long target = a[i];\n                long long right = s[m] - s[i] - target * (m - i);\n                // 绿色面积\n                ans[a[i]] = right + target * i;\n                // 蓝色面积\n            }\n        }\n        return ans;\n    }\n};", "groundtruth": "class Solution {public:vector<long long> distance(vector<int> &nums) {int n = nums.size();unordered_map<int, vector<int>> groups;for (int i = 0; i < n; ++i)groups[nums[i]].push_back(i); // 相同元素分到同一组，记录下标vector<long long> ans(n);long long s[n + 1];s[0] = 0;for (auto &[_, a]: groups) {int m = a.size();for (int i = 0; i < m; ++i)s[i + 1] = s[i] + a[i]; // 前缀和for (int i = 0; i < m; ++i) {long long target = a[i];long long left = target * i - s[i]; // 蓝色面积long long right = s[m] - s[i] - target * (m - i); // 绿色面积ans[target] = left + right;}}return ans;}};"}
{"task_id": "cpp/25", "content": "Note that left is the lower bound of the range, right is the upper bound of the range, mid is the middle value of the range, and the range is [left, right).\n\n", "groundtruth": "class Solution {public:int minimizeMax(vector<int> &nums, int p) {sort(nums.begin(), nums.end());int left = -1, right = nums.back() - nums[0]; // 开区间while (left + 1 < right) { // 开区间int mid = left + (right - left) / 2, cnt = 0;for (int i = 0; i < nums.size() - 1; ++i)if (nums[i + 1] - nums[i] <= mid) { // 都选++cnt;++i;}(cnt >= p ? right : left) = mid;}return right;}};"}
{"task_id": "cpp/26", "content": "\nclass Solution {\npublic:\n    int minimumVisitedCells(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> dist(m, vector<int>(n, -1));\n        dist[0][0] = 1;\n        vector<priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>> row(m), col(n);\n        auto update = [](int& x, int y) {\n            if (x == -1 || y < x) {\n                x = y;\n            }\n        };\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                while (!row[i].empty() && row[i].top().second + grid[i][row[i].top().second] < j) {\n                    row[i].pop();\n                }\n                if (!row[i].empty()) {\n                    update(dist[i][j], row[i].top().first + 1);\n                }\n                while (!col[j].empty() && col[j].top().second + grid[col[j].top().second][j] < i) {\n                    col[j].pop();\n                }\n                if (!col[j].empty()) {\n                    update(dist[i][j], col[j].top().first + 1);\n                }\n                if (dist[i][j] != -1) {\n                    row[i].emplace(dist[i][j], j);\n                    col[j].emplace(dist[i][j], i);\n                }\n            }\n        }\n        return dist[m - 1][n - 1];\n    }\n};\n", "groundtruth": "class Solution {public:int minimumVisitedCells(vector<vector<int>>& grid) {int m = grid.size(), n = grid[0].size();vector<vector<int>> dist(m, vector<int>(n, -1));dist[0][0] = 1;vector<priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>> row(m), col(n);auto update = [](int& x, int y) {if (x == -1 || y < x) {x = y;}};for (int i = 0; i < m; ++i) {for (int j = 0; j < n; ++j) {while (!row[i].empty() && row[i].top().second + grid[i][row[i].top().second] < j) {row[i].pop();}if (!row[i].empty()) {update(dist[i][j], dist[i][row[i].top().second] + 1);}while (!col[j].empty() && col[j].top().second + grid[col[j].top().second][j] < i) {col[j].pop();}if (!col[j].empty()) {update(dist[i][j], dist[col[j].top().second][j] + 1);}if (dist[i][j] != -1) {row[i].emplace(dist[i][j], j);col[j].emplace(dist[i][j], i);}}}return dist[m - 1][n - 1];}};"}
{"task_id": "cpp/27", "content": "", "groundtruth": "class Solution {public:vector<vector<int>> findMatrix(vector<int> &nums) {unordered_map<int, int> cnt;for (int x: nums) ++cnt[x];vector<vector<int>> ans;while (!cnt.empty()) {vector<int> row;for (auto it = cnt.begin(); it != cnt.end();) {row.push_back(it->first);if (--it->second == 0) it = cnt.erase(it);else ++it;}ans.push_back(row);}return ans;}};"}
{"task_id": "cpp/28", "content": "", "groundtruth": "class Solution {public:int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {int ans = 0;int n = reward1.size();vector<int> diffs(n);for (int i = 0; i < n; i++) {ans += reward2[i];diffs[i] = reward1[i] - reward2[i];}sort(diffs.begin(), diffs.end());for (int i = 1; i <= k; i++) {ans += diffs[n - i];}return ans;}};"}
{"task_id": "cpp/29", "content": "\nThe given code uses an efficient algorithm to solve the problem. You are only required to fill in the blanks.\n\nInput: n = 7, p = 3, banned = [2, 4, 6, 8, 10], k = 2Output: [-1, -1, -1, -1, -1, -1, 2]Explanation: There are 7 positions in total.In the beginning, we are at position 3 and want to move to position 7. However, we are not allowed to move to positions in banned, so we are not able to move at all.Note that at position 5, we could move to either position 6 or position 8. We choose to move to position 8 because that is the closest position we can move to that is not in banned.At position 6, we could move to either position 7 or position 9. We choose to move to position 7 because that is the closest position we can move to that is not in banned.At position 9, we could move to either position 10 or position 11. We choose to move to position 10 because that is the closest position we can move to that is not in banned.At position 11, we could move to either position 12 or position 13. We choose to move to position 12 because that is the closest position we can move to that is not in banned. At position 13, we could move to either position 14 or position 15. We choose to move to position 14 because that is the closest position we can move to that is not in banned.At position 15, we could move to either position 16 or position 17. We choose to move to position 16 because that is the closest position we can move to that is not in banned.At position 17, we could move to either position 18 or position 19. We choose to move to position 18 because that is the closest position we can move to that is not in banned. At position 19, we could move to either position 20 or position 21. We choose to move to position 20 because that is the closest position we can move to that is not in banned.At position 2", "groundtruth": "class Solution {public:vector<int> minReverseOperations(int n, int p, vector<int> &banned, int k) {unordered_set<int> ban{banned.begin(), banned.end()};set<int> sets[2];for (int i = 0; i < n; ++i)if (i != p && !ban.count(i))sets[i % 2].insert(i);sets[0].insert(n);sets[1].insert(n); // 哨兵vector<int> ans(n, -1);vector<int> q = {p};for (int step = 0; !q.empty(); ++step) {vector<int> nq;for (int i: q) {ans[i] = step;// 从 mn 到 mx 的所有位置都可以翻转到int mn = max(i - k + 1, k - i - 1);int mx = min(i + k - 1, n * 2 - k - i - 1);auto &s = sets[mn % 2];for (auto it = s.lower_bound(mn); *it <= mx; it = s.erase(it))nq.push_back(*it);}q = move(nq);}return ans;}};"}
{"task_id": "java/0", "content": "\nclass Solution {\n    public int findChampion(int n, int[][] edges) {\n        int[] degree = new int[n];\n        for (int[] e : edges) {\n            degree[e[1]]++;\n        }\n        int champion = -1;\n        for (int i = 0; i < n; i++) {\n            if (degree[i] == 0) {\n                if (champion == -1) {\n                    champion = i;\n                } else {\n                    return -1;\n                }\n            }\n        }\n        return champion;\n    }\n}\n", "groundtruth": "class Solution {    public int findChampion(int n, int[][] edges) {        int[] degree = new int[n];        for (int[] e : edges) {            degree[e[1]]++;        }        int champion = -1;        for (int i = 0; i < n; i++) {            if (degree[i] == 0) {                if (champion == -1) {                    champion = i;                } else {                    return -1;                }            }        }        return champion;    }}"}
{"task_id": "java/1", "content": "\n \n\nExample 1:\n\nInput: edges = [[0,1],[0,2],[1,3]], values = [10,2,9,1]\nOutput: 110\nExplanation: The tree is shown above.\nThe blue edges represent the maximum value of the score that can be obtained with the given operations.\nThe red edges represent the path from the root to the leaf nodes.\nThe score obtained by the path is 1 + 9 + 1 = 11.\nThe total maximum score is 1 + 11 + 11 + 1 = 110.\nExample 2:\n\nInput: edges = [[0,1],[1,2],[2,3],[1,4],[4,5]], values = [10,2,9,3,7]\nOutput: 138\nExplanation: The tree is shown above.\nThe blue edges represent the maximum value of the score that can be obtained with the given operations.\nThe red edges represent the path from the root to the leaf nodes.\nThe score obtained by the path is 1 + 2 + 9 + 7 = 19.\nThe total maximum score is 1 + 19 + 19 + 1 = 138.\n \n\nConstraints:\n\nn == values.length\n2 <= n <= 10^4\n1 <= edges.length <= 10^4\nedges[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\nGiven a tree of size n, where the root is at position 0, find the position of the leaf node that is farthest from the root.\n\n \n\nExample 1:\n\nInput: n = 4, edges = [[1,2],[1,3],[2,4],[2,5]]\nOutput: 5\nExplanation: The leaf node that is farthest from the root is node 5.\nExample 2:\n\nInput: n = 2, edges = [[1,2]]\nOutput: 2\nExplanation: The leaf node that is farthest from the root is node 2.\n \n\nConstraints:\n\n1 <= edges.length <= 10^5\n1 <=", "groundtruth": "class Solution {    public long maximumScoreAfterOperations(int[][] edges, int[] values) {        List<Integer>[] g = new ArrayList[values.length];        Arrays.setAll(g, e -> new ArrayList<>());        g[0].add(-1);         for (int[] e : edges) {            int x = e[0], y = e[1];            g[x].add(y);            g[y].add(x);        }        long ans = 0;        for (int v : values) {            ans += v;        }        return ans - dfs(0, -1, g, values);    }    private long dfs(int x, int fa, List<Integer>[] g, int[] values) {        if (g[x].size() == 1) {             return values[x];        }        long loss = 0;         for (int y : g[x]) {            if (y != fa) {                loss += dfs(y, x, g, values);             }        }        return Math.min(values[x], loss);     }}"}
{"task_id": "java/2", "content": "\n\nclass Solution {\n    public String triangleType(int[] nums) {\n        Arrays.sort(nums);\n        int x = nums[0];\n        int y = nums[1];\n        int z = nums[2];\n        if (x + y <= z) {\n            return \"none\";\n        }\n        if (x == z) {\n            return \"equilateral\";\n        }\n        if (y == z) {\n            return \"isosceles\";\n        }\n        return \"scalene\";\n    }\n}", "groundtruth": "class Solution {    public String triangleType(int[] nums) {        Arrays.sort(nums);        int x = nums[0];        int y = nums[1];        int z = nums[2];        if (x + y <= z) { // 排序后，只需比较 x+y 和 z            return 'none';        }        if (x == z) { // 排序了，说明 y 也和 x z 相等            return 'equilateral';        }        if (x == y || y == z) {            return 'isosceles';        }        return 'scalene';    }}"}
{"task_id": "java/3", "content": "\n\nclass Solution {\n    public int numberOfPairs(int[][] points) {\n        int pairs = 0;\n        Arrays.sort(points, (a, b) -> {\n            if (a[0] != b[0]) {\n                return a[0] - b[0];\n            } else {\n                return b[1] - a[1];\n            }\n        });\n        int n = points.length;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (isGood(points, i, j)) {\n                    pairs++;\n                }\n            }\n        }\n        return pairs;\n    }\n    public boolean isGood(int[][] points, int index1, int index2) {\n        int n = points.length;\n        for (int i = 0; i < n; i++) {\n            if (i == index1 || i == index2) {\n                continue;\n            }\n            if (points[i][0] >= points[index1][0] && points[i][0] <= points[index2][0] && points[i][1] >= points[index2][1] && points[i][1] <= points[index1][1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "groundtruth": "class Solution {    public int numberOfPairs(int[][] points) {        int pairs = 0;        Arrays.sort(points, (a, b) -> {            if (a[0] != b[0]) {                return a[0] - b[0];            } else {                return b[1] - a[1];            }        });        int n = points.length;        for (int i = 0; i < n; i++) {            for (int j = i + 1; j < n; j++) {                if (points[i][1] >= points[j][1] && isGood(points, i, j)) {                    pairs++;                }            }        }        return pairs;    }    public boolean isGood(int[][] points, int index1, int index2) {        int n = points.length;        for (int i = 0; i < n; i++) {            if (i == index1 || i == index2) {                continue;            }            if (points[i][0] >= points[index1][0] && points[i][0] <= points[index2][0] && points[i][1] >= points[index2][1] && points[i][1] <= points[index1][1]) {                return false;            }        }        return true;    }}"}
{"task_id": "java/4", "content": "\nNote: The return type of the function maximumSubarraySum is long, and the function should return the maximum sum of a good subarray of nums.\n\nInput Format\nThe first line contains an integer n, denoting the size of the array nums. The second line contains n space-separated integers nums[i], where 1 ≤ i ≤ n. The third line contains an integer k, denoting the value of k.\n\nConstraints\n1 ≤ n ≤ 10^5\n1 ≤ k ≤ 10^9\n1 ≤ nums[i] ≤ 10^9\n\nOutput Format\nOutput the maximum sum of a good subarray of nums.\n\nSample Input 0\n4\n3 4 2 6\n1\n\nSample Output 0\n6\n\nSample Input 1\n5\n2 1 -3 4 -1\n2\n\nSample Output 1\n4\n\nExplanation\nSample case 0:\n\nThe good subarray of nums is [3, 4, 2], and its sum is 6.\n\nSample case 1:\n\nThe good subarray of nums is [2, 1], and its sum is 3.\n\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {    public long maximumSubarraySum(int[] nums, int k) {        long ans = Long.MIN_VALUE;        long sum = 0;        Map<Integer, Long> minS = new HashMap<>();        for (int x : nums) {            long s1 = minS.getOrDefault(x - k, Long.MAX_VALUE / 2);            long s2 = minS.getOrDefault(x + k, Long.MAX_VALUE / 2);            ans = Math.max(ans, sum + x - Math.min(s1, s2));            minS.merge(x, sum, Math::min);            sum += x;        }        return ans > Long.MIN_VALUE / 4 ? ans : 0;    }}"}
{"task_id": "java/5", "content": "\nNote:\n1 <= s.length <= 10^5\ns[i] is either '0' or '1'.\nThe string may contain leading zeros.\n\nExample 1:\nInput: \"00111000\"\nOutput: 2\nExplanation: There are two substrings with dominant 1's: \"0011\" and \"11000\".\n\nExample 2:\nInput: \"11100000\"\nOutput: 1\nExplanation: There is only one substring with dominant 1's: \"111000\".\n\nExample 3:\nInput: \"11010010\"\nOutput: 2\nExplanation: There are two substrings with dominant 1's: \"1101\" and \"10010\".\n", "groundtruth": "class Solution {    public int numberOfSubstrings(String S) {        char[] s = S.toCharArray();        int n = s.length;        int m = 0;        int[] a = new int[n + 1];        for (int i = 0; i < n; i++) {            if (s[i] == '0') {                a[m++] = i;            }        }        int tot1 = n - m;        a[m] = n; // 哨兵        int ans = 0;        int i = 0; // >= left 的第一个 0 的下标是 a[i]        for (int left = 0; left < n; left++) {            if (s[left] == '1') {                ans += a[i] - left; // 不含 0 的子串个数            }            for (int k = i; k < m; k++) {                int cnt0 = k - i + 1;                if (cnt0 * cnt0 > tot1) {                    break;                }                int cnt1 = a[k] - left - (k - i);                ans += Math.max(a[k + 1] - a[k] - Math.max(cnt0 * cnt0 - cnt1, 0), 0);            }            if (s[left] == '0') {                i++; // 这个 0 后面不会再枚举到了            }        }        return ans;    }}"}
{"task_id": "java/6", "content": "\n\nThe input xCorner and yCorner are guaranteed to be positive integers.\nThe number of circles will not exceed 10000.\nThe input xCorner, yCorner, xi, yi, ri for all circles are all positive integers.\n\n\n \n\nInput\n[\"Solution\",\"canReachCorner\"]\n[[1,1,[[0,0,1]]],[1,1,[[1,1,1]]]]\n\n\n \n\nOutput\n[null,true]\n\n\n \n\nExplanation\nSolution solution = new Solution(1,1,[[0,0,1]]);\nsolution.canReachCorner(); // return true.\n\nSolution solution = new Solution(1,1,[[1,1,1]]);\nsolution.canReachCorner(); // return false.\n\n\n \n\nNote\nThe solution.canReachCorner() function will be called only once.\nThe input parameters of the function may be changed by the interviewer.\n\n \n\n \n\n\n\n\n\n\n \n\n \n\n \n\n \n\n \n\n\n \n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n ", "groundtruth": "class Solution {\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        boolean[] vis = new boolean[circles.length];\n        for (int i = 0; i < circles.length; i++) {\n            long x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            if (inCircle(x, y, r, 0, 0) || // 圆 i 包含矩形左下角\n                inCircle(x, y, r, X, Y) || // 圆 i 包含矩形右上角\n                // 圆 i 是否与矩形上边界/左边界相交相切\n                !vis[i] && (x <= X && Math.abs(y - Y) <= r ||\n                            y <= Y && x <= r ||\n                            y > Y && inCircle(x, y, r, 0, Y)) && dfs(i, X, Y, circles, vis)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n    private boolean inCircle(long ox, long oy, long r, long x, long y) {\n        return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r;\n    }\n\n    private boolean dfs(int i, int X, int Y, int[][] circles, boolean[] vis) {\n        long x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];\n        // 圆 i 是否与矩形右边界/下边界相交相切\n        if (y1 <= Y && Math.abs(x1 - X) <= r1 ||\n            x1 <= X && y1 <= r1 ||\n            x1 > X && inCircle(x1, y1, r1, X, 0)) {\n            return true;\n        }\n        vis[i] = true;\n        for (int j = 0; j < circles.length; j++) {\n            long x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];\n            // 在两圆相交相切的前提下，点 A 是否严格在矩形内\n            if (!vis[j] &&\n                (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) &&\n                x1 * r2 + x2 * r1 < (r1 + r2) * X &&\n                y1 * r2 + y2 * r1 < (r1 + r2) * Y &&\n                dfs(j, X, Y, circles, vis)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/7", "content": "\n \n\nInput: n = 2, m = 2\nOutput: 2\nExplanation: In the following 2 possible ways, Alice can capture the flowers:\n1. Pick the 1st flower from the clockwise direction.\n2. Pick the 1st flower from the anti-clockwise direction.\n\nInput: n = 2, m = 3\nOutput: 3\nExplanation: In the following 3 possible ways, Alice can capture the flowers:\n1. Pick the 1st flower from the clockwise direction.\n2. Pick the 1st flower from the anti-clockwise direction.\n3. Pick the 2nd flower from the clockwise direction.\n\nInput: n = 3, m = 3\nOutput: 4\nExplanation: In the following 4 possible ways, Alice can capture the flowers:\n1. Pick the 1st flower from the clockwise direction.\n2. Pick the 1st flower from the anti-clockwise direction.\n3. Pick the 2nd flower from the clockwise direction.\n4. Pick the 2nd flower from the anti-clockwise direction.\n\nInput: n = 1, m = 1\nOutput: 1\n\n \n\nConstraints:\n\n1 <= n <= 10^5\n1 <= m <= 10^5\n\n```\n\n\n## Solution\n\n### Approach 1: \n\n\n```python\nclass Solution:\n    def flowerGame(self, n: int, m: int) -> int:\n        return (n+1) * (m+1) - 1\n```\n\n\n---\n\n\n## Code\n```python\n\n```\n", "groundtruth": "class Solution {\n    public long flowerGame(int n, int m) {\n        long a = ((long)n/2) * ((long)m-((long)m/2));\n        long b = ((long)m/2) * ((long)n-((long)n/2));\n        return a + b;\n    }\n}\n"}
{"task_id": "java/8", "content": "", "groundtruth": "class Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; // 操作次数\n            int and = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++; // 合并 x，操作次数加一\n                } else {\n                    and = -1; // 准备合并下一段\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; // 答案的这个比特位必须是 1\n                mask ^= 1 << b; // 后面不考虑这个比特位\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/9", "content": "", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n        return result;\n    }\n}\n"}
{"task_id": "java/10", "content": "\nThe input is in the following format:\nThe first line contains one integer n (1 ≤ n ≤ 10000), which is the number of nodes in the graph. The second line contains n pairs of integers xi, yi (1 ≤ xi, yi ≤ n), which represent an edge between node xi and node yi.\nThe third line contains one integer m (1 ≤ m ≤ 5000), which is the number of queries. The following m lines each contain two integers a and b (1 ≤ a, b ≤ n), which represent a query.\n\nOutput:\nFor each query, print the number of pairs of edges that can be removed to make the graph biconnected on a single line.\n\nExample:\n\nInput\n\n5\n1 2\n2 3\n3 4\n4 5\n5\n1 5\n\nOutput\n\n3\n\n\n## 题目大意\n\n这题是一道有向图的题目，给出有 n 个点，有 m 个边的有向图，还有一个数组 queries ，每次询问给出两个点，问从 queries[i][0] 点出发到 queries[i][1] 点有多少条不同的简单路径，如果两个点之间没有边，那么输出 0 。\n\n## 解题思路\n\n这道题是一道最短路径的题目，可以用 SPFA 算法来解。首先用两个二维数组 dp 和 vis 分别存储点 i 和点 j 之间的距离和是否被访问。然后对每个 queries[i] 点，从点 i 出发 BFS 搜索到点 j 的距离，如果距离是 -1 就输出 0 ，如果距离是 -2 就输出 -1 ，否则就输出距离 + 1。\n\n## 代码\n\n```", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        \n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n\n        return result;\n    }\n}\n"}
{"task_id": "java/11", "content": "\nNote: The answer may be a function. Please provide the function's source code.\n\nExample 1:\n\nInput: nums = [3,1,2,4]\nOutput: true\nExplanation: [3,1,2,4] can be sorted in the following operations:\n1. Swap 3 and 4\n2. Swap 1 and 2\n\nExample 2:\n\nInput: nums = [3,1,2,4,5]\nOutput: false\nExplanation: [3,1,2,4,5] cannot be sorted in any number of operations.\n\nConstraints:\n\n1 <= nums.length <= 100\n1 <= nums[i] <= 100\n\n\n\nHint #1  \nHow many different number of set bits can there be in the array?\n\n\n\nHint #2  \nWhat if the number of set bits were the same for every element in the array?\n\n\n\nHint #3  \nIf the number of set bits were the same for every element in the array, then it would be possible to sort the array, since the number of set bits would determine the order of the elements.\n\n\n\nHint #4  \nHow can you use this observation to solve the problem?\n\n\n\nHint #5  \nYou can use the same approach as Hint #2 to determine the number of different number of set bits.\n\n\n\nHint #6  \nCan you use this number to determine the maximum number of swaps that are allowed?\n\n\n\nHint #7  \nIf there are k different number of set bits in the array, then there must be at least k different elements with the same number of set bits.\n\n\n\nHint #8  \nWhat if two elements have the same number of set bits?\n\n\n\nHint #9  \nHow can you ensure that the array can be sorted in one operation?\n\n\n\nHint #10  \nConsider the maximum number of swaps that are allowed and the number of different number of set bits in the array.\n\n\n\nHint #11  \nWhat if the maximum number of swaps is greater than the number of different number of set bits?\n\n\n\nHint #12  \nCan you solve the problem in O(n)", "groundtruth": "class Solution {\n    public boolean canSortArray(int[] nums) {\n        int lastCnt = 0;\n        int lastGroupMax = 0;\n        int curGroupMax = 0;\n        for (int num : nums) {\n            int curCnt = Integer.bitCount(num);\n            if (curCnt == lastCnt) {\n                curGroupMax = Math.max(curGroupMax, num);\n            } else {\n                lastCnt = curCnt;\n                lastGroupMax = curGroupMax;\n                curGroupMax = num;\n            }\n            if (num < lastGroupMax) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "java/12", "content": "\nExample 1:\nInput: nums = [5,1,2,3]\nOutput: 1\nExplanation: We can insert 5 % 1 = 0 at the end of nums to make nums = [1,2,3,0,5]. The length of nums is 5, so the minimum length of nums after performing the operation any number of times is 1.\n\nExample 2:\nInput: nums = [5,1,2,3,4]\nOutput: 1\nExplanation: We can insert 5 % 1 = 0 at the end of nums to make nums = [1,2,3,4,5,0]. The length of nums is 6, so the minimum length of nums after performing the operation any number of times is 1.\n\nExample 3:\nInput: nums = [3,1,1,1]\nOutput: 2\nExplanation: We can insert 3 % 1 = 0 at the end of nums to make nums = [1,1,1,0,3]. The length of nums is 5, so the minimum length of nums after performing the operation any number of times is 2.\n\nConstraints:\n1 <= nums.length <= 105\n1 <= nums[i] <= 105\nThe number of distinct elements in nums is at most 104.", "groundtruth": "class Solution {\n    public int minimumArrayLength(int[] nums) {\n        int m = Integer.MAX_VALUE;\n        for (int x : nums) {\n            m = Math.min(m, x);\n        }\n\n        for (int x : nums) {\n            if (x % m > 0) {\n                return 1;\n            }\n        }\n\n        int cnt = 0;\n        for (int x : nums) {\n            if (x == m) {\n                cnt++;\n            }\n        }\n        return (cnt + 1) / 2;\n    }\n}\n"}
{"task_id": "java/13", "content": "\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7,8,9,10], k = 3, dist = 2\nOutput: 18\nExplanation: One optimal solution is:\n- The cost of [1,2,3] is 1 + 2 + 3 = 6.\n- The cost of [4,5,6] is 4 + 5 + 6 = 15.\n- The cost of [7,8,9,10] is 7 + 8 + 9 + 10 = 30.\nThus the total cost is 6 + 15 + 30 = 41, which is the minimum possible.\nExample 2:\n\nInput: nums = [5,4,3,2,1], k = 2, dist = 1\nOutput: 9\nExplanation: It is optimal to choose the two subarrays [5,4] and [3,2,1].\nThe cost of these two subarrays is 5 + 4 + 3 + 2 + 1 = 15, which is the minimum possible.\nExample 3:\n\nInput: nums = [1,2,3], k = 1, dist = 0\nOutput: 1\nExplanation: Since k equals 1 and dist equals 0, it is optimal to choose the single subarray [1,2,3].\nThe cost of this subarray is 1 + 2 + 3 = 6, which is the minimum possible.\nExample 4:\n\nInput: nums = [1], k = 1, dist = 0\nOutput: 1\nExplanation: The only optimal solution is to choose the single subarray [1].\nThe cost of this subarray is 1, which is the minimum possible.\n \n\nConstraints:\n\nn == nums.length\n1 <= k <= n <= 105\n1 <= dist <= n - 1\n1 <= nums[i] <= 107\n \n\nFollow-up: Could you solve the problem in O(n log k) time?\n", "groundtruth": "class Solution {\n    public long minimumCost(int[] nums, int k, int dist) {\n        k--;\n        sumL = nums[0];\n        for (int i = 1; i < dist + 2; i++) {\n            sumL += nums[i];\n            L.merge(nums[i], 1, Integer::sum);\n        }\n        sizeL = dist + 1;\n        while (sizeL > k) {\n            l2r();\n        }\n\n        long ans = sumL;\n        for (int i = dist + 2; i < nums.length; i++) {\n            // 移除 out\n            int out = nums[i - dist - 1];\n            if (L.containsKey(out)) {\n                sumL -= out;\n                sizeL--;\n                removeOne(L, out);\n            } else {\n                removeOne(R, out);\n            }\n\n            // 添加 in\n            int in = nums[i];\n            if (in < L.lastKey()) {\n                sumL += in;\n                sizeL++;\n                L.merge(in, 1, Integer::sum);\n            } else {\n                R.merge(in, 1, Integer::sum);\n            }\n\n            // 维护大小\n            if (sizeL == k - 1) {\n                r2l();\n            } else if (sizeL == k + 1) {\n                l2r();\n            }\n\n            ans = Math.min(ans, sumL);\n        }\n        return ans;\n    }\n\n    private long sumL;\n    private int sizeL;\n    private final TreeMap<Integer, Integer> L = new TreeMap<>();\n    private final TreeMap<Integer, Integer> R = new TreeMap<>();\n\n    private void l2r() {\n        int x = L.lastKey();\n        removeOne(L, x);\n        sumL -= x;\n        sizeL--;\n        R.merge(x, 1, Integer::sum);\n    }\n\n    private void r2l() {\n        int x = R.firstKey();\n        removeOne(R, x);\n        sumL += x;\n        sizeL++;\n        L.merge(x, 1, Integer::sum);\n    }\n\n    private void removeOne(Map<Integer, Integer> m, int x) {\n        int cnt = m.get(x);\n        if (cnt > 1) {\n            m.put(x, cnt - 1);\n        } else {\n            m.remove(x);\n        }\n    }\n}\n"}
{"task_id": "java/14", "content": "\nThe description is given for your reference. Please read it carefully and try to solve the problem by yourself first.\n\n", "groundtruth": "class Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        char[] text = s.toCharArray();\n        List<Integer> posA = kmp(text, a.toCharArray());\n        List<Integer> posB = kmp(text, b.toCharArray());\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i : posA) {\n            int bi = lowerBound(posB, i);\n            if (bi < posB.size() && posB.get(bi) - i <= k ||\n                bi > 0 && i - posB.get(bi - 1) <= k) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n\n    private List<Integer> kmp(char[] text, char[] pattern) {\n        int m = pattern.length;\n        int[] pi = new int[m];\n        int c = 0;\n        for (int i = 1; i < m; i++) {\n            char v = pattern[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            pi[i] = c;\n        }\n\n        List<Integer> res = new ArrayList<>();\n        c = 0;\n        for (int i = 0; i < text.length; i++) {\n            char v = text[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            if (c == m) {\n                res.add(i - m + 1);\n                c = pi[c - 1];\n            }\n        }\n        return res;\n    }\n\n    // 开区间写法\n    private int lowerBound(List<Integer> nums, int target) {\n        int left = -1, right = nums.size(); // 开区间 (left, right)\n        while (left + 1 < right) { // 区间不为空\n            // 循环不变量：\n            // nums[left] < target\n            // nums[right] >= target\n            int mid = (left + right) >>> 1;\n            if (nums.get(mid) < target) {\n                left = mid; // 范围缩小到 (mid, right)\n            } else {\n                right = mid; // 范围缩小到 (left, mid)\n            }\n        }\n        return right;\n    }\n}\n"}
{"task_id": "java/15", "content": "\n", "groundtruth": "class Solution {\n    public long findMaximumNumber(long k, int x) {\n        this.x = x;\n        long left = 0;\n        long right = (k + 1) << x;\n        while (left + 1 < right) {\n            long mid = (left + right) >>> 1;\n            if (countDigitOne(mid) <= k) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    private int x;\n    private long num;\n    private long memo[][];\n\n    private long countDigitOne(long num) {\n        this.num = num;\n        int m = 64 - Long.numberOfLeadingZeros(num);\n        memo = new long[m][m + 1];\n        for (long[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return dfs(m - 1, 0, true);\n    }\n\n    private long dfs(int i, int cnt1, boolean isLimit) {\n        if (i < 0) return cnt1;\n        if (!isLimit && memo[i][cnt1] != -1) return memo[i][cnt1];\n        int up = isLimit ? (int) (num >> i & 1) : 1;\n        long res = 0;\n        for (int d = 0; d <= up; d++) {\n            res += dfs(i - 1, cnt1 + (d == 1 && (i + 1) % x == 0 ? 1 : 0), isLimit && d == up);\n        }\n        if (!isLimit) memo[i][cnt1] = res;\n        return res;\n    }\n}\n"}
{"task_id": "java/16", "content": "\n\n## Solution\n\n```\nclass Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}\n```\n\n## Explanation\n\nThe idea is to iterate all possible strings and check whether it is valid. We can use a mask to make sure the string has exactly `n` 1's. Then, for each possible string, we can check whether the string is valid by checking whether all substrings of length 2 contain at least one '1'.\n\nThe code is quite simple, but it is a bit tedious to write.\n\n* **worst-case time complexity:** O(2<sup>n</sup>)\n* **worst-case space complexity:** O(2<sup>n</sup>)\n\n## Submitted Solution\n\nThe implemented solution is [here](https://github.com/Jiezhi/myleetcode/blob/master/src/main/java/solutions/0718/solution.java).\n\n## Leetcode link\n\nhttps://leetcode.com/problems/max-number-of-k-sum-pairs/", "groundtruth": "class Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/17", "content": "\nThe input is as follows:\n[[\".Y\", \".Y\", \"Y\"], [\".Y\", \"Y\", \".Y\"], [\"Y\", \"Y\", \".Y\"]]\n\nThe output is as follows:\n1\n", "groundtruth": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] sum = new int[m + 1][n + 1][2];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1][0] = sum[i + 1][j][0] + sum[i][j + 1][0] - sum[i][j][0];\n                sum[i + 1][j + 1][1] = sum[i + 1][j][1] + sum[i][j + 1][1] - sum[i][j][1];\n                if (grid[i][j] != '.') {\n                    sum[i + 1][j + 1][grid[i][j] & 1]++;\n                }\n                if (sum[i + 1][j + 1][0] > 0 && sum[i + 1][j + 1][0] == sum[i + 1][j + 1][1]) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/18", "content": "\n\n\n", "groundtruth": "class Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n        char[] t = target.toCharArray();\n        int n = t.length;\n\n        final int MOD = 1_070_777_777;\n        final int BASE = (int) 8e8 + new Random().nextInt((int) 1e8);\n        int[] powBase = new int[n + 1];\n        int[] preHash = new int[n + 1];\n        powBase[0] = 1;\n        for (int i = 0; i < n; i++) {\n            powBase[i + 1] = (int) ((long) powBase[i] * BASE % MOD);\n            preHash[i + 1] = (int) (((long) preHash[i] * BASE + t[i]) % MOD);\n        }\n\n        Map<Integer, Map<Integer, Integer>> minCost = new TreeMap<>();\n        for (int i = 0; i < words.length; i++) {\n            long h = 0;\n            for (char b : words[i].toCharArray()) {\n                h = (h * BASE + b) % MOD;\n            }\n            minCost.computeIfAbsent(words[i].length(), k -> new HashMap<>())\n                   .merge((int) h, costs[i], Integer::min);\n        }\n\n        int[] f = new int[n + 1];\n        Arrays.fill(f, Integer.MAX_VALUE / 2);\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (Map.Entry<Integer, Map<Integer, Integer>> e : minCost.entrySet()) {\n                int len = e.getKey();\n                if (len > i) {\n                    break;\n                }\n                int subHash = (int) (((preHash[i] - (long) preHash[i - len] * powBase[len]) % MOD + MOD) % MOD);\n                f[i] = Math.min(f[i], f[i - len] + e.getValue().getOrDefault(subHash, Integer.MAX_VALUE / 2));\n            }\n        }\n        return f[n] == Integer.MAX_VALUE / 2 ? -1 : f[n];\n    }\n}\n"}
{"task_id": "java/19", "content": "\n \n\nExample 1:\n\n\nInput: nums = [3,2,3], head = [1,2,3,4,5,6]\nOutput: [1,4,5,6]\nExplanation:\n- nums contains 3, which is the value of the first node.\n- nums contains 2, which is the value of the second node.\n- nums contains 3, which is the value of the third node.\nSo the first three nodes are removed.\nThe answer is the linked list that contains the remaining nodes [1,4,5,6].\nExample 2:\n\n\nInput: nums = [1,2,3,4,5,6], head = [1,2,3,4,5,6]\nOutput: []\nExplanation: All the nodes are removed.\nExample 3:\n\nInput: nums = [], head = [1,2,3,4,5,6]\nOutput: [1,2,3,4,5,6]\nExplanation: Since nums is empty, no nodes are removed.\n \n\nConstraints:\n\nnums.length == n\n1 <= n <= 1000\n1 <= nums[i], the values of the nodes in the linked list <= 1000\n\n```\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node next;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _next) {\n        val = _val;\n        next = _next;\n    }\n};\n*/\nclass Solution {\n    public Node modifiedList(int[] nums, Node head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        Node dummy = new Node(0, head);\n        Node cur = dummy;\n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur", "groundtruth": "class Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur.next.next; // 删除\n            } else {\n                cur = cur.next; // 向后移动\n            }\n        }\n        return dummy.next;\n    }\n}\n"}
{"task_id": "java/20", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        int[][][][] dp = new int[m][n][m][n];\n        for (int i1 = 0; i1 < m; i1++) {\n            for (int j1 = 0; j1 < n; j1++) {\n                for (int i2 = 0; i2 < m; i2++) {\n                    Arrays.fill(dp[i1][j1][i2], Integer.MAX_VALUE);\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][i][j] = 0;\n            }\n        }\n        for (int rowCount = 1; rowCount <= m; rowCount++) {\n            for (int colCount = 1; colCount <= n; colCount++) {\n                for (int i1 = 0, i2 = rowCount - 1; i2 < m; i1++, i2++) {\n                    for (int j1 = 0, j2 = colCount - 1; j2 < n; j1++, j2++) {\n                        for (int midRow = i1; midRow < i2; midRow++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], horizontalCut[midRow] + dp[i1][j1][midRow][j2] + dp[midRow + 1][j1][i2][j2]);\n                        }\n                        for (int midCol = j1; midCol < j2; midCol++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], verticalCut[midCol] + dp[i1][j1][i2][midCol] + dp[i1][midCol + 1][i2][j2]);\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][0][m - 1][n - 1];\n    }\n}\n"}
{"task_id": "java/21", "content": "\n\nExample 1:\nInput: s = \"a\"\nOutput: false\nExplanation: Alice cannot make any moves, so Bob wins.\n\nExample 2:\nInput: s = \"aa\"\nOutput: true\nExplanation: Alice can make the first move, removing the second character 'a' from the string.\n\nExample 3:\nInput: s = \"aab\"\nOutput: false\nExplanation: Bob wins by making the second move, removing the second character 'b' from the string.\n\nConstraints:\n1 <= s.length <= 10^5\ns[i] is either 'a', 'e', 'i', 'o', or 'u'.\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\n    public boolean doesAliceWin(String s) {\n        for (char c : s.toCharArray()) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {\n    public boolean doesAliceWin(String s) {\n        for (char c : s.toCharArray()) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/22", "content": "\n\n\nAnswer:\n\nclass Solution {\n    public int maxOperations(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int cnt1 = 0;\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == '1') {\n                cnt1++;\n            } else if (i > 0 && s[i - 1] == '1') {\n                ans += cnt1;\n            }\n        }\n        return ans;\n    }\n}", "groundtruth": "class Solution {\n    public int maxOperations(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int cnt1 = 0;\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == '1') {\n                cnt1++;\n            } else if (i > 0 && s[i - 1] == '1') {\n                ans += cnt1;\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/23", "content": "\n## 解题思路\n\n- 给出 2 个整数数组，要求计算最小操作次数。操作次数的定义为：选取一个子数组，在这个子数组内所有元素 +1，或者 -1。\n- 这一题是简单的模拟题，读懂题目的意思就可以直接 AC 了。\n\n## 代码\n\n```go\n\npackage leetcode\n\nfunc minimumOperations(nums []int, target []int) int {\n\tif len(nums) == 0 {\n\t\treturn 0\n\t}\n\tans, s := 0, target[0]-nums[0]\n\tfor i := 1; i < len(nums); i++ {\n\t\tk := target[i] - target[i-1] - (nums[i] - nums[i-1])\n\t\tif k > 0 {\n\t\t\tans += int(s >= 0)\n\t\t} else {\n\t\t\tans -= int(s <= 0) + int(Min(k+s, 0))\n\t\t}\n\t\ts += int64(k)\n\t}\n\treturn ans\n}\n\n```\n\n\n----------------------------------------------\n<div style=\"display: flex;justify-content: space-between;align-items: center;\">\n<p><a href=\"https://books.halfrost.com/leetcode/ChapterFour/2100.Number-of-Small-Submatrices-with-All-Ones/\">⬅️上一页</a></p>\n<p><a href=\"https://books.halfrost.com/leetcode/ChapterFour/2102.Maximum-Depth-of-a-Maze/\">下一页➡️</a></p>\n</div>\n", "groundtruth": "class Solution {\n    public long minimumOperations(int[] nums, int[] target) {\n        long s = target[0] - nums[0];\n        long ans = Math.abs(s);\n        for (int i = 1; i < nums.length; i++) {\n            int k = (target[i] - target[i - 1]) - (nums[i] - nums[i - 1]);\n            if (k > 0) {\n                ans += s >= 0 ? k : Math.max(k + s, 0);\n            } else {\n                ans -= s <= 0 ? k : Math.min(k + s, 0);\n            }\n            s += k;\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/24", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {\n    private static final int MX = 31622;\n    private static final int[] PI = new int[MX + 1];\n\n    static {\n        for (int i = 2; i <= MX; i++) {\n            if (PI[i] == 0) { // i 是质数\n                PI[i] = PI[i - 1] + 1;\n                for (int j = i * i; j <= MX; j += i) {\n                    PI[j] = -1; // 标记 i 的倍数为合数\n                }\n            } else {\n                PI[i] = PI[i - 1];\n            }\n        }\n    }\n\n    public int nonSpecialCount(int l, int r) {\n        return r - l + 1 - (PI[(int) Math.sqrt(r)] - PI[(int) Math.sqrt(l - 1)]);\n    }\n}\n"}
{"task_id": "python/0", "content": "\n \n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: 3\nExplanation:\n- For value = 1, its adjacent sum is 2 (grid[0][0] = 1, grid[0][1] = 2)\n- For value = 2, its adjacent sum is 4 (grid[0][1] = 2, grid[1][1] = 4)\n- For value = 3, its adjacent sum is 6 (grid[1][2] = 6)\n- For value = 4, its adjacent sum is 5 (grid[1][0] = 4, grid[1][1] = 5)\n- For value = 5, its adjacent sum is 8 (grid[1][1] = 5, grid[1][2] = 8)\n- For value = 6, its adjacent sum is 9 (grid[1][2] = 6, grid[2][2] = 9)\n- For value = 7, its adjacent sum is 7 (grid[2][0] = 7)\n- For value = 8, its adjacent sum is 9 (grid[2][1] = 8, grid[2][2] = 9)\n- For value = 9, its adjacent sum is 8 (grid[2][2] = 9, grid[1][2] = 8)\nSo the answer for the value of 3 is 6.\n\n\nInput: grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]\nOutput: 10\nExplanation:\n- For value = 1, its adjacent sum is 2 (grid[0][0] = 1, grid[0][1] = 2)\n- For value = 2, its adjacent sum is 4 (grid[0][1] = 2, grid[1][1] = 4)\n- For value = 3, its adjacent sum is 6 (grid[1][2] = 6)\n- For value = 4, its adjacent sum is ", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n    "}
{"task_id": "python/1", "content": "\nInput Format\nThe first line contains a single integer n, the size of grid.\nThe next n lines each contain n space-separated integers describing grid[i].\nThe next line contains an integer value.\n\nConstraints\n0 <= n <= 1000\n0 <= grid[i][j] < n2\n0 <= value < n2\nAll elements in grid are distinct.\n\nOutput Format\nReturn the sum of elements which are adjacent neighbors of value, that is either to the top, left, right, or bottom of value in grid.\n\nSample Input 0\n3\n1 2 3\n4 5 6\n7 8 9\n1\n\nSample Output 0\n12\n\nExplanation 0\nThe 1st element adjacent to value 1 is 2, and the 2nd element adjacent to value 1 is 3.\nThe 1st element adjacent to value 2 is 1, and the 2nd element adjacent to value 2 is 3.\nThe 1st element adjacent to value 3 is 1, and the 2nd element adjacent to value 3 is 2.\nHence, the sum of adjacent neighbors is 1 + 2 + 1 + 2 + 1 + 2 = 12.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n "}
{"task_id": "python/2", "content": "\n", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/3", "content": "", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n  "}
{"task_id": "python/4", "content": "\n# 题目：1650. 运营商和旅客\n# 给你一个大小为 n 的数组 ranges 和一个整数 k ，其中 ranges[i] = [starti, endi] 表示第 i 个区间开始位置是 starti 而结束位置是 endi 。\n# 初始时，你位于位置 0 ，你想要到达位置 k 。你每次可以向左或者向右移动最多 1 个单位长度，你也可以跳过 任意 个单位长度（可以很多次）。\n# 请你返回到达位置 k 需要的最小操作次数。\n\n# 示例 1：\n# 输入：k = 7, ranges = [[1,3],[3,4],[5,6]]\n# 输出：2\n# 解释：可以通过 ranges[0][1] -> ranges[1][1] -> ranges[2][1] 抵达位置 k 。\n\n# 示例 2：\n# 输入：k = 1, ranges = [[1,3],[3,4],[5,6]]\n# 输出：0\n# 解释：你可以直接到达位置 k 。\n\n# 示例 3：\n# 输入：k = 10, ranges = [[1,3],[3,4],[5,6]]\n# 输出：3\n# 解释：可以通过 ranges[0][1] -> ranges[1][1] -> ranges[2][1] 抵达位置 k 。\n\n# 示例 4：\n# 输入：k = 15, ranges = [[1,3],[3,4],[5,6]]\n# 输出：4\n# 解释：可以通过 ranges[0][1] -> ranges[1][1] -> ranges[2][1] -> ranges[2][1] 抵达位置", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/5", "content": "\nInput:\nn = 3\nqueries = [[0,1],[1,2],[0,2]]\n\nOutput:\n[3,2,2]\n\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = []\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans.append(bfs(i))\n        return ans", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/6", "content": "\n# 非递归并查集\ndef find(x: int) -> int:\n    rt = x\n    while fa[rt] != rt:\n        rt = fa[rt]\n    while fa[x] != rt:\n        fa[x], x = fa[x], rt\n    return rt\n\nans = []\ncnt = n - 1  # 并查集连通块个数\nfor l, r in queries:\n    fr = find(r - 1)\n    i = find(l)\n    while i < r - 1:\n        cnt -= 1\n        fa[i] = fr\n        i = find(i + 1)\n    ans.append(cnt)\nreturn ans\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/7", "content": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1\n        for l, r in queries:\n            fr = find(l)\n            i = find(r - 1)\n            cnt -= 1\n            while i != fr:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/8", "content": "\n\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/9", "content": "\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [0] * (n + 1)\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i] += op\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i]\n            s += i * self.t[i]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n           ", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/10", "content": "", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/11", "content": "\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n               ", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/12", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": " class Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\n        double=0\n        for it in nums:\n            if it>=10: \n                double=double+it \n            else:\n                single=single+it  \n        \n        return single !=double\n "}
{"task_id": "python/13", "content": "\nThe following code is a completed version of the code.\n\n\nMX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = i\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n"}
{"task_id": "python/14", "content": "", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n "}
{"task_id": "python/15", "content": "\n\n\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += n - left\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b =='0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n "}
{"task_id": "python/16", "content": "\n", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/17", "content": "\nThe time limit for each test case is 0.2 seconds.\nThe time limit for the entire program is 3.0 seconds.\n\nPlease fill in the blank (_______) according to the description.\n\nNote:\n\nThe binary string s contains at most 50,000 characters.\n\n\nExample 1:\nInput: s = \"11110000111111\"\nOutput: 2\nExplanation: The substrings with dominant 1s are \"11110\" and \"111111\".\nExample 2:\nInput: s = \"111111111111111\"\nOutput: 15\n\n```\n\n## Solution\n\n[SourceCode](./solution.js)\n", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/18", "content": "The sample input and output is as follows:\nInput:\nX = 3, Y = 3, circles = [[1, 1, 2], [2, 2, 1]]\nOutput:\ntrue\nExplanation:\nThe figure shows the rectangle and two circles. There is a path from the bottom left corner to the top right corner such that the entire path lies inside the rectangle, does not touch or lie inside any circle, and touches the rectangle only at the two corners.\nNote:\nThe number of circles will be in the range [0, 50].\nThe coordinates of the center of each circle will be integers in the range [-2500, 2500].\nThe radius of each circle will be an integer in the range [1, 999].\nThe answer will be in the form of a boolean value, either true or false.\n\n", "groundtruth": " class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n    "}
{"task_id": "python/19", "content": "\n\n\nInput Format\n\nThe first line contains two integers xCorner and yCorner, separated by a single space.\nThe second line contains the number of circles, n.\nThe next n lines each contain three integers xi, yi, ri, separated by a single space.\n\nOutput Format\n\nIf there is a path from the bottom left corner to the top right corner such that the entire path lies inside the rectangle, does not touch or lie inside any circle, and touches the rectangle only at the two corners, print true on a single line. Otherwise, print false.\n\nConstraints\n\n1 ≤ xCorner, yCorner ≤ 10^4\n1 ≤ n ≤ 10^5\n0 ≤ xi, yi, ri ≤ 10^4\nThe sum of xCorner, yCorner, xi, yi, and ri does not exceed 10^6.\nThe number of solutions is less than 10^5.\n\n\n\nSample Input\n\n3 3\n3\n1 2 1\n1 1 1\n2 2 2\n\nSample Output\n\nfalse\n\nExplanation\n\nThe bottom left corner is (0,0), the top right corner is (3,3).\n\n\n\nSample Input\n\n3 3\n2\n1 2 1\n1 1 1\n\nSample Output\n\ntrue\n\nExplanation\n\nThe bottom left corner is (0,0), the top right corner is (3,3).\n\n\n\nSample Input\n\n3 3\n2\n1 2 1\n2 2 1\n\nSample Output\n\nfalse\n\nExplanation\n\nThe bottom left corner is (0,0), the top right corner is (3,3).\n\n\n\nSample Input\n\n3 3\n3\n1 2 1\n1 1 1\n1 1 1\n\nSample Output\n\nfalse\n\nExplanation\n\nThe bottom left corner is (0,0), the top right corner is (3,3).\n\n\n\nSample Input\n\n3 3\n3\n1 2 1\n1 1 1\n2 1 1\n\nSample Output\n\ntrue\n\nExplanation\n", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/20", "content": "\nNote:\n\nThe number of circles is at most 1000.\nThe coordinates of the circles are integers between 0 and 1000.\nThe coordinates of the corners of the rectangle are integers between 0 and 1000.\nThe radius of each circle is an integer between 1 and 1000.\n", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/21", "content": "\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] and not grid[j][i]:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n\n\n# 题意：给你一个2D数组grid, 数组里面的值代表两个队伍之间的战斗情况, 如果grid[i][j] = 1, 代表队伍i比队伍j强, 如果grid[i][j] = 0, 代表队伍j比队伍i强. 现在你需要找到一支队伍, 如果不存在比这支队伍更强的队伍, 那么这支队伍就是赢家.\n# 题解：这道题的解题思路很清晰, 只需要找到一支队伍, 使得这支队伍比所有其他的队伍强, 那么这支队伍就是赢家. 而我们需要找到的队伍必须是唯一的, 因此我们只需要从数组里面选出一个最小的数字作为这支队伍, 这样做的原因是, 因为数组是按照队伍的战斗情况填充的, 那么我们只需要选择一个最小的数字, 就能保�", "groundtruth": "\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] == 1 and grid[j][i] == 0:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n"}
{"task_id": "python/22", "content": "\nThe output format is as follows:\n\nComplete the findChampion function in the editor below. It should return an integer that represents the index of the champion team, or -1 if there is no champion.\n\nfindChampion has the following parameter(s):\n\nn: the number of teams in the tournament\nedges: a 2D integer array describing the DAG, where edges[i] = [ui, vi] indicates that there is a directed edge from team ui to team vi\nConstraints:\n\n1 <= n <= 5000\n0 <= edges.length <= 5000\nedges[i].length == 2\n0 <= ui, vi < n\nThere are no duplicate edges in the graph.\nNo team is stronger than or equal to every other team.\nSample Input\n\n2\n[[1,0]]\nSample Output\n\n0\nExplanation\n\nThere are two teams in the tournament, and no team is stronger than the other. Thus, team 0 will be the champion.\n\nSample Input\n\n4\n[[3,2],[0,3],[1,3],[3,0],[1,2],[2,0],[2,1]]\nSample Output\n\n-1\nExplanation\n\nThere are four teams in the tournament, and no team is the champion.\n\nNote:\n\nThe graph is represented as follows:\n\n0 -> 3\n1 -> 3\n2 -> 3\n3\nThe graph is represented as follows:\n\n0 -> 3\n1 -> 3\n2 -> 3\n3\nThe graph is represented as follows:\n\n0 -> 3\n1 -> 3\n2 -> 3\n3\nThe graph is represented as follows:\n\n0 -> 3\n1 -> 3\n2 -> 3\n3\n", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/23", "content": "\nThe given code will output the correct result, but it's too slow. Your task is to optimize it.\n\nThe running time of your optimized code should be less than or equal to 300 ms.\n\nNote: The input n is less than or equal to 5000, and m is less than or equal to 10000.\n\n", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/24", "content": "", "groundtruth": "\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/25", "content": "\n", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/26", "content": "\n", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/27", "content": "", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/28", "content": "", "groundtruth": "\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/29", "content": "\n \n\nExample 1:\n\nInput: nums1 = [1,2,3], nums2 = [4,5,6]\nOutput: 3\nExplanation: You can make sums of both arrays equal by changing 0 to 3 in nums1 and 0 to 4 in nums2. The sums of both arrays will be: [1, 2, 3] and [4, 5, 6]\nExample 2:\n\nInput: nums1 = [1,1,1,1,1], nums2 = [1,1,1,1,1]\nOutput: 5\nExample 3:\n\nInput: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,6]\nOutput: -1\nExplanation: You cannot make the sum of elements equal.\n\nConstraints:\n\n1 <= nums1.length, nums2.length <= 10^5\n1 <= nums1[i], nums2[i] <= 10^9\n \n\nHint #1  \nThe idea is to change the number of zeros to be equal.\n\nHint #2  \nIf the number of zeros in nums1 is greater than the number of zeros in nums2, then you have to change the number of zeros in nums1 to be equal to the number of zeros in nums2.\n\nHint #3  \nIf the number of zeros in nums2 is greater than the number of zeros in nums1, then you have to change the number of zeros in nums2 to be equal to the number of zeros in nums1.\n\nHint #4  \nIf the sum of the numbers in nums1 is less than the sum of the numbers in nums2, then you have to increase the number of zeros in nums1.\n\nHint #5  \nIf the sum of the numbers in nums2 is greater than the sum of the numbers in nums1, then you have to increase the number of zeros in nums2.\n\nHint #6  \nIf you have to increase the number of zeros in nums1, then you can only increase it if the sum of the numbers in nums1 is less than the sum of the numbers", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/30", "content": "\nInput: nums1 = [5,1], nums2 = [2,1,4]\nOutput: 7\nExplanation: Change nums1 to [1,4] and nums2 to [2,1,5]\n\nInput: nums1 = [1,1,1], nums2 = [1,1,1]\nOutput: 6\nExplanation: Change nums1 to [1,1,2] and nums2 to [1,2,1]\n\nInput: nums1 = [2,2,2], nums2 = [1,1,1]\nOutput: -1\nExplanation: It is impossible to make the sum of nums1 equal to the sum of nums2.\n\nInput: nums1 = [1,2,3], nums2 = [4,5,6]\nOutput: 3\nExplanation: Change nums1 to [1,2,4] and nums2 to [4,5,3].\n\nInput: nums1 = [1,1,1,1,1], nums2 = [1,1,1,1,1]\nOutput: 6\nExplanation: Change nums1 to [1,1,1,2,1] and nums2 to [1,1,1,1,2].\n\nInput: nums1 = [2,2,2,2,2], nums2 = [2,2,2,2,2]\nOutput: 4\nExplanation: Change nums1 to [2,2,2,3,2] and nums2 to [2,2,2,2,3].\n", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/31", "content": "\nNote:\n\n1 <= nums.length <= 105\n1 <= nums[i], k <= 105\n\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = dp2, dp3, max(dp3, dp2) + num\n        return min(dp1, dp2, dp3)\n\n\n\n", "groundtruth": "\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/32", "content": "\n# Testcase 1:\nedges = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 5], [3, 6], [5, 7], [5, 8], [7, 9], [7, 10], [9, 11], [9, 12]]\ncoins = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nk = 3\nans = 560\nExpected Output:\n560\n\n# Testcase 2:\nedges = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 5], [3, 6], [5, 7], [5, 8], [7, 9], [7, 10], [9, 11], [9, 12]]\ncoins = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nk = 5\nans = 720\nExpected Output:\n720\n\n# Testcase 3:\nedges = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 5], [3, 6], [5, 7], [5, 8], [7, 9], [7, 10], [9, 11], [9, 12]]\ncoins = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\nk = 1\nans = 1440\nExpected Output:\n1440\n", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/33", "content": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = ____\n            res2 = ____\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i)  \n                    if j < 13:  \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n\n", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/34", "content": "", "groundtruth": " class Solution:     def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:         g = [[] for _ in coins]         for x, y in edges:             g[x].append(y)             g[y].append(x)         @cache         def dfs(i: int, j: int, fa: int) -> int:             res1 = (coins[i] >> j) - k             res2 = coins[i] >> (j + 1)             for ch in g[i]:                 if ch != fa:                     res1 += dfs(ch, j, i)                      if j < 13:                          res2 += dfs(ch, j + 1, i)              return max(res1, res2)         return dfs(0, 0, -1) "}
{"task_id": "python/35", "content": "\n\nNote: The input/output format and example 1 are the same as those of the LeetCode problem 1423, but the constraints are different.\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5]\nOutput: 39916800\nExplanation: The answer should be the sum of the squares of distinct counts of all subarrays of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.\nPlease read the description carefully.\nExample 2:\n\nInput: nums = [1,2,3,4,5,6]\nOutput: 431689600\nExplanation: The answer should be the sum of the squares of distinct counts of all subarrays of nums.\nExample 3:\n\nInput: nums = [1,2,3,4,5,6,7]\nOutput: 7465753600\nExplanation: The answer should be the sum of the squares of distinct counts of all subarrays of nums.\n \n\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 100\n\n \n\nHint #1  \nThis problem can be solved by using segment trees.\n\n'''\n\n\nclass Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/36", "content": "\n \n\nExample 1:\n\nInput: nums = [1,2,2,3,1]\nOutput: 4\nExplanation:\nThe subarrays are marked in bold:\n[1] = 1\n[1,2] = 2\n[1,2,2] = 2\n[1,2,2,3] = 3\n[1,2,2,3,1] = 4\nExample 2:\n\nInput: nums = [1,2,2,3,1,4]\nOutput: 7\nExplanation:\nThe subarrays are marked in bold:\n[1] = 1\n[1,2] = 2\n[1,2,2] = 2\n[1,2,2,3] = 3\n[1,2,2,3,1] = 4\n[1,2,2,3,1,4] = 4\n[1,2,2,3,1,4,4] = 5\nExample 3:\n\nInput: nums = [1,2,2,3,1,4,4,4,4]\nOutput: 10\nExplanation:\nThe subarrays are marked in bold:\n[1] = 1\n[1,2] = 2\n[1,2,2] = 2\n[1,2,2,3] = 3\n[1,2,2,3,1] = 4\n[1,2,2,3,1,4] = 4\n[1,2,2,3,1,4,4] = 5\n[1,2,2,3,1,4,4,4] = 6\n[1,2,2,3,1,4,4,4,4] = 7\n[1,2,2,3,1,4,4,4,4,4] = 8\n[1,2,2,3,1,4,4,4,4,4,4] = 9\n[1,2,2,3,1,4,4,4,4,4,4,4] = 10\n\n \n\nConstraints", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/37", "content": "\n```python\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += i - j\n            ans += s\n            last[x] = i\n        return ans\n```\n", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/38", "content": "\n\n\nExample 1:\nInput: s = \"111000\"\nOutput: 1\nExplanation: Change s[0] to '0'.\n\nExample 2:\nInput: s = \"000000\"\nOutput: 0\nExplanation: s is already beautiful.\n\nExample 3:\nInput: s = \"111111\"\nOutput: 1\nExplanation: Change s[0] to '0'.\n\nConstraints:\n\n2 <= s.length <= 1000\ns[i] is either '0' or '1'.\ns.length is even.\n", "groundtruth": " class Solution:     def minChanges(self, s: str) -> int:         cnt = 0         for i in range(0, len(s), 2):             if len(set(s[i:i + 2])) > 1:                 cnt += 1                 print(s)         return cnt "}
{"task_id": "python/39", "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": " class Solution:     def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:         f = [0] + [-inf] * target         s = 0         for x in nums:             s = min(s + x, target)             for j in range(s, x - 1, -1):                 # f[j] = max(f[j], f[j - x] + 1)                 if f[j] < f[j - x] + 1:                     f[j] = f[j - x] + 1         return f[-1] if f[-1] > 0 else -1 "}
{"task_id": "python/40", "content": "\n\nInput Format\n\nThe first line contains integers m, n, k, and l, respectively denoting the dimensions of the field, the number of horizontal fences, and the number of vertical fences.\nThe second line contains k integers hFences[i] (1 <= i <= k <= m - 1) where each hFences[i] denotes the position of a horizontal fence at the coordinate (hFences[i], 1).\nThe third line contains l integers vFences[i] (1 <= i <= l <= n - 1) where each vFences[i] denotes the position of a vertical fence at the coordinate (1, vFences[i]).\n \n\nConstraints\n\n1 <= m, n <= 10^5\n1 <= k <= m - 1\n1 <= l <= n - 1\n1 <= hFences[i] <= m - 1\n1 <= vFences[i] <= n - 1\nThe given fences do not intersect.\n \n\nOutput Format\n\nOutput a single integer denoting the maximum area of a square field that can be formed by removing some fences (possibly none) or -1 if it is impossible to make a square field.\n \n\nSample Input 0\n\n4 3 1 1\n1\n2\n3\n1\n1\n \n\nSample Output 0\n\n9\n \n\nExplanation 0\n\nThe field is surrounded by two horizontal fences from the coordinates (1, 1) to (1, 3) and (4, 1) to (4, 3) and two vertical fences from the coordinates (1, 1) to (4, 1) and (1, 3) to (4, 3). The area of the maximum square field is 3 × 3 = 9.\n\nSample Input 1\n\n3 2 1 2\n1\n2\n1\n2\n \n\nSample Output 1\n\n4\n \n\nExplanation 1\n\nThe field is surrounded by two horizontal fences from the coordinates (1, 1) to (1, 2) and (3, 1) to (3, 2) and two vertical fences from the coordinates (1, 1) to", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/41", "content": "\nNote: The field is surrounded by two horizontal fences from the coordinates (1, 1) to (1, n) and (m, 1) to (m, n) and two vertical fences from the coordinates (1, 1) to (m, 1) and (1, n) to (m, n). These fences cannot be removed.", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/42", "content": "The sample input is as follows:\n\n source = \"aba\"\n target = \"caa\"\n original = [\"a\", \"b\", \"c\"]\n changed = [\"c\", \"a\", \"a\"]\n cost = [3, 2, 1]\n\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/43", "content": "\n\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/44", "content": "\n\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)         for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/45", "content": "\nExample 1:\nInput: source = \"1203\", target = \"1212\", original = [\"1211\",\"0121\",\"1201\"], changed = [\"1112\",\"1212\",\"1201\"], cost = [1,2,3]\nOutput: 4\nExplanation: One optimal way to convert source to target is:\n1. Apply the first operation on index 1: \"1203\" -> \"1112\"\n2. Apply the second operation on index 0: \"1112\" -> \"1212\"\nIt can be shown that there is no better way to convert source to target, so we return 4.\n\nExample 2:\nInput: source = \"1221\", target = \"1201\", original = [\"1211\",\"0112\",\"1122\"], changed = [\"1112\",\"1212\",\"1201\"], cost = [1,2,3]\nOutput: -1\nExplanation: It can be shown that it is impossible to convert source to target.\n\nConstraints:\n\nsource.length == target.length == n\noriginal.length == changed.length == n\n1 <= n <= 1000\nn is even.\nsource, target, original[i], changed[i] consist of digits from '0' to '9'.\noriginal[i] != changed[i]\ncost.length == n\n1 <= cost[i] <= 1000\n\nHint #1  \nThis is a variant of the shortest path problem, which can be solved by dynamic programming.\n\nHint #2  \nThe graph of the problem has a lot of edges. We can use a data structure to reduce the number of edges.\n\nHint #3  \nWe can use a data structure to reduce the number of edges. For each substring of the string, we can keep track of the minimum cost to convert it to another substring.\n\nHint #4  \nFor each substring of the string, we can keep track of the minimum cost to convert it to another substring. We can use a 2D array or a 2D map to do so.\n\nHint #5  \nFor each substring of the string, we", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                      continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/46", "content": "\nNote: You are not allowed to change the function signature.\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)\n            len_to_strs[len(y)].add(y)\n            dis[x][y] = c\n            dis[x][x] = 0\n            dis[y][y] = 0\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:\n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1)\n            for size, strs in len_to_strs.items():\n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:\n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/47", "content": "\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/48", "content": "\nConstraints:\n\nn == grid.length\nn == grid[i].length\n1 <= n <= 1000\n0 <= grid[i][j] < n2\nAll the values in grid are unique.\nAll the values in grid are in the range [0, n2 - 1].\nEach value in grid appears exactly once in its row and once in its column.\nAt most 104 calls will be made to adjacentSum and diagonalSum.\n\nOutput:\n\nThe output is handled by the code.\n\nExample 1:\n\nInput: grid = [[0,1],[2,3]]\nOutput: [null,1,2,3]\nExplanation:\nNeighborSum neighborSum = new NeighborSum([[0,1],[2,3]]);\nneighborSum.adjacentSum(0); // return 1. Sum of 1 adjacent elements = 1.\nneighborSum.adjacentSum(1); // return 2. Sum of 1 adjacent elements = 2.\nneighborSum.adjacentSum(2); // return 3. Sum of 1 adjacent elements = 3.\nneighborSum.adjacentSum(3); // return 3. Sum of 1 adjacent elements = 3.\nneighborSum.diagonalSum(0); // return 2. Sum of 1 diagonal elements = 2.\nneighborSum.diagonalSum(1); // return 1. Sum of 1 diagonal elements = 1.\nneighborSum.diagonalSum(2); // return 2. Sum of 1 diagonal elements = 2.\nneighborSum.diagonalSum(3); // return 1. Sum of 1 diagonal elements = 1.\nExample 2:\n\nInput: grid = [[1,1,1,2,3,4,5,7],[2,2,2,4,5,7,8,9],[3,3,3,5,6,8,9,10],[4,4,4,6,8,10,11,12],[5,5,5,7,9,11,13,14],[6,6,6,8,10,12,", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/49", "content": "\n \n\nExample 1:\n\nInput\n[\"NeighborSum\", \"adjacentSum\", \"adjacentSum\", \"adjacentSum\", \"diagonalSum\", \"diagonalSum\", \"adjacentSum\"]\n[[[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]], [1], [2], [3], [1], [2], [3]]\nOutput\n[null, 0, 0, 0, 0, 0, 0]\nExplanation\nNeighborSum neighborSum = new NeighborSum([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]);\nneighborSum.adjacentSum(1); // return 0;\nneighborSum.adjacentSum(2); // return 0;\nneighborSum.adjacentSum(3); // return 0;\nneighborSum.diagonalSum(1); // return 0;\nneighborSum.diagonalSum(2); // return 0;\nneighborSum.adjacentSum(3); // return 0;\n \n\nConstraints:\n\nn == grid.length == grid[i].length\n1 <= n <= 1000\n0 <= grid[i][j] < n2\n0 <= value < n2\nEach value in the grid occurs exactly once.\nAt most 1000 calls in total will be made to adjacentSum and diagonalSum.\n", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/50", "content": "\nThe input format is as follows:\nThe first line contains two space-separated integers n and m, the number of cities and the number of queries, respectively.\nThe second line contains n - 1 space-separated integers a1, a2, ..., a(n - 1), where ai is the next city number from city i.\nThe third line contains m space-separated integers q1, q2, ..., qm, where qi is the length of the new road from city ui to city vi.\n\nThe output format is as follows:\nPrint m space-separated integers, where the i-th integer is the length of the shortest path from city 0 to city n - 1 after processing the first i + 1 queries.\n\nNote: You may want to use the BFS algorithm. The BFS algorithm is as follows:\n1. Initialize a queue with the starting node.\n2. Loop while the queue is not empty:\n    - Pop the first node from the queue.\n    - If the node has not been visited before, mark it as visited and enqueue all its neighbors that have not been visited.\n3. Return the shortest distance between the starting node and all the nodes in the graph.\n\nInput\n1 1\n1\n2\n\nOutput\n1\n\nInput\n2 2\n1 2\n1 1\n\nOutput\n1 2\n\nInput\n4 3\n1 2\n1 3\n2 4\n\nOutput\n1 2 3\n\nInput\n3 2\n1 2\n1 3\n\nOutput\n1 2 3\n\nInput\n4 2\n1 2\n3 4\n\nOutput\n1 2 3 4\n\nInput\n5 5\n1 2\n1 3\n2 4\n3 5\n2 4\n\nOutput\n1 2 3 4 5\n\nInput\n5 2\n1 2\n2 4\n\nOutput\n1 2 3 4 5\n\nInput\n5 3\n1 2\n1 3\n2 4\n3 5\n1 4\n\nOutput\n1 2 3 4 5\n\nInput\n5 3\n1 2\n1 3\n2 ", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/51", "content": "\nThe returned array must be in the same format as the example answer.\n\nConstraints:\n\n1 <= n <= 10^5\n1 <= queries.length <= 10^5\nqueries[i].length == 2\n0 <= ui, vi <= n - 1\nui != vi\nThere are no two queries such that queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1].\n\n\n```python\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n))\n        def find(x):\n            if x != fa[x]:\n                fa[x] = find(fa[x])\n            return fa[x]\n\n        def union(u, v):\n            fu, fv = find(u), find(v)\n            if fu != fv:\n                fa[fu] = fv\n\n        ans = []\n        for [u, v] in queries:\n            union(u, v)\n            ans.append(len(set(find(x) for x in range(n))))\n        return ans\n```\n\n", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/52", "content": "", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/53", "content": "", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/54", "content": "", "groundtruth": "\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\ndouble=0\nfor it in nums:\nif it>=10: \ndouble=double+it \nelse:\nsingle=single+it  \n        \nreturn single !=double\n "}
{"task_id": "python/55", "content": "\n", "groundtruth": "\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/56", "content": "\nNote: You can use the Python math library’s sqrt() function to compute square roots.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/57", "content": "\nExample 1:\n\nInput: xCorner = 5, yCorner = 4, circles = [[0,0,2],[4,0,1],[2,2,3]]\nOutput: false\nExplanation: The path 0,0 -> 4,0 -> 2,2 -> 4,0 is not inside the rectangle.\nExample 2:\n\nInput: xCorner = 1, yCorner = 1, circles = [[0,0,1]]\nOutput: true\nExample 3:\n\nInput: xCorner = 1, yCorner = 1, circles = [[1,1,2]]\nOutput: false\n\n \n\nConstraints:\n\n1 <= xCorner, yCorner <= 100\n1 <= circles.length <= 104\ncircles[i].length == 3\n0 <= xi, yi <= 100\n1 <= ri <= 100\nThere are no two circles that have a common point inside the rectangle.\n\n'''\n\n\nclass Solution:\n    def canReachCorner(self, xCorner, yCorner, circles):\n        vis = [False] * len(circles)\n        def dfs(i):\n            vis[i] = True\n            for j in range(len(circles)):\n                if not vis[j] and in_circle(circles[j][0], circles[j][1], circles[j][2], circles[i][0], circles[i][1]):\n                    if dfs(j):\n                        return True\n            if in_circle(xCorner, yCorner, 0, circles[i][0], circles[i][1]):\n                return True\n            return False\n        def in_circle(ox, oy, r, x, y):\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n        return dfs(0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/58", "content": "\nThe output format is as follows:\nReturn the integer that will be the champion of the tournament if there is a unique champion, otherwise, return -1.\n\nNote:\n\n1 <= n <= 500\n0 <= edges.length <= 1250\nedges[i].length == 2\n0 <= ui, vi <= n - 1\nui != vi\nThere are no duplicate edges in the input.\n\n \n\nExample 1:\n\nInput: n = 8, edges = [[0,1],[1,2],[2,3],[4,5],[5,6],[6,7]]\nOutput: 4\nExplanation: The tournament is shown below:\n  0           1\n   \\          /\n    2 - - - - 3\n   /          \\\n  4 - - - - - 5\n   \\          /\n    6 - - - - 7\nThe champion is team 4 because there is no team that can defeat them.\n\nExample 2:\n\nInput: n = 8, edges = [[0,1],[1,2],[2,3],[4,5],[5,6],[6,7],[0,4]]\nOutput: -1\nExplanation: There are 2 teams, team 0 and team 4, that can win the tournament.\n\nExample 3:\n\nInput: n = 2, edges = [[1,0]]\nOutput: 0\nExplanation: Team 0 will win the tournament because there is no team that can defeat them.\n\nExample 4:\n\nInput: n = 8, edges = [[0,1],[1,2],[2,3],[4,5],[5,6],[6,7],[0,4],[4,1],[1,5],[5,2],[2,6],[6,3]]\nOutput: 0\nExplanation: The tournament is shown below:\n  0           1\n   \\          /\n    2 - - - - 3\n   /          \\\n  4 - - - - - 5\n   \\          /\n    6 - - - - 7\nTeam 0 is the champion because there is no team that can defeat them.\n\n \n\nConstraints:\n\n1 <= n <= 500\n0 <=", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/59", "content": "\n# The code of the program is as follows:\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            u, v = edge\n            graph[u].append(v)\n        visited = [False] * n\n        self.dfs(graph, 0, visited)\n        for i in range(n):\n            if not visited[i]:\n                return -1\n        return 0\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        visited[start] = True\n        for v in graph[start]:\n            if not visited[v]:\n                self.dfs(graph, v, visited)\n\n# test case 1:\nn = 8\nedges = [[0, 1], [1, 2], [2, 3], [2, 4], [3, 5], [4, 5]]\nprint(Solution().findChampion(n, edges))\n# output 0\n\n# test case 2:\nn = 4\nedges = [[0, 1], [1, 2], [2, 3]]\nprint(Solution().findChampion(n, edges))\n# output -1\n\n# test case 3:\nn = 7\nedges = [[0, 1], [1, 2], [2, 3], [2, 4], [4, 5], [5, 6]]\nprint(Solution().findChampion(n, edges))\n# output 0\n", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/60", "content": "\n\n\n\n#include <bits/stdc++.h>\nusing namespace std;\nclass Solution {\npublic:\n    int maximumScoreAfterOperations(vector<vector<int>>& edges, vector<int>& values) {\n        int n = values.size();\n        vector<vector<int>> path(n);\n        for (auto &edge : edges) {\n            int u = edge[0], v = edge[1];\n            path[u].push_back(v);\n            path[v].push_back(u);\n        }\n\n        int ans = 0;\n        function<void(int, int)> dfs = [&](int u, int p) {\n            int sum = 0;\n            for (int v : path[u]) {\n                if (v == p) continue;\n                dfs(v, u);\n                sum += (ans + values[v]);\n            }\n            ans += values[u];\n            if (sum != 0) ans = -ans;\n        };\n        dfs(0, -1);\n        return ans;\n    }\n};\n\n\n\n\n\n", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/61", "content": "The code is in Python.", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/62", "content": "\nExample 1:\nInput: nums = [1,-2,10,-20,100]\nOutput: 100\nExplanation: The balanced subsequence is [100].\n\nExample 2:\nInput: nums = [-2,-1,2,1]\nOutput: 2\nExplanation: The balanced subsequence is [-1,2].\n\nExample 3:\nInput: nums = [-1000,1000]\nOutput: 1000\nExplanation: The balanced subsequence is [1000].\n\nConstraints:\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n\n", "groundtruth": "class Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/63", "content": "\nConstraints:\n1 <= nums.length <= 105\n1 <= k <= nums.length\n1 <= nums[i] <= 105", "groundtruth": "class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/64", "content": "\n\n\nAnswer:\n\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n        if abs(sum1 - sum2) % 2 == 1:\n            return -1\n        half = (sum1 - sum2) // 2\n        nums1_count = 0\n        nums2_count = 0\n        for i in range(len(nums1)):\n            if nums1[i] == 0:\n                nums1[i] = half // zero1\n                nums1_count += 1\n        for i in range(len(nums2)):\n            if nums2[i] == 0:\n                nums2[i] = half // zero2\n                nums2_count += 1\n        return sum(nums1) - half + sum(nums2)\n", "groundtruth": "class Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n\n"}
{"task_id": "python/65", "content": "The code should be in Python and have no extra space.\n", "groundtruth": "class Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/66", "content": "\nExample 1:\nInput: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], coins = [1,1,1,1,1,1], k = 3\nOutput: 8\nExplanation: The optimal way to collect coins is to collect coin 1 in the root node and coins 2 and 3 in the node with label 1.\n\nExample 2:\nInput: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], coins = [0,1,0,0,0,0], k = 3\nOutput: 4\nExplanation: The optimal way to collect coins is to collect coin 1 in the root node and coin 2 in the node with label 1.\n\nExample 3:\nInput: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], coins = [0,0,1,1,0,0], k = 3\nOutput: 5\nExplanation: The optimal way to collect coins is to collect coin 1 in the root node and coin 3 in the node with label 2.\n\nExample 4:\nInput: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], coins = [1,1,1,1,1,1], k = 0\nOutput: 6\nExplanation: The optimal way to collect coins is to collect coins 0, 1, 2 and 3.\n \nConstraints:\n\nn == coins.length\n2 <= n <= 10^5\nedges.length == n - 1\nedges[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\n0 <= coins[i] <= 10^4\n0 <= k <= 10^4\n\n\nSolution:\n\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins", "groundtruth": "class Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/67", "content": "\n", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/68", "content": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            return query(o * 2, l, (l + r) // 2, L, R) + query(o * 2 + 1, (l + r) // 2 + 1, r, L, R)\n\n        def query(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                return sum[o]\n            ____\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def add(o: int, l: int, r: int, L: int, R: int, v: int) -> int:\n            ____\n\n        def update(o: int, l: int, r: int, v: int) -> None:\n            if o < n:\n                ____\n            else:\n                ____\n\n        ____\n\n        ____\n\n        ____\n\n        ____\n\n        return ____\n", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/69", "content": "\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        n = len(s)\n        if n % 2 == 1:\n            return -1\n        ____\n        return ans\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        cnt = 0\n        for i in range(0, len(s), 2):\n            if len(set(s[i:i + 2])) > 1:\n                cnt += 1\n                \n        print(s)\n        return cnt\n"}
{"task_id": "python/70", "content": "\nExample 1:\n\nInput: nums = [5,3,7,2,1,4,6,9,10,8], target = 14\nOutput: 6\nExplanation: \nThe longest subsequence that sums up to target is [3,4,7].\n\nExample 2:\n\nInput: nums = [1,2,3,4,5,6,7,8,9,10], target = 15\nOutput: 6\nExplanation: \nThe longest subsequence that sums up to target is [4,5,6].\n\nExample 3:\n\nInput: nums = [1,2,3,4,5,6,7,8,9,10], target = 100\nOutput: -1\nExplanation: \nThere is no subsequence that sums up to target.\n\nExample 4:\n\nInput: nums = [1,2,3,4,5,6,7,8,9,10], target = 20\nOutput: -1\n\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 1000\n1 <= target <= 1000\n\n", "groundtruth": "\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        f = [0] + [-inf] * target\n        s = 0\n        for x in nums:\n            s = min(s + x, target)\n            for j in range(s, x - 1, -1):\n                # f[j] = max(f[j], f[j - x] + 1)\n                if f[j] < f[j - x] + 1:\n                    f[j] = f[j - x] + 1\n        return f[-1] if f[-1] > 0 else -1\n"}
{"task_id": "python/71", "content": "\nThe code should be written in the Python programming language and use OOP.\n\nPlease, check the code that you have written and make sure that it is working properly. Also, please, try to optimize your code if you can, because we will use it in some other problems as well.\n\nIf you are not familiar with the Python programming language, then you can check some additional information on the following link:\nhttps://docs.python.org/3/tutorial/index.html\n\nAlso, you can check the following video course on Python programming language:\nhttps://www.coursera.org/learn/python\n\nThe time limit for this problem is 1 second.\n\n", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/72", "content": "\n\n\n", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/73", "content": "\n#Test case 1:\nsource = \"abb\"\ntarget = \"bab\"\noriginal = [\"b\",\"a\",\"b\"]\nchanged = [\"a\",\"b\",\"b\"]\ncost = [1,2,3]\nanswer = 2\n\n#Test case 2:\nsource = \"aab\"\ntarget = \"bba\"\noriginal = [\"a\",\"a\",\"b\"]\nchanged = [\"b\",\"b\",\"a\"]\ncost = [1,2,3]\nanswer = -1\n\n#Test case 3:\nsource = \"abb\"\ntarget = \"bab\"\noriginal = [\"a\",\"b\",\"b\"]\nchanged = [\"b\",\"a\",\"b\"]\ncost = [1,2,3]\nanswer = 3\n\n#Test case 4:\nsource = \"aab\"\ntarget = \"bba\"\noriginal = [\"a\",\"a\",\"b\"]\nchanged = [\"b\",\"b\",\"a\"]\ncost = [1,2,3]\nanswer = -1\n\n#Test case 5:\nsource = \"aabb\"\ntarget = \"bbaa\"\noriginal = [\"a\",\"a\",\"b\",\"b\"]\nchanged = [\"b\",\"b\",\"a\",\"a\"]\ncost = [1,2,3,4]\nanswer = 4\n\n#Test case 6:\nsource = \"abb\"\ntarget = \"bba\"\noriginal = [\"a\",\"b\",\"b\"]\nchanged = [\"b\",\"b\",\"a\"]\ncost = [1,2,3]\nanswer = 3\n\n#Test case 7:\nsource = \"aab\"\ntarget = \"bba\"\noriginal = [\"a\",\"a\",\"b\"]\nchanged = [\"b\",\"b\",\"a\"]\ncost = [1,2,3]\nanswer = -1\n\n#Test case 8:\nsource = \"aabb\"\ntarget = \"bbaa\"\noriginal = [\"a\",\"a\",\"b\",\"b\"]\nchanged = [\"b\",\"b\",\"a\",\"a\"]\ncost = [1,2,3,4]\nanswer = 4\n\n#Test case 9:\nsource = \"abb\"\ntarget = \"bba\"\noriginal = [\"a\",\"b\",\"b\"]\nchanged = [\"b\",\"b\",\"a\"]\ncost = [1,2", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        dis = [[inf] * 26 for _ in range(26)]\n        for i in range(26):\n            dis[i][i] = 0\n\n        for x, y, c in zip(original, changed, cost):\n            x = ord(x) - ord('a')\n            y = ord(y) - ord('a')\n            dis[x][y] = min(dis[x][y], c)\n\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/74", "content": "\n", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/75", "content": "", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "cpp/0", "content": "", "groundtruth": "class Solution {public:static const int mod = 1e9 + 7;int specialPerm(vector<int>& nums) {int n = nums.size();vector<vector<int>> f(1 << n, vector<int>(n, -1));function<int(int, int)> dfs = [&](int state, int i) {if (f[state][i] != -1) {return f[state][i];}if (state == (1 << i)) {return 1;}f[state][i] = 0;for (int j = 0; j < n; j++) {if (i == j || !(state >> j & 1)) {continue;}if (nums[i] % nums[j] != 0 && nums[j] % nums[i] != 0) {continue;}f[state][i] = (f[state][i] + dfs(state ^ (1 << i), j)) % mod;}return f[state][i];};int res = 0;for (int i = 0; i < n; i++) {res = (res + dfs((1 << n) - 1, i)) % mod;}return res;}};"}
{"task_id": "cpp/1", "content": "Example 1:\nInput: cost = [10,10,10,10,10,10,10,10,10,10], time = [1,1,1,1,1,1,1,1,1,1]Output: 10\n\nExample 2:\nInput: cost = [1,2,3,4,5,6,7,8,9,10], time = [1,2,3,4,5,6,7,8,9,10]Output: 50\n\nNote:\n\nThe costs and times are positive integers.\n1 <= costs.length == times.length <= 1000\n\n\n\n\n\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        int n = cost.size();\n        vector<int> f(n * 2 + 1, INT_MAX / 2);\n        f[n] = 0;\n        for (int i = 0; i < n; ++i) {\n            vector<int> g(n * 2 + 1, INT_MAX / 2);\n            for (int j = 0; j <= n * 2; ++j) {\n                // 付费____// 免费\n                if (j > 0) {\n                    g[j - 1] = min(g[j - 1], f[j]);\n                }\n            }\n            f = move(g);\n        }\n        return *min_element(f.begin() + n, f.end());\n    }\n};\n\n", "groundtruth": "class Solution {public:int paintWalls(vector<int>& cost, vector<int>& time) {int n = cost.size();vector<int> f(n * 2 + 1, INT_MAX / 2);f[n] = 0;for (int i = 0; i < n; ++i) {vector<int> g(n * 2 + 1, INT_MAX / 2);for (int j = 0; j <= n * 2; ++j) {// 付费g[min(j + time[i], n * 2)] = min(g[min(j + time[i], n * 2)], f[j] + cost[i]);// 免费if (j > 0) {g[j - 1] = min(g[j - 1], f[j]);}}f = move(g);}return *min_element(f.begin() + n, f.end());}};"}
{"task_id": "cpp/2", "content": "", "groundtruth": "class Solution {public:string smallestString(string s) {char target = 'a';auto it = std::find_if(s.begin(), s.end(), [target](char c) {return c != target;});int indexOfFirstNonA = std::distance(s.begin(), it);if (indexOfFirstNonA == s.length()) {return s.substr(0, s.length() - 1) + 'z';}size_t indexOfFirstA_AfterFirstNonA = s.find('a', indexOfFirstNonA);if (indexOfFirstA_AfterFirstNonA == string::npos) {indexOfFirstA_AfterFirstNonA = s.length();}string res;for (int i = 0; i < s.length(); ++i) {if (indexOfFirstNonA <= i && i < indexOfFirstA_AfterFirstNonA) {res.push_back(static_cast<char>(s[i] - 1));} else {res.push_back(s[i]);}}return res;}};"}
{"task_id": "cpp/3", "content": "\nclass Solution {\npublic:\n    long long minCost(vector<int>& nums, int x) {\n        int n = nums.size();\n        vector<int> f(nums);\n        long long ans = 0;\n        for (int k = 1; k < n; ++k) {\n            for (int i = 0; i < n; ++i) {\n                f[i] = min(f[i], nums[(i + k) % n]);\n            }\n            ans = min(ans, x * (n - k) + f[0]);\n        }\n        return ans;\n    }\n};", "groundtruth": "class Solution {public:long long minCost(vector<int>& nums, int x) {int n = nums.size();vector<int> f(nums);long long ans = accumulate(f.begin(), f.end(), 0LL);for (int k = 1; k < n; ++k) {for (int i = 0; i < n; ++i) {f[i] = min(f[i], nums[(i + k) % n]);}ans = min(ans, static_cast<long long>(k) * x + accumulate(f.begin(), f.end(), 0LL));}return ans;}};"}
{"task_id": "cpp/4", "content": "\n \n\nExample 1:\nInput: nums1 = [3,3,6,6], nums2 = [1,1,2,2], queries = [[0,0,2],[1,1,2],[2,2,2],[3,3,2],[3,3,4]]\nOutput: [10,10,10,13,14]\nExplanation: The queries are processed as follows:\n- [0,0,2]: j = 0 -> [1,1], j = 1 -> [2,2], j = 2 -> [3,3] \n- [1,1,2]: j = 0 -> [1,1], j = 1 -> [2,2] \n- [2,2,2]: j = 0 -> [2,2] \n- [3,3,2]: j = 0 -> [3,3] \n- [3,3,4]: j = 0 -> [3,3], j = 1 -> [6,6]\n\nExample 2:\nInput: nums1 = [5,5,4,4,4], nums2 = [1,1,2,2,3], queries = [[0,3,2],[1,2,2],[0,1,4],[1,3,3],[1,3,4]]\nOutput: [15,15,12,13,14]\nExplanation: The queries are processed as follows:\n- [0,3,2]: j = 0 -> [5,5], j = 1 -> [4,4], j = 2 -> [3,3] \n- [1,2,2]: j = 0 -> [1,1], j = 1 -> [2,2] \n- [0,1,4]: j = 0 -> [5,5], j = 1 -> [4,4] \n- [1,3,3]: j = 0 -> [1,1], j = 1 -> [2,2], j = 2 -> [3,3] \n- [1,3,4]: j = 0 -> [1,1], j = 1 -> [2,2],", "groundtruth": "class Solution {public:vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {vector<pair<int, int>> sortedNums;vector<tuple<int, int, int>> sortedQueries;for (int i = 0; i < nums1.size(); i++) {sortedNums.emplace_back(nums1[i], nums2[i]);}sort(sortedNums.begin(), sortedNums.end(), greater<pair<int, int>>());for (int i = 0; i < queries.size(); i++) {sortedQueries.emplace_back(i, queries[i][0], queries[i][1]);}sort(sortedQueries.begin(), sortedQueries.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b) {return get<1>(a) > get<1>(b);});vector<pair<int, int>> stk;vector<int> answer(queries.size(), -1);int j = 0;for (auto &[i, x, y] : sortedQueries) {while (j < sortedNums.size() && sortedNums[j].first >= x) {auto [num1, num2] = sortedNums[j];while (!stk.empty() && stk.back().second <= num1 + num2) {stk.pop_back();}if (stk.empty() || stk.back().first < num2) {stk.emplace_back(num2, num1 + num2);}j++;}int k = lower_bound(stk.begin(), stk.end(), make_pair(y, 0)) - stk.begin();if (k < stk.size()) {answer[i] = stk[k].second;}}return answer;}};"}
{"task_id": "cpp/5", "content": "\nclass Solution {\npublic:\n    int longestSemiRepetitiveSubstring(string s) {\n        int ans = 1, left = 0, same = 0, n = s.length();\n        for (int right = 1; right < n; right++) {\n            if (s[right] == s[right - 1] && ++same > 1) {\n                same = 1;\n            }\n            ans = max(ans, right - left + 1);\n        }\n        return ans;\n    }\n};\n\n", "groundtruth": "class Solution {public:int longestSemiRepetitiveSubstring(string s) {int ans = 1, left = 0, same = 0, n = s.length();for (int right = 1; right < n; right++) {if (s[right] == s[right - 1] && ++same > 1) {for (left++; s[left] != s[left - 1]; left++);same = 1;}ans = max(ans, right - left + 1);}return ans;}};"}
{"task_id": "cpp/6", "content": "\nConstraints:\n1 <= n <= 105\nd <= 109\nnums[i] <= 109\ns[i] is either 'L' or 'R'\n", "groundtruth": "class Solution {public:static constexpr int mod = 1e9 + 7;int sumDistance(vector<int>& nums, string s, int d) {int n = nums.size();vector<long long> pos(n);for (int i = 0; i < n; i++) {if (s[i] == 'L') {pos[i] = (long long) nums[i] - d;} else {pos[i] = (long long) nums[i] + d;}}sort(pos.begin(), pos.end());long long res = 0;for (int i = 1; i < n; i++) {res += 1ll * (pos[i] - pos[i - 1]) * i % mod * (n - i) % mod;res %= mod;}return res;}};"}
{"task_id": "cpp/7", "content": "", "groundtruth": "class Solution {public:vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {vector<int> ans;unordered_map<int, int> mp;int m = grid.size();int n = grid[0].size();for (int j = 0; j < m; j++) {int st = 0;for (int i = 0; i < n; i++) {st |= (grid[j][i] << i);}mp[st] = j;}if (mp.count(0)) {ans.push_back(mp[0]);return ans;}for (auto [x, i]: mp) {for (auto [y, j]: mp) {if (!(x & y)) {return {min(i, j), max(i, j)};}}}return ans;}};"}
{"task_id": "cpp/8", "content": "Note: You are not allowed to use the built-in matrix structure.\n\n \n\nExample 1:\n\nInput: n = 2, queries = [[1,0,1],[0,1,1]]\nOutput: [2,2]\nExplanation: After the first query, the matrix looks like this: 1 1 \n              |1 0|\n              |0 1|\nAfter the second query, the matrix looks like this: 2 2 \n              |1 1|\n              |1 1|\nExample 2:\n\nInput: n = 1, queries = [[0,0,1]]\nOutput: [1]\nExample 3:\n\nInput: n = 5, queries = [[4,2,0],[4,3,1],[1,4,0],[1,2,1],[2,2,1]]\nOutput: [0,1,1,1,1]\n \n\nConstraints:\n\n1 <= n <= 100\n1 <= m <= 100\nqueries.length == m\n0 <= typei, indexi, vali <= n\nOnly one operation of each type is supported for each index.\n\n\n\n\n\n\nclass Solution {\npublic:\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\n        long long ans = 0;\n        unordered_set<int> vis[2];\n        for (int i = queries.size() - 1; i >= 0; i--) {\n            auto &q = queries[i];\n            int type = q[0], index = q[1], val = q[2];\n            if (!vis[type].count(index)) {\n                // 后面（>i）没有对这一行/列的操作// 这一行/列还剩下 n-vis[type^1].size() 个可以填入的格子____vis[type].insert(index);\n                ans += (n - vis[type^1].size()) * val;\n            }\n        }\n        return ans;\n    }\n};\n", "groundtruth": "class Solution {public:long long matrixSumQueries(int n, vector<vector<int>> &queries) {long long ans = 0;unordered_set<int> vis[2];for (int i = queries.size() - 1; i >= 0; i--) {auto &q = queries[i];int type = q[0], index = q[1], val = q[2];if (!vis[type].count(index)) { // 后面（>i）没有对这一行/列的操作// 这一行/列还剩下 n-vis[type^1].size() 个可以填入的格子ans += (long long) (n - vis[type ^ 1].size()) * val;vis[type].insert(index);}}return ans;}};"}
{"task_id": "cpp/9", "content": "\n \n\nExample 1:\n\nInput: num1 = \"1\", num2 = \"2\", min_sum = 1, max_sum = 3\nOutput: 2\nExplanation: The two good integers are 1 and 2.\n\nExample 2:\n\nInput: num1 = \"3\", num2 = \"5\", min_sum = 1, max_sum = 6\nOutput: 4\nExplanation: The four good integers are 3, 4, 5, and 6.\n\n \n\nConstraints:\n\n    1 <= num1.length, num2.length <= 100\n    num1 and num2 consist of digits only.\n    min_sum <= max_sum\n    max_sum <= 109\n\n\n \n\n\n\n\n\n\n\n\nclass Solution {\npublic:\n    int count(string num1, string num2, int min_sum, int max_sum) {\n        int n = num1.size(), m = num2.size(), res = 0;\n        vector<vector<int>> dp(n + 1, vector<int>(max_sum + 1, 0));\n        for(int i = 0; i < n; i++) {\n            dp[i + 1][0] = dp[i][0];\n            int x = num1[i] - '0';\n            for(int j = 1; j <= max_sum; j++) {\n                dp[i + 1][j] = dp[i][j];\n                if(j >= x) {\n                    dp[i + 1][j] += dp[i][j - x];\n                }\n            }\n        }\n        for(int i = 0; i < m; i++) {\n            int x = num2[i] - '0';\n            for(int j = min_sum; j <= max_sum; j++) {\n                if(j >= x) {\n                    res = (res + dp[n][j - x]) % 1000000007;\n                }\n            }\n        }\n        return res;\n    }\n", "groundtruth": "class Solution {static constexpr int N = 23;static constexpr int M = 401;static constexpr int MOD = 1e9 + 7;int d[N][M];string num;int min_sum;int max_sum;int dfs(int i, int j, bool limit) {if (j > max_sum) {return 0;}if (i == -1) {return j >= min_sum;}if (!limit && d[i][j] != -1) {return d[i][j];}int res = 0;int up = limit ? num[i] - '0' : 9;for (int x = 0; x <= up; x++) {res = (res + dfs(i - 1, j + x, limit && x == up)) % MOD;}if (!limit) {d[i][j] = res;}return res;}int get(string num) {reverse(num.begin(), num.end());this->num = num;return dfs(num.size() - 1, 0, true);}// 求解 num - 1，先把最后一个非 0 字符减去 1，再把后面的 0 字符变为 9string sub(string num) {int i = num.size() - 1;while (num[i] == '0') {i--;}num[i]--;i++;while (i < num.size()) {num[i] = '9';i++;}return num;}public:int count(string num1, string num2, int min_sum, int max_sum) {memset(d, -1, sizeof d);this->min_sum = min_sum;this->max_sum = max_sum;return (get(num2) - get(sub(num1)) + MOD) % MOD;}};"}
{"task_id": "cpp/10", "content": "\nclass Solution {\npublic:\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\n        int n = mat.size();\n        int m = mat[0].size();\n        unordered_map<int, pair<int, int>> mp;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                mp[mat[i][j]] = {i, j};\n            }\n        }\n        vector<int> rowCnt(n, 0);\n        vector<int> colCnt(m, 0);\n        for (int i = 0; i < arr.size(); ++i) {\n            pair<int, int> v = mp[arr[i]];\n            ++rowCnt[v.first];\n            if (rowCnt[v.first] == m) {\n                return i;\n            }\n            ++colCnt[v.second];\n            if (colCnt[v.second] == n) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n", "groundtruth": "class Solution {public:int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {int n = mat.size();int m = mat[0].size();unordered_map<int, pair<int, int>> mp;for (int i = 0; i < n; ++i) {for (int j = 0; j < m; ++j) {mp[mat[i][j]] = {i, j};}}vector<int> rowCnt(n, 0);vector<int> colCnt(m, 0);for (int i = 0; i < arr.size(); ++i) {auto& v = mp[arr[i]];++rowCnt[v.first];if (rowCnt[v.first] == m) {return i;}++colCnt[v.second];if (colCnt[v.second] == n) {return i;}}return -1;}};"}
{"task_id": "cpp/11", "content": "", "groundtruth": "class Solution {public:int minimumCost(vector<int> &start, vector<int> &target, vector <vector<int>> &specialRoads) {using LL = long long;LL t = (LL) target[0] << 32 | target[1];unordered_map<LL, int> dis = {{(LL) start[0] << 32 | start[1], 0}, {t, INT_MAX}};unordered_set<LL> vis;for (;;) {LL v = -1;int dv = -1;for (auto &[p, d]: dis)if (!vis.count(p) && (dv < 0 || d < dv))v = p, dv = d;if (v == t) return dv; // 到终点的最短路已确定vis.insert(v);int vx = v >> 32, vy = v & UINT32_MAX;// 更新到终点的最短路dis[t] = min(dis[t], dv + target[0] - vx + target[1] - vy);for (auto &r: specialRoads) {int d = dv + abs(r[0] - vx) + abs(r[1] - vy) + r[4];LL w = (LL) r[2] << 32 | r[3];if (!dis.count(w) || d < dis[w])dis[w] = d;}}}};"}
{"task_id": "cpp/12", "content": "\nExample 1:\nInput: s = \"aabcb\", k = 5\nOutput: \"aabbb\"\nExplanation: The smallest beautiful string is \"aabbb\".\n\nExample 2:\nInput: s = \"aab\", k = 3\nOutput: \"bbb\"\n\nExample 3:\nInput: s = \"ab\", k = 3\nOutput: \"\"\n\nConstraints:\ns.length == n\n1 <= n <= 100\n1 <= k <= 100\ns consists of lowercase English letters.\n", "groundtruth": "class Solution {public:string smallestBeautifulString(string s, int k) {for (int i = s.length() - 1; i >= 0; --i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {____}}for (int j = 1; j <= 3; ++j) {if (s[i] - 'a' + j + 1 <= k && blockedCharacters.find(s[i] + j) == blockedCharacters.end()) {return generate(s, i, j);}}}return \"\";}string generate(string s, int idx, int offset) {s[idx] += offset;for (int i = idx + 1; i < s.length(); ++i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {blockedCharacters.insert(s[i - j]);}}for (int j = 0; j < 3; ++j) {if (____) {s[i] = 'a' + j;break;}}}return s;}};"}
{"task_id": "cpp/13", "content": "Example 1:\nInput: a = [1,2,3], b = [1,2,3]\nOutput: [1,2,3]\nExplanation: The prefix common array is [1,2,3].\nExample 2:\nInput: a = [1,2,3], b = [1,2,4]\nOutput: [1,2]\nExplanation: The prefix common array is [1,2].\n\n\nSolution:\n\nclass Solution {public:\n    vector<int> findThePrefixCommonArray(vector<int> &a, vector<int> &b) {\n        int n = a.size();\n        vector<int> ans(n);\n        long long p = 0, q = 0;\n        for (int i = 0; i < n; ++i) {\n            p |= 1LL << a[i];\n            q |= 1LL << b[i];\n            ans[i] = __builtin_popcount(p & q);\n        }\n        return ans;\n    }\n};\n\n\n\n\n", "groundtruth": "class Solution {public:vector<int> findThePrefixCommonArray(vector<int> &a, vector<int> &b) {int n = a.size();vector<int> ans(n);long long p = 0, q = 0;for (int i = 0; i < n; ++i) {p |= 1LL << a[i];q |= 1LL << b[i];ans[i] = __builtin_popcountll(p & q);}return ans;}};"}
{"task_id": "cpp/14", "content": "\n \n\nNote: The above incomplete code is just a sample of the given code. The actual code has no compile errors and can run successfully.\n\n \n\nExample 1:\n\n\nInput: grid = [[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]]\nOutput: 0\nExplanation: No fish are available to catch.\nExample 2:\n\n\nInput: grid = [[1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,1],[1,0,1,1,1,0,0,1],[1,0,0,0,0,0,0,1],[1,0,1,1,1,0,0,1],[1,0,0,0,0,0,0,1],[1,0,1,1,1,0,0,1],[1,1,1,1,1,1,1,1]]\nOutput: 14\nExplanation: The maximum number of fish that can be caught is 14.\nExample 3:\n\n\nInput: grid = [[0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0]]\nOutput: 0\n \n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 200\ngrid[i][j] is either 0 or 1.\n \n\nFollow up: Can you solve this problem in linear time?\n\n\n\n\n\n\nclass Solution {\npublic:\n    int maxAreaOfIsland(vector", "groundtruth": "class Solution {static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};public:int findMaxFish(vector<vector<int>> &grid) {int m = grid.size(), n = grid[0].size(), ans = 0;function<int(int, int)> dfs = [&](int x, int y) -> int {if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)return 0;int sum = grid[x][y];grid[x][y] = 0; // 标记成访问过for (auto &d: dirs) // 四方向移动sum += dfs(x + d[0], y + d[1]);return sum;};for (int i = 0; i < m; ++i)for (int j = 0; j < n; ++j)ans = max(ans, dfs(i, j));return ans;}};"}
{"task_id": "cpp/15", "content": "\n// 树状数组模板\nclass BIT {\npublic:\n    vector<int> tree;\n    BIT(int n) : tree(n) {}\n\n    // 将下标 i 上的数加一\n    void inc(int i) {\n        while (i < tree.size()) {\n            ++tree[i];\n            i += i & -i;\n        }\n    }\n\n    // 返回闭区间 [1, i] 的元素和\n    int sum(int x) {\n        int res = 0;\n        while (x > 0) {\n            res += tree[x];\n            x &= x - 1;\n        }\n        return res;\n    }\n\n    // 返回闭区间 [left, right] 的元素和\n    int query(int left, int right) {\n        return sum(right) - sum(left - 1);\n    }\n};\n\nclass Solution {\npublic:\n    long long countOperationsToEmptyArray(vector<int> &nums) {\n        int n = nums.size(), id[n];\n        iota(id, id + n, 0);\n        sort(id, id + n, [&](int i, int j) {\n            return nums[i] < nums[j];\n        });\n        long long ans = n; // 先把 n 计入答案\n        BIT t(n + 1); // 下标从 1 开始\n        int pre = 1; // 上一个最小值的位置，初始为 1\n        for (int k = 0; k < n; ++k) {\n            int i = id[k] + 1; // 下标从 1 开始\n            if (i >= pre) // 从 pre 移动到 i，跳过已经删除的数\n                t.inc(i);\n            else // 从 pre 移动到 n，再从 1 移动到 i，跳过已经删除的数\n                t.inc(n -", "groundtruth": "// 树状数组模板class BIT {vector<int> tree;public:BIT(int n) : tree(n) {}// 将下标 i 上的数加一void inc(int i) {while (i < tree.size()) {++tree[i];i += i & -i;}}// 返回闭区间 [1, i] 的元素和int sum(int x) {int res = 0;while (x > 0) {res += tree[x];x &= x - 1;}return res;}// 返回闭区间 [left, right] 的元素和int query(int left, int right) {return sum(right) - sum(left - 1);}};class Solution {public:long long countOperationsToEmptyArray(vector<int> &nums) {int n = nums.size(), id[n];iota(id, id + n, 0);sort(id, id + n, [&](int i, int j) {return nums[i] < nums[j];});long long ans = n; // 先把 n 计入答案BIT t(n + 1); // 下标从 1 开始int pre = 1; // 上一个最小值的位置，初始为 1for (int k = 0; k < n; ++k) {int i = id[k] + 1; // 下标从 1 开始if (i >= pre) // 从 pre 移动到 i，跳过已经删除的数ans += i - pre - t.query(pre, i);else // 从 pre 移动到 n，再从 1 移动到 i，跳过已经删除的数ans += n - pre + i - k + t.query(i, pre - 1);t.inc(i); // 删除 ipre = i;}return ans;}};"}
{"task_id": "cpp/16", "content": "\n", "groundtruth": "class Solution {public:vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x) {const int BIAS = 50;int cnt[BIAS * 2 + 1]{}, n = nums.size();for (int i = 0; i < k - 1; ++i) // 先往窗口内添加 k-1 个数++cnt[nums[i] + BIAS];vector<int> ans(n - k + 1);for (int i = k - 1; i < n; ++i) {++cnt[nums[i] + BIAS]; // 进入窗口（保证窗口有恰好 k 个数）int left = x;for (int j = 0; j < BIAS; ++j) { // 暴力枚举负数范围 [-50,-1]left -= cnt[j];if (left <= 0) { // 找到美丽值ans[i - k + 1] = j - BIAS;break;}}--cnt[nums[i - k + 1] + BIAS]; // 离开窗口}return ans;}};"}
{"task_id": "cpp/17", "content": "\nclass Solution {\npublic:\n    int minOperations(vector<int> &nums) {\n        int n = nums.size(), gcd_all = 0, cnt1 = 0;\n        for (int x: nums) {\n            gcd_all = gcd(gcd_all, x);\n            if (gcd_all == 1) ++cnt1;\n        }\n        if (gcd_all > 1) return -1;\n        if (cnt1) return n - cnt1;\n        int min_size = n;\n        for (int i = 0; i < n; ++i) {\n            int g = 0;\n            for (int j = i; j < n; ++j) {\n                g = gcd(g, nums[j]);\n                if (g == 1) break;\n            }\n            if (g == 1) min_size = min(min_size, j - i + 1);\n        }\n        return min_size + n - 1;\n    }\n};", "groundtruth": "class Solution {public:int minOperations(vector<int> &nums) {int n = nums.size(), gcd_all = 0, cnt1 = 0;for (int x: nums) {gcd_all = gcd(gcd_all, x);cnt1 += x == 1;}if (gcd_all > 1) return -1;if (cnt1) return n - cnt1;int min_size = n;for (int i = 0; i < n; ++i) {int g = 0;for (int j = i; j < n; ++j) {g = gcd(g, nums[j]);if (g == 1) {// 这里本来是 j-i+1，把 +1 提出来合并到 return 中min_size = min(min_size, j - i);break;}}}return min_size + n - 1;}};"}
{"task_id": "cpp/18", "content": "The code has been tested and verified.\n \nExample 1:\nInput: nums = [3,6,1,2], divisors = [1,2,3]\nOutput: 6\nExplanation:\nFor divisors[0]=1, the maximum divisibility score is 2.\nFor divisors[1]=2, the maximum divisibility score is 3.\nFor divisors[2]=3, the maximum divisibility score is 1.\nThe divisor with the maximum divisibility score is divisors[1]=2.\n\nExample 2:\nInput: nums = [1,2,3,4,5,6], divisors = [1,7,10,11]\nOutput: 6\nExplanation:\nFor divisors[0]=1, the maximum divisibility score is 6.\nFor divisors[1]=7, the maximum divisibility score is 0.\nFor divisors[2]=10, the maximum divisibility score is 0.\nFor divisors[3]=11, the maximum divisibility score is 0.\nThe divisor with the maximum divisibility score is divisors[0]=1.\n \nConstraints:\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5\n1 <= divisors.length <= 10^5\n1 <= divisors[i] <= 10^5\n\nSolution:\n\nclass Solution {\npublic:\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\n        int cnt = -1, ans = 0;\n        for (int i = 0; i < divisors.size(); i++) {\n            int tmp = 0;\n            for (int j = 0; j < nums.size(); j++) {\n                if (nums[j] % divisors[i] == 0) {\n                    tmp++;\n                }\n            }\n            if (tmp > cnt || (tmp == cnt && divisors[i] < ans)) {\n                cnt = tmp;\n                ans = divisors[i];\n            }\n        }\n        return ans;\n    }\n};\n", "groundtruth": "class Solution {public:int maxDivScore(vector<int>& nums, vector<int>& divisors) {int cnt = -1, ans = 0;for (int i = 0; i < divisors.size(); i++) {int tmp = 0;for (int j = 0; j < nums.size(); j++) {if (nums[j] % divisors[i] == 0) {tmp++;}}if (tmp > cnt || (tmp == cnt && divisors[i] < ans)) {ans = divisors[i];cnt = tmp;}}return ans;}};"}
{"task_id": "cpp/19", "content": "\n\nExample 1:\nInput: word = \"a\"\nOutput: 1\nExplanation: The string \"a\" can be formed by concatenating the string \"abc\" 1 time. Thus, the minimum number of letters that must be inserted is 1.\n\nExample 2:\nInput: word = \"ab\"\nOutput: 0\nExplanation: The string \"ab\" can be formed by concatenating the string \"abc\" 1 time. Thus, the minimum number of letters that must be inserted is 0.\n\nExample 3:\nInput: word = \"abc\"\nOutput: 0\nExplanation: The string \"abc\" can be formed by concatenating the string \"abc\" 1 time. Thus, the minimum number of letters that must be inserted is 0.\n\nExample 4:\nInput: word = \"abca\"\nOutput: 0\nExplanation: The string \"abca\" can be formed by concatenating the string \"abc\" 1 time. Thus, the minimum number of letters that must be inserted is 0.\n\nExample 5:\nInput: word = \"aabc\"\nOutput: 0\nExplanation: The string \"aabc\" can be formed by concatenating the string \"abc\" 1 time. Thus, the minimum number of letters that must be inserted is 0.\n\n\nConstraints:\n\n1 <= word.length <= 1000\nword only consists of the characters 'a', 'b', and 'c'.", "groundtruth": "class Solution {public:int addMinimum(string word) {int n = word.size();vector<int> d(n + 1);for (int i = 1; i <= n; i++) {d[i] = d[i - 1] + 2;if (i > 1 && word[i - 1] > word[i - 2]) {d[i] = d[i - 1] - 1;}}return d[n];}};"}
{"task_id": "cpp/20", "content": "\nExample 1:\nInput: n = 5, edges = [[0,1],[2,3],[0,4]], price = [10,20,30,40,50], trips = [[0,1],[1,2],[3,4],[0,3],[1,4],[2,3],[0,2]]\nOutput: 200\nExplanation: There are two trips:\n1. From node 0 to node 1 with a price sum of 10 + 20 = 30.\n2. From node 3 to node 4 with a price sum of 40 + 50 = 90.\nThe minimum total price sum to complete all the given trips is 30 + 90 = 120, so 120 is returned.\nExample 2:\nInput: n = 3, edges = [[0,1],[1,2]], price = [10,20,30], trips = [[0,1],[1,2],[0,2]]\nOutput: 50\nExplanation: There are three trips:\n1. From node 0 to node 1 with a price sum of 10.\n2. From node 1 to node 2 with a price sum of 20.\n3. From node 0 to node 2 with a price sum of 30.\nThe minimum total price sum to complete all the given trips is 10 + 20 + 30 = 60, so 60 is returned.\n \nConstraints:\n\n2 <= n <= 1000\nn - 1 <= edges.length <= 2000\nedges[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\nprice.length == n\n1 <= price[i] <= 100\n1 <= trips.length <= 1000\ntrips[i].length == 2\n0 <= starti, endi <= n - 1\nstarti != endi\nThere is at least one path between any two nodes.\n\n", "groundtruth": "class Solution {public:int minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips) {vector<vector<int>> next(n);for (auto &edge : edges) {next[edge[0]].push_back(edge[1]);next[edge[1]].push_back(edge[0]);}vector<int> count(n);function<bool(int, int, int)> dfs = [&](int node, int parent, int end) -> bool {if (node == end) {count[node]++;return true;}for (int child : next[node]) {if (child == parent) {continue;}if (dfs(child, node, end)) {count[node]++;return true;}}return false;};for (auto &trip: trips) {dfs(trip[0], -1, trip[1]);}function<pair<int, int>(int, int)> dp = [&](int node, int parent) -> pair<int, int> {pair<int, int> res = {price[node] * count[node], price[node] * count[node] / 2};for (int child : next[node]) {if (child == parent) {continue;}auto [x, y] = dp(child, node);res.first += min(x, y); // node 没有减半，因此可以取子树的两种情况的最小值res.second += x; // node 减半，只能取子树没有减半的情况}return res;};auto [x, y] = dp(0, -1);return min(x, y);}};"}
{"task_id": "cpp/21", "content": "\n", "groundtruth": "class Solution {public:vector<long long> findPrefixScore(vector<int>& nums) {vector<long long> ans;int tmp = nums[0];ans.push_back(nums[0] * 2);for (int i = 1; i < nums.size(); ++i) {if (nums[i] > tmp) tmp = nums[i];ans.push_back(nums[i] + tmp + ans[i - 1]);}return ans;}};"}
{"task_id": "cpp/22", "content": "The following is the class of TreeNode.\nclass TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nThe code should be completed without any other library.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {public:TreeNode* replaceValueInTree(TreeNode* root) {vector<TreeNode*> q = {root};root->val = 0;while (!q.empty()) {vector<TreeNode*> q2;int sum = 0;for (auto fa : q) {if (fa->left) {q2.push_back(fa->left);sum += fa->left->val;}if (fa->right) {q2.push_back(fa->right);sum += fa->right->val;}}for (auto fa : q) {int child_sum = (fa->left ? fa->left->val : 0) +(fa->right ? fa->right->val : 0);if (fa->left) {fa->left->val = sum - child_sum;}if (fa->right) {fa->right->val = sum - child_sum;}}q = move(q2);}return root;}};"}
{"task_id": "cpp/23", "content": "\n\nConstraints:\n\n2 <= n <= 105\n1 <= edges.length <= 105\nedges[i].length == 3\n0 <= fromi, toi <= n - 1\n0 <= edgeCosti <= 109\nThere does not exist any edge from i to i.\nThere may exist parallel edges between two nodes.\nNo edge will be added after calling shortestPath(node1, node2).\nshortestPath(node1, node2) will not be called twice with the same node1 and node2.\n\n\n\n\n\n\n\nclass Graph {\npublic:\n    using pii = pair<int, int>;\n    Graph(int n, vector<vector<int>>& edges) {\n        this->graph = vector<vector<pii>>(n);\n        for (auto &vec : edges) {\n            int x = vec[0];\n            int y = vec[1];\n            int cost = vec[2];\n            graph[x].emplace_back(y, cost);\n        }\n    }\n    \n    void addEdge(vector<int> edge) {\n        int x = edge[0];\n        int y = edge[1];\n        int cost = edge[2];\n        graph[x].emplace_back(y, cost);\n    }\n    \n    int shortestPath(int node1, int node2) {\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\n        vector<int> dist(graph.size(), INT_MAX);\n        dist[node1] = 0;\n        pq.emplace(0, node1);\n        while (!pq.empty()) {\n            auto [cost, cur] = pq.top();\n            pq.pop();\n            if (cur == node2) {\n                return cost;\n            }\n            for (auto [next, ncost] : graph[cur]) {\n                if (dist[next] > cost + ncost) {\n                    dist[next] = cost + ncost;\n                    pq.emplace(dist[next], next);\n                }\n            }\n        }\n        return -1;\n    }\n    \n", "groundtruth": "class Graph {public:using pii = pair<int, int>;Graph(int n, vector<vector<int>>& edges) {this->graph = vector<vector<pii>>(n);for (auto &vec : edges) {int x = vec[0];int y = vec[1];int cost = vec[2];graph[x].emplace_back(y, cost);}}void addEdge(vector<int> edge) {int x = edge[0];int y = edge[1];int cost = edge[2];graph[x].emplace_back(y, cost);}int shortestPath(int node1, int node2) {priority_queue<pii, vector<pii>, greater<pii>> pq;vector<int> dist(graph.size(), INT_MAX);dist[node1] = 0;pq.emplace(0, node1);while (!pq.empty()) {auto [cost, cur] = pq.top();pq.pop();if (cur == node2) {return cost;}for (auto [next, ncost] : graph[cur]) {if (dist[next] > cost + ncost) {dist[next] = cost + ncost;pq.emplace(cost + ncost, next);}}}return -1;}private:vector<vector<pii>> graph;};"}
{"task_id": "cpp/24", "content": "\nNote:\nThe answer is guaranteed to fit within the range of a signed 32-bit integer.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "groundtruth": "class Solution {public:vector<long long> distance(vector<int> &nums) {int n = nums.size();unordered_map<int, vector<int>> groups;for (int i = 0; i < n; ++i)groups[nums[i]].push_back(i); // 相同元素分到同一组，记录下标vector<long long> ans(n);long long s[n + 1];s[0] = 0;for (auto &[_, a]: groups) {int m = a.size();for (int i = 0; i < m; ++i)s[i + 1] = s[i] + a[i]; // 前缀和for (int i = 0; i < m; ++i) {long long target = a[i];long long left = target * i - s[i]; // 蓝色面积long long right = s[m] - s[i] - target * (m - i); // 绿色面积ans[target] = left + right;}}return ans;}};"}
{"task_id": "cpp/25", "content": "", "groundtruth": "class Solution {public:int minimizeMax(vector<int> &nums, int p) {sort(nums.begin(), nums.end());int left = -1, right = nums.back() - nums[0]; // 开区间while (left + 1 < right) { // 开区间int mid = left + (right - left) / 2, cnt = 0;for (int i = 0; i < nums.size() - 1; ++i)if (nums[i + 1] - nums[i] <= mid) { // 都选++cnt;++i;}(cnt >= p ? right : left) = mid;}return right;}};"}
{"task_id": "cpp/26", "content": "The answer is in the range of a 32-bit signed integer.\nNote: This problem is a simplified version of Problem 1386.\n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n0 <= grid[i][j] <= 100", "groundtruth": "class Solution {public:int minimumVisitedCells(vector<vector<int>>& grid) {int m = grid.size(), n = grid[0].size();vector<vector<int>> dist(m, vector<int>(n, -1));dist[0][0] = 1;vector<priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>> row(m), col(n);auto update = [](int& x, int y) {if (x == -1 || y < x) {x = y;}};for (int i = 0; i < m; ++i) {for (int j = 0; j < n; ++j) {while (!row[i].empty() && row[i].top().second + grid[i][row[i].top().second] < j) {row[i].pop();}if (!row[i].empty()) {update(dist[i][j], dist[i][row[i].top().second] + 1);}while (!col[j].empty() && col[j].top().second + grid[col[j].top().second][j] < i) {col[j].pop();}if (!col[j].empty()) {update(dist[i][j], dist[col[j].top().second][j] + 1);}if (dist[i][j] != -1) {row[i].emplace(dist[i][j], j);col[j].emplace(dist[i][j], i);}}}return dist[m - 1][n - 1];}};"}
{"task_id": "cpp/27", "content": "\n \n\nExample 1:\n\nInput: nums = [1,3,2,6,5,2]\nOutput: [[1,2,3],[5,6]]\nExplanation: Choosing the rows indexed at 0 and 2 is optimal because they contain the minimum number of elements.\nExample 2:\n\nInput: nums = [1,2,3,4,5,6]\nOutput: [[1,2,3],[4,5,6]]\nExplanation: Choosing the rows indexed at 0, 1, and 2 is also optimal.\n \n\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 1000\n \n\nFollow-up:\nWhat if nums contains duplicates? How would you adjust your code?\n\n \n\nclass Solution {\npublic:\n    vector<vector<int>> findMatrix(vector<int>& nums) {\n        unordered_map<int, int> cnt;\n        for (int x : nums) ++cnt[x];\n        vector<vector<int>> ans;\n        while (!cnt.empty()) {\n            vector<int> row;\n            for (auto it = cnt.begin(); it != cnt.end();) {\n                row.push_back(it->first);\n                if (--it->second == 0) cnt.erase(it);\n                else ++it;\n            }\n            ans.push_back(row);\n        }\n        return ans;\n    }\n};\n\n", "groundtruth": "class Solution {public:vector<vector<int>> findMatrix(vector<int> &nums) {unordered_map<int, int> cnt;for (int x: nums) ++cnt[x];vector<vector<int>> ans;while (!cnt.empty()) {vector<int> row;for (auto it = cnt.begin(); it != cnt.end();) {row.push_back(it->first);if (--it->second == 0) it = cnt.erase(it);else ++it;}ans.push_back(row);}return ans;}};"}
{"task_id": "cpp/28", "content": "\nThe test data is as follows:\nreward1=[9,8,6,3,1,2]\nreward2=[7,6,4,2,1,1]\nk=3\nreturn 21\n\nThe test data is as follows:\nreward1=[2,8,5,7]\nreward2=[4,1,2,7]\nk=2\nreturn 14\n\nThe test data is as follows:\nreward1=[1,9,8,5,6,3,4]\nreward2=[5,2,6,3,7,1,1]\nk=5\nreturn 22\n\nThe test data is as follows:\nreward1=[1,2,3,4,5,6,7]\nreward2=[5,4,3,2,1,6,7]\nk=7\nreturn 28\n", "groundtruth": "class Solution {public:int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {int ans = 0;int n = reward1.size();vector<int> diffs(n);for (int i = 0; i < n; i++) {ans += reward2[i];diffs[i] = reward1[i] - reward2[i];}sort(diffs.begin(), diffs.end());for (int i = 1; i <= k; i++) {ans += diffs[n - i];}return ans;}};"}
{"task_id": "cpp/29", "content": "\n\n \n\n \n\nExample 1:\n\nInput: n = 5, p = 3, banned = [1, 2], k = 2\nOutput: [-1, -1, -1, -1, -1]\nExplanation: The single 1 is at position 3. Reverse the subarray [1, 2] will not change the value of the single 1.\nExample 2:\n\nInput: n = 3, p = 1, banned = [], k = 2\nOutput: [0, 0, 1]\nExplanation: The single 1 is at position 1. Reverse the subarray [1, 2] to get [2, 1].\nExample 3:\n\nInput: n = 3, p = 1, banned = [3], k = 2\nOutput: [0, 1, 1]\nExplanation: The single 1 is at position 1. Reverse the subarray [1, 2] to get [2, 1].\n \n\nConstraints:\n\n1 <= n <= 105\n0 <= p < n\n0 <= banned.length <= 1000\n0 <= banned[i] < n\n1 <= k <= n\n\n```\n/*\n * @lc app=leetcode id=1829 lang=cpp\n *\n * [1829] Maximum XOR for Each Pair\n */\nclass Solution {\npublic:\n    vector<int> minReverseOperations(int n, int p, vector<int> &banned, int k) {\n        unordered_set<int> ban{banned.begin(), banned.end()};\n        set<int> sets[2];\n        for (int i = 0; i < n; ++i)\n            if (i != p && ban.find(i) == ban.end())\n                sets[i % 2].insert(i);\n        sets[0].insert(n);\n        sets[1].insert(n);\n        // 哨兵\n        vector<int> ans(n, -1);\n        vector<int> q = {p};\n        for (", "groundtruth": "class Solution {public:vector<int> minReverseOperations(int n, int p, vector<int> &banned, int k) {unordered_set<int> ban{banned.begin(), banned.end()};set<int> sets[2];for (int i = 0; i < n; ++i)if (i != p && !ban.count(i))sets[i % 2].insert(i);sets[0].insert(n);sets[1].insert(n); // 哨兵vector<int> ans(n, -1);vector<int> q = {p};for (int step = 0; !q.empty(); ++step) {vector<int> nq;for (int i: q) {ans[i] = step;// 从 mn 到 mx 的所有位置都可以翻转到int mn = max(i - k + 1, k - i - 1);int mx = min(i + k - 1, n * 2 - k - i - 1);auto &s = sets[mn % 2];for (auto it = s.lower_bound(mn); *it <= mx; it = s.erase(it))nq.push_back(*it);}q = move(nq);}return ans;}};"}
{"task_id": "java/0", "content": "\n\n\n\n\n\n\nclass Solution {    public int findChampion(int n, int[][] edges) {        int[] degree = new int[n];        for (int[] e : edges) {            degree[e[0]]--;            degree[e[1]]++;        }        int champion = -1;        for (int i = 0; i < n; i++) {            if (degree[i] == 0) {                if (champion == -1) {                    champion = i;                } else {                    return -1;                }            }        }        return champion;    }", "groundtruth": "class Solution {    public int findChampion(int n, int[][] edges) {        int[] degree = new int[n];        for (int[] e : edges) {            degree[e[1]]++;        }        int champion = -1;        for (int i = 0; i < n; i++) {            if (degree[i] == 0) {                if (champion == -1) {                    champion = i;                } else {                    return -1;                }            }        }        return champion;    }}"}
{"task_id": "java/1", "content": "\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <functional>\n#include <iostream>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\nclass Solution {\npublic:\n    long maximumScoreAfterOperations(vector<vector<int>> &edges, vector<int> &values) {\n        vector<vector<int>> g(values.size());\n        for (auto &edge : edges) {\n            g[edge[0]].push_back(edge[1]);\n            g[edge[1]].push_back(edge[0]);\n        }\n        int n = values.size();\n        priority_queue<pair<int, int>> pq;\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += values[i];\n            pq.push(make_pair(values[i], i));\n        }\n        unordered_map<int, unordered_set<int>> edge_dict;\n        for (int i = 0; i < edges.size(); i++) {\n            int u = edges[i][0], v = edges[i][1];\n            edge_dict[u].insert(v);\n            edge_dict[v].insert(u);\n        }\n        while (!pq.empty()) {\n            int idx = pq.top().second;\n            if (g[idx].size() == 1) {\n                return sum - 2 * pq.top().first;\n            }\n            int max_nei = 0;\n            int max_nei_idx = 0;\n            for (int nei : g[idx]) {\n                if (nei == pq.top().second) {\n                    continue;\n                }\n                if (values[nei] > max_nei) {\n                    max_nei = values[nei];\n                    max_nei_idx = nei;\n                }\n            }\n            values[max_nei_idx] = values[idx];\n            values[idx] = max_nei;\n            sum -=", "groundtruth": "class Solution {    public long maximumScoreAfterOperations(int[][] edges, int[] values) {        List<Integer>[] g = new ArrayList[values.length];        Arrays.setAll(g, e -> new ArrayList<>());        g[0].add(-1);         for (int[] e : edges) {            int x = e[0], y = e[1];            g[x].add(y);            g[y].add(x);        }        long ans = 0;        for (int v : values) {            ans += v;        }        return ans - dfs(0, -1, g, values);    }    private long dfs(int x, int fa, List<Integer>[] g, int[] values) {        if (g[x].size() == 1) {             return values[x];        }        long loss = 0;         for (int y : g[x]) {            if (y != fa) {                loss += dfs(y, x, g, values);             }        }        return Math.min(values[x], loss);     }}"}
{"task_id": "java/2", "content": "\nAnswer:\nclass Solution {\n    public String triangleType(int[] nums) {\n        Arrays.sort(nums);\n        int x = nums[0];\n        int y = nums[1];\n        int z = nums[2];\n        if (x + y <= z) {\n            return \"none\";\n        }\n        if (x == z) {\n            return \"equilateral\";\n        }\n        if (y == z) {\n            return \"isosceles\";\n        }\n        return \"scalene\";\n    }\n}\n\n\n\n\n", "groundtruth": "class Solution {    public String triangleType(int[] nums) {        Arrays.sort(nums);        int x = nums[0];        int y = nums[1];        int z = nums[2];        if (x + y <= z) { // 排序后，只需比较 x+y 和 z            return 'none';        }        if (x == z) { // 排序了，说明 y 也和 x z 相等            return 'equilateral';        }        if (x == y || y == z) {            return 'isosceles';        }        return 'scalene';    }}"}
{"task_id": "java/3", "content": "\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numberOfPairs(vector<vector<int>>& points) {\n        int n = points.size();\n        map<pair<int, int>, int> m;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (points[i][1] < points[j][1]) {\n                    m[{points[i][0], points[j][0]}]++;\n                }\n                else if (points[i][1] > points[j][1]) {\n                    m[{points[j][0], points[i][0]}]++;\n                }\n            }\n        }\n        int count = 0;\n        for (auto it = m.begin(); it != m.end(); ++it) {\n            count += it->second * (it->second - 1) / 2;\n        }\n        return count;\n    }\n};\n\n", "groundtruth": "class Solution {    public int numberOfPairs(int[][] points) {        int pairs = 0;        Arrays.sort(points, (a, b) -> {            if (a[0] != b[0]) {                return a[0] - b[0];            } else {                return b[1] - a[1];            }        });        int n = points.length;        for (int i = 0; i < n; i++) {            for (int j = i + 1; j < n; j++) {                if (points[i][1] >= points[j][1] && isGood(points, i, j)) {                    pairs++;                }            }        }        return pairs;    }    public boolean isGood(int[][] points, int index1, int index2) {        int n = points.length;        for (int i = 0; i < n; i++) {            if (i == index1 || i == index2) {                continue;            }            if (points[i][0] >= points[index1][0] && points[i][0] <= points[index2][0] && points[i][1] >= points[index2][1] && points[i][1] <= points[index1][1]) {                return false;            }        }        return true;    }}"}
{"task_id": "java/4", "content": "\n\n\n\n", "groundtruth": "class Solution {    public long maximumSubarraySum(int[] nums, int k) {        long ans = Long.MIN_VALUE;        long sum = 0;        Map<Integer, Long> minS = new HashMap<>();        for (int x : nums) {            long s1 = minS.getOrDefault(x - k, Long.MAX_VALUE / 2);            long s2 = minS.getOrDefault(x + k, Long.MAX_VALUE / 2);            ans = Math.max(ans, sum + x - Math.min(s1, s2));            minS.merge(x, sum, Math::min);            sum += x;        }        return ans > Long.MIN_VALUE / 4 ? ans : 0;    }}"}
{"task_id": "java/5", "content": "\nclass Solution {\n    public int numberOfSubstrings(String S) {\n        char[] s = S.toCharArray();\n        int n = s.length;\n        int m = 0;\n        int[] a = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                a[m++] = i;\n            }\n        }\n        int tot1 = n - m;\n        a[m] = n; // 哨兵\n        int tot0 = m;\n        int ans = 0;\n        int i = 0; // >= left 的第一个 0 的下标是 a[i]\n        for (int left = 0; left < n; left++) {\n            if (s[left] == '1') {\n                ans += a[i] - left; // 不含 0 的子串个数\n            }\n            for (int k = i; k < m; k++) {\n                int cnt0 = k - i + 1;\n                if (a[k] - left >= cnt0 * cnt0) {\n                    break;\n                }\n                int cnt1 = a[k] - left - (k - i);\n                ans += cnt0 * cnt1;\n            }\n            if (s[left] == '0') {\n                i++; // 这个 0 后面不会再枚举到了\n            }\n        }\n        return ans;\n    }\n}\n\n", "groundtruth": "class Solution {    public int numberOfSubstrings(String S) {        char[] s = S.toCharArray();        int n = s.length;        int m = 0;        int[] a = new int[n + 1];        for (int i = 0; i < n; i++) {            if (s[i] == '0') {                a[m++] = i;            }        }        int tot1 = n - m;        a[m] = n; // 哨兵        int ans = 0;        int i = 0; // >= left 的第一个 0 的下标是 a[i]        for (int left = 0; left < n; left++) {            if (s[left] == '1') {                ans += a[i] - left; // 不含 0 的子串个数            }            for (int k = i; k < m; k++) {                int cnt0 = k - i + 1;                if (cnt0 * cnt0 > tot1) {                    break;                }                int cnt1 = a[k] - left - (k - i);                ans += Math.max(a[k + 1] - a[k] - Math.max(cnt0 * cnt0 - cnt1, 0), 0);            }            if (s[left] == '0') {                i++; // 这个 0 后面不会再枚举到了            }        }        return ans;    }}"}
{"task_id": "java/6", "content": "\n", "groundtruth": "class Solution {\n    public boolean canReachCorner(int X, int Y, int[][] circles) {\n        boolean[] vis = new boolean[circles.length];\n        for (int i = 0; i < circles.length; i++) {\n            long x = circles[i][0], y = circles[i][1], r = circles[i][2];\n            if (inCircle(x, y, r, 0, 0) || // 圆 i 包含矩形左下角\n                inCircle(x, y, r, X, Y) || // 圆 i 包含矩形右上角\n                // 圆 i 是否与矩形上边界/左边界相交相切\n                !vis[i] && (x <= X && Math.abs(y - Y) <= r ||\n                            y <= Y && x <= r ||\n                            y > Y && inCircle(x, y, r, 0, Y)) && dfs(i, X, Y, circles, vis)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n    private boolean inCircle(long ox, long oy, long r, long x, long y) {\n        return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r;\n    }\n\n    private boolean dfs(int i, int X, int Y, int[][] circles, boolean[] vis) {\n        long x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];\n        // 圆 i 是否与矩形右边界/下边界相交相切\n        if (y1 <= Y && Math.abs(x1 - X) <= r1 ||\n            x1 <= X && y1 <= r1 ||\n            x1 > X && inCircle(x1, y1, r1, X, 0)) {\n            return true;\n        }\n        vis[i] = true;\n        for (int j = 0; j < circles.length; j++) {\n            long x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];\n            // 在两圆相交相切的前提下，点 A 是否严格在矩形内\n            if (!vis[j] &&\n                (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) &&\n                x1 * r2 + x2 * r1 < (r1 + r2) * X &&\n                y1 * r2 + y2 * r1 < (r1 + r2) * Y &&\n                dfs(j, X, Y, circles, vis)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/7", "content": "\nSolution:\n\nclass Solution {\n    public long flowerGame(int n, int m) {\n        long a = (long)n * (long)m / 2;\n        long b = ((long)m/2) * ((long)n-((long)n/2));\n        return a + b;\n    }\n}\n", "groundtruth": "class Solution {\n    public long flowerGame(int n, int m) {\n        long a = ((long)n/2) * ((long)m-((long)m/2));\n        long b = ((long)m/2) * ((long)n-((long)n/2));\n        return a + b;\n    }\n}\n"}
{"task_id": "java/8", "content": "\n\n\n", "groundtruth": "class Solution {\n    public int minOrAfterOperations(int[] nums, int k) {\n        int ans = 0;\n        int mask = 0;\n        for (int b = 29; b >= 0; b--) {\n            mask |= 1 << b;\n            int cnt = 0; // 操作次数\n            int and = -1; // -1 的二进制全为 1\n            for (int x : nums) {\n                and &= x & mask;\n                if (and != 0) {\n                    cnt++; // 合并 x，操作次数加一\n                } else {\n                    and = -1; // 准备合并下一段\n                }\n            }\n            if (cnt > k) {\n                ans |= 1 << b; // 答案的这个比特位必须是 1\n                mask ^= 1 << b; // 后面不考虑这个比特位\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/9", "content": "", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n        return result;\n    }\n}\n"}
{"task_id": "java/10", "content": "\n  \n\nSample Input 1:\nn = 2\nx = 2\ny = 3\n\nSample Output 1:\n[1, 2]\nExplanation:\n\n\n1:  2 3\n2:  3 1\n\nThe letters mapped by the key 1 are \"2\" and \"3\". The letters mapped by the key 2 are \"3\" and \"1\".\n\n\nThe following figure shows how to type the word \"233\" using the given keypad:\nWe need to push the key 2 twice to type \"2\", and we need to push the key 3 thrice to type \"3\".\n\n\nTherefore, the output is [1, 2].\n  \n\nSample Input 2:\nn = 4\nx = 4\ny = 3\n\nSample Output 2:\n[0, 1, 1, 2]\nExplanation:\n\n\n1:  4 2 3 1\n2:  3 1 4 2\n3:  1 4 2 3\n4:  2 3 1 4\n\nThe letters mapped by the key 1 are \"4\", \"2\", \"3\" and \"1\". The letters mapped by the key 2 are \"3\", \"1\", \"4\" and \"2\".\n\n\nThe following figure shows how to type the word \"4321\" using the given keypad:\nWe need to push the key 1 four times to type \"4\", and we need to push the key 2 thrice to type \"3\".\n\n\nTherefore, the output is [0, 1, 1, 2].\n\nSolution:\n\n\nimport java.lang.reflect.Array;\n\nclass Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        \n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w", "groundtruth": "class Solution {\n    public int[] countOfPairs(int n, int x, int y) {\n        int w[][] = new int[n + 1][n + 1];\n        int INF = Integer.MAX_VALUE / 2;\n        \n        //初始化 邻接矩阵。\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                w[i][j] = (i == j ? 0 : INF);\n\n        //额外的捷径的权值是1。但不能是自身到自身，因为自身到自身的权值本来就是0.\n        if (x != y) {\n            w[x][y] = 1;\n            w[y][x] = 1;\n        }\n\n        //建图，前后相邻 权值都是1。\n        for (int i = 1; i < n; i++) {\n            w[i][i + 1] = 1;\n            w[i + 1][i] = 1;\n        }\n\n        //佛洛依德算法\n        for (int p = 1; p <= n; p++)\n            for (int st = 1; st <= n; st++)\n                for (int end = 1; end <= n; end++)\n                    w[st][end] = Math.min(w[st][end], w[st][p] + w[p][end]);\n\n        //先用下标从0开始的数组来求结果。\n        int[] res = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (w[i][j] != INF)\n                    res[w[i][j]]++;\n\n        //最终再遍历一次把求得的结果放到 下标从1开始的result数组。\n        int[] result  = new int[n];\n        for (int i = 0; i < n; i++)\n            result[i] = res[i + 1];\n\n        return result;\n    }\n}\n"}
{"task_id": "java/11", "content": "\n\n\n\n\npackage q1177;\n\nclass Solution {\n    public boolean canSortArray(int[] nums) {\n        int lastCnt = 0;\n        int lastGroupMax = 0;\n        int curGroupMax = 0;\n        for (int num : nums) {\n            int curCnt = Integer.bitCount(num);\n            if (curCnt == lastCnt) {\n                curGroupMax = Math.max(curGroupMax, num);\n            } else {\n                lastCnt = curCnt;\n                lastGroupMax = curGroupMax;\n                curGroupMax = num;\n            }\n            if (num < lastGroupMax) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n", "groundtruth": "class Solution {\n    public boolean canSortArray(int[] nums) {\n        int lastCnt = 0;\n        int lastGroupMax = 0;\n        int curGroupMax = 0;\n        for (int num : nums) {\n            int curCnt = Integer.bitCount(num);\n            if (curCnt == lastCnt) {\n                curGroupMax = Math.max(curGroupMax, num);\n            } else {\n                lastCnt = curCnt;\n                lastGroupMax = curGroupMax;\n                curGroupMax = num;\n            }\n            if (num < lastGroupMax) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"task_id": "java/12", "content": "", "groundtruth": "class Solution {\n    public int minimumArrayLength(int[] nums) {\n        int m = Integer.MAX_VALUE;\n        for (int x : nums) {\n            m = Math.min(m, x);\n        }\n\n        for (int x : nums) {\n            if (x % m > 0) {\n                return 1;\n            }\n        }\n\n        int cnt = 0;\n        for (int x : nums) {\n            if (x == m) {\n                cnt++;\n            }\n        }\n        return (cnt + 1) / 2;\n    }\n}\n"}
{"task_id": "java/13", "content": "\n```java\n\nclass Solution {\n    public long minimumCost(int[] nums, int k, int dist) {\n        k--;\n        sumL = nums[0];\n        for (int i = 1; i < dist + 2; i++) {\n            sumL += nums[i];\n            L.merge(nums[i], 1, Integer::sum);\n        }\n        sizeL = dist + 1;\n        while (sizeL > k) {\n            l2r();\n        }\n\n        long ans = sumL;\n        for (int i = dist + 2; i < nums.length; i++) {\n            // 移除 out\n            int out = nums[i - dist - 1];\n            if (L.containsKey(out)) {\n                sumL -= out;\n                sizeL--;\n                removeOne(L, out);\n            } else {\n                removeOne(R, out);\n            }\n\n            // 添加 in\n            int in = nums[i];\n            if (in < L.lastKey()) {\n                sumL += in;\n                sizeL++;\n                L.merge(in, 1, Integer::sum);\n            } else {\n                R.merge(in, 1, Integer::sum);\n            }\n\n            // 维护大小\n            if (sizeL == k - 1) {\n                r2l();\n            } else if (sizeL == k + 1) {\n                l2r();\n            }\n\n            ans = Math.min(ans, sumL);\n        }\n        return ans;\n    }\n\n    private long sumL;\n    private int sizeL;\n    private final TreeMap<Integer, Integer> L = new TreeMap<>();\n    private final TreeMap<Integer, Integer> R = new TreeMap<>();\n\n    private void l2r() {\n        int x = L.lastKey();\n        removeOne(L, x);\n        sumL -= x;\n        sizeL--;\n        R.merge(x, 1, Integer::sum);\n    }\n\n    private void r2l() {\n        int x = R", "groundtruth": "class Solution {\n    public long minimumCost(int[] nums, int k, int dist) {\n        k--;\n        sumL = nums[0];\n        for (int i = 1; i < dist + 2; i++) {\n            sumL += nums[i];\n            L.merge(nums[i], 1, Integer::sum);\n        }\n        sizeL = dist + 1;\n        while (sizeL > k) {\n            l2r();\n        }\n\n        long ans = sumL;\n        for (int i = dist + 2; i < nums.length; i++) {\n            // 移除 out\n            int out = nums[i - dist - 1];\n            if (L.containsKey(out)) {\n                sumL -= out;\n                sizeL--;\n                removeOne(L, out);\n            } else {\n                removeOne(R, out);\n            }\n\n            // 添加 in\n            int in = nums[i];\n            if (in < L.lastKey()) {\n                sumL += in;\n                sizeL++;\n                L.merge(in, 1, Integer::sum);\n            } else {\n                R.merge(in, 1, Integer::sum);\n            }\n\n            // 维护大小\n            if (sizeL == k - 1) {\n                r2l();\n            } else if (sizeL == k + 1) {\n                l2r();\n            }\n\n            ans = Math.min(ans, sumL);\n        }\n        return ans;\n    }\n\n    private long sumL;\n    private int sizeL;\n    private final TreeMap<Integer, Integer> L = new TreeMap<>();\n    private final TreeMap<Integer, Integer> R = new TreeMap<>();\n\n    private void l2r() {\n        int x = L.lastKey();\n        removeOne(L, x);\n        sumL -= x;\n        sizeL--;\n        R.merge(x, 1, Integer::sum);\n    }\n\n    private void r2l() {\n        int x = R.firstKey();\n        removeOne(R, x);\n        sumL += x;\n        sizeL++;\n        L.merge(x, 1, Integer::sum);\n    }\n\n    private void removeOne(Map<Integer, Integer> m, int x) {\n        int cnt = m.get(x);\n        if (cnt > 1) {\n            m.put(x, cnt - 1);\n        } else {\n            m.remove(x);\n        }\n    }\n}\n"}
{"task_id": "java/14", "content": "\n", "groundtruth": "class Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        char[] text = s.toCharArray();\n        List<Integer> posA = kmp(text, a.toCharArray());\n        List<Integer> posB = kmp(text, b.toCharArray());\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i : posA) {\n            int bi = lowerBound(posB, i);\n            if (bi < posB.size() && posB.get(bi) - i <= k ||\n                bi > 0 && i - posB.get(bi - 1) <= k) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n\n    private List<Integer> kmp(char[] text, char[] pattern) {\n        int m = pattern.length;\n        int[] pi = new int[m];\n        int c = 0;\n        for (int i = 1; i < m; i++) {\n            char v = pattern[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            pi[i] = c;\n        }\n\n        List<Integer> res = new ArrayList<>();\n        c = 0;\n        for (int i = 0; i < text.length; i++) {\n            char v = text[i];\n            while (c > 0 && pattern[c] != v) {\n                c = pi[c - 1];\n            }\n            if (pattern[c] == v) {\n                c++;\n            }\n            if (c == m) {\n                res.add(i - m + 1);\n                c = pi[c - 1];\n            }\n        }\n        return res;\n    }\n\n    // 开区间写法\n    private int lowerBound(List<Integer> nums, int target) {\n        int left = -1, right = nums.size(); // 开区间 (left, right)\n        while (left + 1 < right) { // 区间不为空\n            // 循环不变量：\n            // nums[left] < target\n            // nums[right] >= target\n            int mid = (left + right) >>> 1;\n            if (nums.get(mid) < target) {\n                left = mid; // 范围缩小到 (mid, right)\n            } else {\n                right = mid; // 范围缩小到 (left, mid)\n            }\n        }\n        return right;\n    }\n}\n"}
{"task_id": "java/15", "content": "\npublic class Solution {\n    public long findMaximumNumber(long k, int x) {\n        this.x = x;\n        // 开区间二分，原理见 https://www.bilibili.com/video/BV1AP41137w7/\n        long left = 0;\n        long right = (k + 1) << x;\n        while (left + 1 < right) {\n            long mid = (left + right) >>> 1;\n            if (mid * (mid + 1) / 2 <= k) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    private int x;\n    private long num;\n    private long memo[][];\n\n    private long countDigitOne(long num) {\n        this.num = num;\n        int m = 64 - num;\n        memo = new long[m][m + 1];\n        for (long[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return dfs(m - 1, 0, true);\n    }\n\n    private long dfs(int i, int cnt1, boolean isLimit) {\n        if (i < 0) return cnt1;\n        if (!isLimit && memo[i][cnt1] != -1) return memo[i][cnt1];\n        int up = isLimit ? (int) (num >> i & 1) : 1;\n        long res = 0;\n        for (int d = 0; d <= up; d++) {\n            res += dfs(i - 1, cnt1 + (d == 1 && (i + 1) % x == 0 ? 1 : 0), isLimit && d == up);\n        }\n        if (!isLimit) memo[i][cnt1] = res;\n        return res;\n    }\n}\n", "groundtruth": "class Solution {\n    public long findMaximumNumber(long k, int x) {\n        this.x = x;\n        long left = 0;\n        long right = (k + 1) << x;\n        while (left + 1 < right) {\n            long mid = (left + right) >>> 1;\n            if (countDigitOne(mid) <= k) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    private int x;\n    private long num;\n    private long memo[][];\n\n    private long countDigitOne(long num) {\n        this.num = num;\n        int m = 64 - Long.numberOfLeadingZeros(num);\n        memo = new long[m][m + 1];\n        for (long[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return dfs(m - 1, 0, true);\n    }\n\n    private long dfs(int i, int cnt1, boolean isLimit) {\n        if (i < 0) return cnt1;\n        if (!isLimit && memo[i][cnt1] != -1) return memo[i][cnt1];\n        int up = isLimit ? (int) (num >> i & 1) : 1;\n        long res = 0;\n        for (int d = 0; d <= up; d++) {\n            res += dfs(i - 1, cnt1 + (d == 1 && (i + 1) % x == 0 ? 1 : 0), isLimit && d == up);\n        }\n        if (!isLimit) memo[i][cnt1] = res;\n        return res;\n    }\n}\n"}
{"task_id": "java/16", "content": "\n```\npublic class Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << (n - 1)) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}\n```", "groundtruth": "class Solution {\n    public List<String> validStrings(int n) {\n        List<String> ans = new ArrayList<>();\n        int mask = (1 << n) - 1;\n        for (int i = 0; i < (1 << n); i++) {\n            int x = mask ^ i;\n            if (((x >> 1) & x) == 0) {\n                ans.add(Integer.toBinaryString((1 << n) | i).substring(1));\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/17", "content": "\nSolution:\nclass Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] sum = new int[m + 1][n + 1][2];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1][0] = sum[i][j + 1][0] + sum[i + 1][j][0] - sum[i][j][0];\n                sum[i + 1][j + 1][1] = sum[i + 1][j][1] + sum[i][j + 1][1] - sum[i][j][1];\n                if (grid[i][j] != '.') {\n                    sum[i + 1][j + 1][grid[i][j] & 1]++;\n                }\n                if (sum[i + 1][j + 1][0] == sum[i + 1][j + 1][1]) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n", "groundtruth": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int ans = 0;\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][][] sum = new int[m + 1][n + 1][2];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1][0] = sum[i + 1][j][0] + sum[i][j + 1][0] - sum[i][j][0];\n                sum[i + 1][j + 1][1] = sum[i + 1][j][1] + sum[i][j + 1][1] - sum[i][j][1];\n                if (grid[i][j] != '.') {\n                    sum[i + 1][j + 1][grid[i][j] & 1]++;\n                }\n                if (sum[i + 1][j + 1][0] > 0 && sum[i + 1][j + 1][0] == sum[i + 1][j + 1][1]) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/18", "content": "```java\nclass Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n        char[] t = target.toCharArray();\n        int n = t.length;\n\n        final int MOD = 1_070_777_777;\n        final int BASE = (int) 8e8 + new Random().nextInt((int) 1e8); // 随机 base，防止 hack\n        int[] powBase = new int[n + 1]; // powBase[i] = base^i\n        int[] preHash = new int[n + 1]; // 前缀哈希值 preHash[i] = hash(target[0] 到 target[i-1])\n        powBase[0] = 1;\n        for (int i = 0; i < n; i++) {\n            powBase[i + 1] = (int) ((long) powBase[i] * BASE % MOD);\n            preHash[i + 1] = (int) (((long) preHash[i] * BASE + t[i]) % MOD);\n        }\n\n        Map<Integer, Map<Integer, Integer>> minCost = new TreeMap<>(); // 长度 -> 哈希值 -> 最小成本\n        for (int i = 0; i < words.length; i++) {\n            long h = 0;\n            for (char b : words[i].toCharArray()) {\n                h = (h * BASE + b) % MOD;\n            }\n            minCost.computeIfAbsent(words[i].length(), k -> new HashMap<>())\n                   .merge((int) h, costs[i], Integer::min);\n        }\n\n        int[] f = new int[n + 1];\n        Arrays.fill(f, Integer.MAX_VALUE / 2);\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (Map.Entry<Integer, Map<Integer, Integer>> e : minCost.entrySet()) {\n                int len = e.getKey", "groundtruth": "class Solution {\n    public int minimumCost(String target, String[] words, int[] costs) {\n        char[] t = target.toCharArray();\n        int n = t.length;\n\n        final int MOD = 1_070_777_777;\n        final int BASE = (int) 8e8 + new Random().nextInt((int) 1e8);\n        int[] powBase = new int[n + 1];\n        int[] preHash = new int[n + 1];\n        powBase[0] = 1;\n        for (int i = 0; i < n; i++) {\n            powBase[i + 1] = (int) ((long) powBase[i] * BASE % MOD);\n            preHash[i + 1] = (int) (((long) preHash[i] * BASE + t[i]) % MOD);\n        }\n\n        Map<Integer, Map<Integer, Integer>> minCost = new TreeMap<>();\n        for (int i = 0; i < words.length; i++) {\n            long h = 0;\n            for (char b : words[i].toCharArray()) {\n                h = (h * BASE + b) % MOD;\n            }\n            minCost.computeIfAbsent(words[i].length(), k -> new HashMap<>())\n                   .merge((int) h, costs[i], Integer::min);\n        }\n\n        int[] f = new int[n + 1];\n        Arrays.fill(f, Integer.MAX_VALUE / 2);\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (Map.Entry<Integer, Map<Integer, Integer>> e : minCost.entrySet()) {\n                int len = e.getKey();\n                if (len > i) {\n                    break;\n                }\n                int subHash = (int) (((preHash[i] - (long) preHash[i - len] * powBase[len]) % MOD + MOD) % MOD);\n                f[i] = Math.min(f[i], f[i - len] + e.getValue().getOrDefault(subHash, Integer.MAX_VALUE / 2));\n            }\n        }\n        return f[n] == Integer.MAX_VALUE / 2 ? -1 : f[n];\n    }\n}\n"}
{"task_id": "java/19", "content": "\n\n\n\n\npackage leetcode19;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n    ListNode(int x, ListNode next) { val = x; this.next = next; }\n}\n\nclass Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur.next.next; // 删除\n            } else {\n                cur = cur.next; // 向后移动\n            }\n        }\n        return dummy.next;\n    }\n}\n\n\n\n", "groundtruth": "class Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums.length); // 预分配空间\n        for (int x : nums) {\n            set.add(x);\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null) {\n            if (set.contains(cur.next.val)) {\n                cur.next = cur.next.next; // 删除\n            } else {\n                cur = cur.next; // 向后移动\n            }\n        }\n        return dummy.next;\n    }\n}\n"}
{"task_id": "java/20", "content": "\n\n\n\nAnswer: \\begin{code}\nclass Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        int[][][][] dp = new int[m][n][m][n];\n        for (int i1 = 0; i1 < m; i1++) {\n            for (int j1 = 0; j1 < n; j1++) {\n                for (int i2 = 0; i2 < m; i2++) {\n                    Arrays.fill(dp[i1][j1][i2], Integer.MAX_VALUE);\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][i][j] = 0;\n            }\n        }\n        for (int rowCount = 1; rowCount <= m; rowCount++) {\n            for (int colCount = 1; colCount <= n; colCount++) {\n                for (int i1 = 0, i2 = rowCount - 1; i2 < m; i1++, i2++) {\n                    for (int j1 = 0, j2 = colCount - 1; j2 < n; j1++, j2++) {\n                        for (int midRow = i1; midRow < i2; midRow++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], horizontalCut[midRow] + dp[i1][j1][midRow][j2] + dp[midRow + 1][j1][i2][j2]);\n                        }\n                        for (int midCol = j1; midCol < j2; midCol++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], verticalCut[midCol] + dp[i1][j1][i2][midCol] + dp[i1][", "groundtruth": "class Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        int[][][][] dp = new int[m][n][m][n];\n        for (int i1 = 0; i1 < m; i1++) {\n            for (int j1 = 0; j1 < n; j1++) {\n                for (int i2 = 0; i2 < m; i2++) {\n                    Arrays.fill(dp[i1][j1][i2], Integer.MAX_VALUE);\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][i][j] = 0;\n            }\n        }\n        for (int rowCount = 1; rowCount <= m; rowCount++) {\n            for (int colCount = 1; colCount <= n; colCount++) {\n                for (int i1 = 0, i2 = rowCount - 1; i2 < m; i1++, i2++) {\n                    for (int j1 = 0, j2 = colCount - 1; j2 < n; j1++, j2++) {\n                        for (int midRow = i1; midRow < i2; midRow++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], horizontalCut[midRow] + dp[i1][j1][midRow][j2] + dp[midRow + 1][j1][i2][j2]);\n                        }\n                        for (int midCol = j1; midCol < j2; midCol++) {\n                            dp[i1][j1][i2][j2] = Math.min(dp[i1][j1][i2][j2], verticalCut[midCol] + dp[i1][j1][i2][midCol] + dp[i1][midCol + 1][i2][j2]);\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][0][m - 1][n - 1];\n    }\n}\n"}
{"task_id": "java/21", "content": "\n", "groundtruth": "class Solution {\n    public boolean doesAliceWin(String s) {\n        for (char c : s.toCharArray()) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"task_id": "java/22", "content": "\n```\nclass Solution {\n    public int maxOperations(String s) {\n        char[] str = s.toCharArray();\n        int len = str.length;\n        int ans = 0;\n        int cnt1 = 0;\n        for(int i = 0; i < len; i++){\n            if(str[i] == '1')\n                cnt1++;\n            else if(i > 0 && str[i - 1] == '1')\n                ans += cnt1;\n        }\n        return ans;\n    }\n}\n```\n", "groundtruth": "class Solution {\n    public int maxOperations(String S) {\n        char[] s = S.toCharArray();\n        int ans = 0;\n        int cnt1 = 0;\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == '1') {\n                cnt1++;\n            } else if (i > 0 && s[i - 1] == '1') {\n                ans += cnt1;\n            }\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/23", "content": "\n\n\n\npackage q1201;\n\npublic class Solution {\n    public long minimumOperations(int[] nums, int[] target) {\n        long s = target[0] - nums[0];\n        long ans = Math.abs(s);\n        for (int i = 1; i < nums.length; i++) {\n            int k = (target[i] - target[i - 1]) - (nums[i] - nums[i - 1]);\n            if (k > 0) {\n                ans += s >= 0 ? k : Math.min(k - s, 0);\n            } else {\n                ans -= s <= 0 ? k : Math.min(k + s, 0);\n            }\n            s += k;\n        }\n        return ans;\n    }\n}\n", "groundtruth": "class Solution {\n    public long minimumOperations(int[] nums, int[] target) {\n        long s = target[0] - nums[0];\n        long ans = Math.abs(s);\n        for (int i = 1; i < nums.length; i++) {\n            int k = (target[i] - target[i - 1]) - (nums[i] - nums[i - 1]);\n            if (k > 0) {\n                ans += s >= 0 ? k : Math.max(k + s, 0);\n            } else {\n                ans -= s <= 0 ? k : Math.min(k + s, 0);\n            }\n            s += k;\n        }\n        return ans;\n    }\n}\n"}
{"task_id": "java/24", "content": "\n\nAnswer:\n\n\n\nclass Solution {\n    private static final int MX = 31622;\n    private static final int[] PI = new int[MX + 1];\n\n    static {\n        for (int i = 2; i <= MX; i++) {\n            if (PI[i] == 0) { // i 是质数\n                PI[i] = PI[i - 1] + 1;\n                for (int j = i * i; j <= MX; j += i) {\n                    PI[j] = -1; // 标记 i 的倍数为合数\n                }\n            } else {\n                PI[i] = PI[i - 1];\n            }\n        }\n    }\n\n    public int nonSpecialCount(int l, int r) {\n        int cnt = 0;\n        for (int i = l; i <= r; i++) {\n            if (PI[i] != 2) cnt++;\n        }\n        return cnt;\n    }\n}\n\n\n\n\n\n\n", "groundtruth": "class Solution {\n    private static final int MX = 31622;\n    private static final int[] PI = new int[MX + 1];\n\n    static {\n        for (int i = 2; i <= MX; i++) {\n            if (PI[i] == 0) { // i 是质数\n                PI[i] = PI[i - 1] + 1;\n                for (int j = i * i; j <= MX; j += i) {\n                    PI[j] = -1; // 标记 i 的倍数为合数\n                }\n            } else {\n                PI[i] = PI[i - 1];\n            }\n        }\n    }\n\n    public int nonSpecialCount(int l, int r) {\n        return r - l + 1 - (PI[(int) Math.sqrt(r)] - PI[(int) Math.sqrt(l - 1)]);\n    }\n}\n"}
{"task_id": "python/0", "content": "", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n    "}
{"task_id": "python/1", "content": "\nNote: The test cases are generated such that value is a valid index of the grid and that the sum of all elements is in the range of a 32-bit signed integer.\n\n\ndef __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n "}
{"task_id": "python/2", "content": "", "groundtruth": " DIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/3", "content": "\n\n```python\nfrom collections import deque\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[] for _ in range(n)]\n        vis = [-1] * n\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n```\n\n\n```python\n\n```\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n  "}
{"task_id": "python/4", "content": "", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/5", "content": "\n\n```\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [-1] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n```\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/6", "content": "", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/7", "content": "\n", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/8", "content": "", "groundtruth": " class Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/9", "content": "\nAnswer = \n\n[2, 3, 2]\n\nExplanation:\n\nQueries of the first type:\nqueries[i] = [1, sizei]\ndetermine the count of alternating groups with size sizei.\nqueries[0] = [1, 1], the count of alternating groups with size 1 is 2.\nqueries[1] = [1, 2], the count of alternating groups with size 2 is 3.\nqueries[2] = [1, 3], the count of alternating groups with size 3 is 2.\n\nQueries of the second type:\nqueries[i] = [2, indexi, colori],\nchange colors[indexi] to colori.\nqueries[0] = [2, 1, 0], the color of index 1 is changed from 0 to 1.\nqueries[1] = [2, 3, 1], the color of index 3 is changed from 1 to 0.\n", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/10", "content": "```\n\n```\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/11", "content": "\nNote: The answer is guaranteed to be in the range of 32-bit signed integer.", "groundtruth": " from sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/12", "content": "\nAnswer:\n class Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\n        double=0\n        for it in nums:\n            if it>=10: \n                double+=it\n            else:\n                single+=it\n        \n        return single !=double\n", "groundtruth": " class Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\n        double=0\n        for it in nums:\n            if it>=10: \n                double=double+it \n            else:\n                single=single+it  \n        \n        return single !=double\n "}
{"task_id": "python/13", "content": "\ndef pi_sieve(n):\n    prime_arr = [0] * (n + 1)\n    for i in range(2, n + 1):\n        if prime_arr[i] == 0:  # i is prime\n            prime_arr[i] = ______\n            for j in range(i, n + 1, i):\n                prime_arr[j] = -1  # mark i's multiples as composite\n    return prime_arr\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n"}
{"task_id": "python/14", "content": "\n\n# \n# @lc app=leetcode id=1954 lang=python3\n#\n# [1954] The Number of the Smallest Set of Unique Prime Factors\n#\n\n# @lc code=start\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        count = 0\n        for i in range(l, r + 1):\n            p, f = set(prime_factors(i)), 2\n            if len(p) != f:\n                count += 1\n        return count\n    \ndef prime_factors(n):\n    for i in range(2, n):\n        while n % i == 0:\n            yield i\n            n //= i\n    \n# @lc code=end\n\n", "groundtruth": " MX = 31622\npi = [0] * (MX + 1)\nfor i in range(2, MX + 1):\n    if pi[i] == 0:  # i 是质数\n        pi[i] = pi[i - 1] + 1\n        for j in range(i * i, MX + 1, i):\n            pi[j] = -1  # 标记 i 的倍数为合数\n    else:\n        pi[i] = pi[i - 1]\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        return r - l + 1 - (pi[isqrt(r)] - pi[isqrt(l - 1)])\n "}
{"task_id": "python/15", "content": "", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n "}
{"task_id": "python/16", "content": "", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/17", "content": "\n", "groundtruth": " class Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/18", "content": "", "groundtruth": " class Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n    "}
{"task_id": "python/19", "content": "", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/20", "content": "\n\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or                x1 <= X and y1 <= r1 or                x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and                    (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and                    x1 * r2 + x2 * r1 < (r1 + r2) * X and                    y1 * r2 + y2 * r1 < (r1 + r2) * Y and                    dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or                in_circle(x, y, r, X, Y) or                not vis[i] and (x <= X and abs(y - Y) <= r or                                y <= Y and x <= r or                                y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/21", "content": "\nThe code is as follows:\n\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[j][i] == 1:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] == 0:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n\n\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[j][i] == 0:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n\n", "groundtruth": "\nclass Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def check(i):\n            for j in range(n):\n                if i == j:\n                    continue\n                elif grid[i][j] == 1 and grid[j][i] == 0:\n                    continue\n                else:\n                    return False\n            return True\n        n = len(grid)\n        for i in range(n):\n            if check(i):\n                return i\n"}
{"task_id": "python/22", "content": "\n\n\n\ndef dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n    count = 1\n    visited[start] = True\n    next_nodes = graph[start]\n    for next_node in next_nodes:\n        if not visited[next_node]:\n            count += self.dfs(graph, next_node, visited)\n    return count\n\ndef findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for i in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n\n\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/23", "content": "\n\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n", "groundtruth": "\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/24", "content": "\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1, nums[u])\n            \n        return dfs(0)[1]", "groundtruth": "\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/25", "content": "\nNote: The code for BIT is already complete. Only complete the incomplete code.\n\nSample Case:\n\nSolution().maxBalancedSubsequenceSum(nums = [2,1,2,3,4,5,2,2,2,4]) \n// Output: 9\n\n// Explanation: The subsequence is [2,2,2,4] and is balanced.\n", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/26", "content": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1  \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))  \n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/27", "content": "", "groundtruth": "\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/28", "content": "\nNote:\n\nThe standard bitwise OR operation is defined as a binary operator on integers, and the result is the bitwise inclusive OR of the bit patterns of the operands. For example,\n\n3 = 0b11\n\n5 = 0b101\n\n3 | 5 = 0b111\n\n\n\n\n\n\n", "groundtruth": "\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/29", "content": "\n\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum1 == 0\n        zero2 = sum2 == 0\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/30", "content": "\n\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n        \n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: \n                return sum1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: \n                return sum2\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: \n            return sum1 + zero1\n        return sum1 + zero1\n\n\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n        \n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: \n                return sum1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: \n                return sum2\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: \n            return sum1 + zero1\n        return sum1 + zero1\n\n\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num", "groundtruth": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n"}
{"task_id": "python/31", "content": "", "groundtruth": "\nclass Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/32", "content": "\n\n\n\n", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/33", "content": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = 0\n            res2 = 0\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i)  \n                    if j < 13:  \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n", "groundtruth": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/34", "content": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i)\n                    if j < 13:\n                        res2 += dfs(ch, j + 1, i)\n            return max(res1, res2)\n\n        return dfs(0, 0, -1)", "groundtruth": " class Solution:     def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:         g = [[] for _ in coins]         for x, y in edges:             g[x].append(y)             g[y].append(x)         @cache         def dfs(i: int, j: int, fa: int) -> int:             res1 = (coins[i] >> j) - k             res2 = coins[i] >> (j + 1)             for ch in g[i]:                 if ch != fa:                     res1 += dfs(ch, j, i)                      if j < 13:                          res2 += dfs(ch, j + 1, i)              return max(res1, res2)         return dfs(0, 0, -1) "}
{"task_id": "python/35", "content": "def sumCounts(self, nums: List[int]) -> int:\n    n = len(nums)\n    sum = [0] * (n * 4)\n    todo = [0] * (n * 4)\n\n    def do(o: int, l: int, r: int, add: int) -> None:\n        sum[o] += add * (r - l + 1)\n        todo[o] += add\n\n    # o=1  [l,r] 1<=l<=r<=n\n    # 把 [L,R] 加一，同时返回加一之前的区间和\n    def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n        if L <= l and r <= R:\n            res = sum[o]\n            do(o, l, r, 1)\n            return res\n        m = (l + r) // 2\n        add = todo[o]\n        if add:\n            do(o * 2, l, m, add)\n            do(o * 2 + 1, m + 1, r, add)\n            todo[o] = 0\n        res = 0\n        if L <= m:\n            res += query_and_add1(o * 2, l, m, L, R)\n        if m < R:\n            res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n        sum[o] = sum[o * 2] + sum[o * 2 + 1]\n        return res\n\n    ans = s = 0\n    last = {}\n    for i, x in enumerate(nums, 1):\n        j = last.get(x, 0)\n        s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n        ans += s\n        last[x] = i\n    return ans % 1_000_000_007\n\n\n# You are given an array representing a", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/36", "content": "\n\n\n\n# You are given a 0-indexed integer array nums. The distinct count of a subarray of nums is defined as: Let nums[i..j] be a subarray of nums consisting of all the indices from i to j such that 0 <= i <= j < nums.length. Then the number of distinct values in nums[i..j] is called the distinct count of nums[i..j]. Return the sum of the squares of distinct counts of all subarrays of nums. A subarray is a contiguous non-empty sequence of elements within an array.\n# \n# \n# \n# Example 1:\n# \n# Input: nums = [1,2,3]\n# Output: 45\n# Explanation: The distinct counts of the subarrays are:\n# [1]: Distinct counts = 1. [2]: Distinct counts = 2. [3]: Distinct counts = 3. [1,2]: Distinct counts = 2. [2,3]: Distinct counts = 2. [1,2,3]: Distinct counts = 3.\n# Therefore, the sum of the squares of the distinct counts is: 1^2 + 2^2 + 3^2 + 2^2 + 2^2 + 3^2 = 45.\n# Example 2:\n# \n# Input: nums = [2,3,3,2]\n# Output: 44\n# Explanation: The distinct counts of the subarrays are:\n# [2]: Distinct counts = 1. [3]: Distinct counts = 2. [3]: Distinct counts = 2. [2]: Distinct counts = 1. [2,3]: Distinct counts = 2. [3,3]: Distinct counts = 1. [2,3,3]: Distinct counts = 2. [3,3,2]: Distinct counts = 2. [2,3,3,2]: Distinct counts = 3.\n# Therefore, the sum of the squares of the distinct counts is: 1^2 + 2^2 + 2^2 + 1^2 + 2^2 + 1^2 + ", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/37", "content": "", "groundtruth": " class Solution:     def sumCounts(self, nums: List[int]) -> int:         n = len(nums)         sum = [0] * (n * 4)         todo = [0] * (n * 4)         def do(o: int, l: int, r: int, add: int) -> None:             sum[o] += add * (r - l + 1)             todo[o] += add         # o=1  [l,r] 1<=l<=r<=n         # 把 [L,R] 加一，同时返回加一之前的区间和         def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:             if L <= l and r <= R:                 res = sum[o]                 do(o, l, r, 1)                 return res             m = (l + r) // 2             add = todo[o]             if add:                 do(o * 2, l, m, add)                 do(o * 2 + 1, m + 1, r, add)                 todo[o] = 0             res = 0             if L <= m: res += query_and_add1(o * 2, l, m, L, R)             if m < R: res += query_and_add1(o * 2 + 1, m + 1, r, L, R)             sum[o] = sum[o * 2] + sum[o * 2 + 1]             return res         ans = s = 0         last = {}         for i, x in enumerate(nums, 1):             j = last.get(x, 0)             s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j             ans += s             last[x] = i         return ans % 1_000_000_007 "}
{"task_id": "python/38", "content": "\n\n```python\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        cnt = 0\n        for i in range(0, len(s), 2):\n            if (s[i] != s[i+1]):\n                cnt += 1\n        return cnt\n```\n\n\n```python\n\n```\n", "groundtruth": " class Solution:     def minChanges(self, s: str) -> int:         cnt = 0         for i in range(0, len(s), 2):             if len(set(s[i:i + 2])) > 1:                 cnt += 1                 print(s)         return cnt "}
{"task_id": "python/39", "content": "\n", "groundtruth": " class Solution:     def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:         f = [0] + [-inf] * target         s = 0         for x in nums:             s = min(s + x, target)             for j in range(s, x - 1, -1):                 # f[j] = max(f[j], f[j - x] + 1)                 if f[j] < f[j - x] + 1:                     f[j] = f[j - x] + 1         return f[-1] if f[-1] > 0 else -1 "}
{"task_id": "python/40", "content": "\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nint main(){\n  ll mod=1000000007;\n  ll n,m,x;\n  cin>>n>>m>>x;\n  ll vf[n],hf[m];\n  for(ll i=0;i<n;i++){\n      cin>>vf[i];\n  }\n  for(ll i=0;i<m;i++){\n      cin>>hf[i];\n  }\n  \n  ll i=0;\n  ll j=0;\n  sort(hf,hf+m);\n  sort(vf,vf+n);\n  ll res=0;\n  while(i<n && j<m){\n      if(vf[i]<=hf[j]){\n          i++;\n      }\n      else{\n          j++;\n      }\n      res++;\n  }\n  cout<<res*res<<\" \"<<x;\n  \n  \n}\n", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/41", "content": "", "groundtruth": " class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         h = self.f(hFences, m)         v = self.f(vFences, n)         ans = max(h & v, default=0)         return ans ** 2 % 1_000_000_007 if ans else -1      def f(self, a: List[int], mx: int) -> Set[int]:         a.extend([1, mx])         a.sort()         return set(y - x for x, y in combinations(a, 2)) "}
{"task_id": "python/42", "content": "\n  \n  class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1\n\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/43", "content": "", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)          for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/44", "content": "", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         dis = [[inf] * 26 for _ in range(26)]         for i in range(26):             dis[i][i] = 0          for x, y, c in zip(original, changed, cost):             x = ord(x) - ord('a')             y = ord(y) - ord('a')             dis[x][y] = min(dis[x][y], c)         for k in range(26):             for i in range(26):                 for j in range(26):                     dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))         return ans if ans < inf else -1 "}
{"task_id": "python/45", "content": "", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                      continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/46", "content": "\n#[Puzzle 2]\nGiven the head of a linked list, reverse the list, and return the reversed list.\n\nExample 1:\n\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\nExample 2:\n\nInput: head = [1,2]\nOutput: [2,1]\nExample 3:\n\nInput: head = []\nOutput: []\n  \n#[Puzzle 3]\nGiven an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.\n\nThe value of |x| is defined as:\n\nx if x >= 0.\n-x if x < 0.\n\nExample 1:\n\nInput: nums = [1,2,2,1], k = 1\nOutput: 4\nExplanation: The pairs with an absolute difference of 1 are:\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]\n\nclass Solution:     def countKDifference(self, nums: List[int], k: int) -> int:         count = 0         for i in range(len(nums)):             for j in range(i + 1, len(nums)):                 if abs(nums[i] - nums[j]) == k:                     count += 1         return count\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/47", "content": "\nThe correct answer is as follows:\n```py\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)\n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:\n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1)\n            for size, strs in len_to_strs.items():\n                if i < size:\n                    continue\n                s = source[i - size:i]\n                t = target[i - size:i]\n                if s in strs and t in strs:\n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(target))\n        return ans if ans < inf else -1\n```\n", "groundtruth": " class Solution:     def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:         len_to_strs = defaultdict(set)         dis = defaultdict(lambda: defaultdict(lambda: inf))         for x, y, c in zip(original, changed, cost):             len_to_strs[len(x)].add(x)              len_to_strs[len(y)].add(y)             dis[x][y] = min(dis[x][y], c)             dis[x][x] = 0             dis[y][y] = 0         for strs in len_to_strs.values():             for k in strs:                 for i in strs:                     if dis[i][k] == inf:                       continue                     for j in strs:                         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])          @cache         def dfs(i: int) -> int:             if i == 0:                 return 0             res = inf             if source[i - 1] == target[i - 1]:                 res = dfs(i - 1)              for size, strs in len_to_strs.items():                  if i < size:                     continue                 s = source[i - size: i]                 t = target[i - size: i]                 if s in strs and t in strs:                   res = min(res, dis[s][t] + dfs(i - size))             return res         ans = dfs(len(source))         return ans if ans < inf else -1 "}
{"task_id": "python/48", "content": "\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/49", "content": "\n\n# -*- coding: utf-8 -*-\nclass NeighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n    \n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n    \n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n", "groundtruth": "\nDIRS = ((-1, 0), (1, 0), (0, -1), (0, 1), (1, 1), (-1, 1), (-1, -1), (1, -1))\n\nclass neighborSum:\n    def __init__(self, grid: List[List[int]]):\n        n = len(grid)\n        s = [[0, 0] for _ in range(n * n)]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                for k, (dx, dy) in enumerate(DIRS):\n                    x, y = i + dx, j + dy\n                    if 0 <= x < n and 0 <= y < n:\n                        s[v][k // 4] += grid[x][y]\n        self.s = s\n\n    def adjacentSum(self, value: int) -> int:\n        return self.s[value][0]\n\n    def diagonalSum(self, value: int) -> int:\n        return self.s[value][1]\n  "}
{"task_id": "python/50", "content": "", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        g = [[i + 1] for i in range(n - 1)]\n        vis = [-1] * (n - 1)\n\n        def bfs(i: int) -> int:\n            q = deque([0])\n            for step in count(1):\n                tmp = q\n                q = []\n                for x in tmp:\n                    for y in g[x]:\n                        if y == n - 1:\n                            return step\n                        if vis[y] != i:\n                            vis[y] = i\n                            q.append(y)\n            return -1\n\n        ans = [0] * len(queries)\n        for i, (l, r) in enumerate(queries):\n            g[l].append(r)\n            ans[i] = bfs(i)\n        return ans\n "}
{"task_id": "python/51", "content": "\nNote: The length of queries is in the range [1, 105].\nThe integer n is in the range [2, 105].\nn == queries.length\n1 <= ui, vi <= n - 1\nui != vi\nThe initial graph has no edges.\nThere are no duplicate queries.\n", "groundtruth": "\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        fa = list(range(n - 1))\n\n        # 非递归并查集\n        def find(x: int) -> int:\n            rt = x\n            while fa[rt] != rt:\n                rt = fa[rt]\n            while fa[x] != rt:\n                fa[x], x = rt, fa[x]\n            return rt\n\n        ans = []\n        cnt = n - 1  # 并查集连通块个数\n        for l, r in queries:\n            fr = find(r - 1)\n            i = find(l)\n            while i < r - 1:\n                cnt -= 1\n                fa[i] = fr\n                i = find(i + 1)\n            ans.append(cnt)\n        return ans\n "}
{"task_id": "python/52", "content": "", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/53", "content": "", "groundtruth": "\nfrom sortedcontainers import SortedList\n\nclass FenwickTree:\n    def __init__(self, n: int):\n        self.t = [[0, 0] for _ in range(n + 1)]\n\n    # op=1，添加一个 size\n    # op=-1，移除一个 size\n    def update(self, size: int, op: int) -> None:\n        i = len(self.t) - size\n        while i < len(self.t):\n            self.t[i][0] += op\n            self.t[i][1] += op * size\n            i += i & -i\n\n    # 返回 >= size 的元素个数，元素和\n    def query(self, size: int) -> (int, int):\n        cnt = s = 0\n        i = len(self.t) - size\n        while i > 0:\n            cnt += self.t[i][0]\n            s += self.t[i][1]\n            i &= i - 1\n        return cnt, s\n\nclass Solution:\n    def numberOfAlternatingGroups(self, a: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(a)\n        sl = SortedList()\n        t = FenwickTree(n)\n\n        # op=1，添加一个结束位置 i\n        # op=-1，移除一个结束位置 i\n        def update(i: int, op: int) -> None:\n            idx = sl.bisect_left(i)\n            pre = sl[idx - 1]\n            nxt = sl[idx % len(sl)]\n\n            t.update((nxt - pre - 1) % n + 1, -op)  # 移除/添加旧长度\n            t.update((i - pre) % n, op)\n            t.update((nxt - i) % n, op)  # 添加/移除新长度\n\n        # 添加一个结束位置 i\n        def add(i: int) -> None:\n            if not sl:\n                t.update(n, 1)\n            else:\n                update(i, 1)\n            sl.add(i)\n\n        # 移除一个结束位置 i\n        def remove(i: int) -> None:\n            sl.remove(i)\n            if not sl:\n                t.update(n, -1)\n            else:\n                update(i, -1)\n\n        for i, c in enumerate(a):\n            if c == a[(i + 1) % n]:\n                add(i)  # i 是一个结束位置\n\n        ans = []\n        for q in queries:\n            if q[0] == 1:\n                if not sl:\n                    ans.append(n)  # 每个长为 size 的子数组都符合要求\n                else:\n                    cnt, s = t.query(q[1])\n                    ans.append(s - cnt * (q[1] - 1))\n            else:\n                i, c = q[1], q[2]\n                if a[i] == c:  # 无影响\n                    continue\n                pre, nxt = (i - 1) % n, (i + 1) % n\n                # 修改前，先去掉结束位置\n                if a[pre] == a[i]:\n                    remove(pre)\n                if a[i] == a[nxt]:\n                    remove(i)\n                a[i] = c\n                # 修改后，添加新的结束位置\n                if a[pre] == a[i]:\n                    add(pre)\n                if a[i] == a[nxt]:\n                    add(i)\n        return ans\n "}
{"task_id": "python/54", "content": "\n#Input: nums = [1,2,3]\n#Output: true\n#Explanation: Alice can choose to play with only the number 1, and the sum of Bob's numbers is 1 + 2 + 3 = 6.\n#If Alice chose numbers 2 or 3, the sum would be 2 + 3 = 5 and Alice would lose.\n#Therefore, Alice can win by choosing numbers 1.\n\n\n\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        memo = {}\n        def dfs(index, cache):\n            if index == len(nums): return False\n            if (index, cache) in memo: return memo[(index, cache)]\n            take = False\n            for i in range(index, len(nums)):\n                if nums[i] <= cache: continue\n                take |= not dfs(i + 1, nums[i])\n                if take: break\n            memo[(index, cache)] = take\n            return take\n        return dfs(0, 0)\n", "groundtruth": "\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single=0\ndouble=0\nfor it in nums:\nif it>=10: \ndouble=double+it \nelse:\nsingle=single+it  \n        \nreturn single !=double\n "}
{"task_id": "python/55", "content": "\nExample:\nInput: s = \"011000110\"\nOutput: 6\nExplanation: The 6 substrings with dominant ones are \"011000110\", \"011000110\", \"011000110\", \"011000110\", \"011000110\", \"011000110\".\n\n\n```\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        zero = 0\n        one = 0\n        count = 0\n        for i in range(len(s)):\n            if s[i] == '0':\n                zero += 1\n            else:\n                one += 1\n            while zero * zero <= one * one:\n                if s[count] == '0':\n                    zero -= 1\n                else:\n                    one -= 1\n                count += 1\n        return len(s) - count\n\n```\n\n", "groundtruth": "\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        a = [i for i, b in enumerate(s) if b == '0']\n        tot1 = n - len(a)\n        a.append(n)  # 哨兵\n        ans = i = 0  # >= left 的第一个 0 的下标是 a[i]\n        for left, b in enumerate(s):\n            if b == '1':\n                ans += a[i] - left  # 不含 0 的子串个数\n            for k in range(i, len(a) - 1):\n                cnt0 = k - i + 1\n                if cnt0 * cnt0 > tot1:\n                    break\n                cnt1 = a[k] - left - (k - i)\n                # 可以改成手动比大小，那样更快\n                ans += max(a[k + 1] - a[k] - max(cnt0 * cnt0 - cnt1, 0), 0)\n            if b == '0':\n                i += 1  # 这个 0 后面不会再枚举到了\n        return ans\n    "}
{"task_id": "python/56", "content": "\n", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/57", "content": "```\ndef canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            if i == len(circles):\n                return True\n            for j in range(len(circles)):\n                if vis[j] or in_circle(circles[j][0], circles[j][1], circles[j][2], 0, 0):\n                    continue\n                vis[j] = True\n                if dfs(i + 1):\n                    return True\n                vis[j] = False\n            return False\n\n        return dfs(0)\n```\n", "groundtruth": "\nclass Solution:\n    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:\n        # 判断点 (x,y) 是否在圆 (ox,oy,r) 内\n        def in_circle(ox: int, oy: int, r: int, x: int, y: int) -> bool:\n            return (ox - x) * (ox - x) + (oy - y) * (oy - y) <= r * r\n\n        vis = [False] * len(circles)\n        def dfs(i: int) -> bool:\n            x1, y1, r1 = circles[i]\n            # 圆 i 是否与矩形右边界/下边界相交相切\n            if y1 <= Y and abs(x1 - X) <= r1 or \\\n               x1 <= X and y1 <= r1 or \\\n               x1 > X and in_circle(x1, y1, r1, X, 0):\n                return True\n            vis[i] = True\n            for j, (x2, y2, r2) in enumerate(circles):\n                # 在两圆相交相切的前提下，点 A 是否严格在矩形内\n                if not vis[j] and \\\n                   (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (r1 + r2) * (r1 + r2) and \\\n                   x1 * r2 + x2 * r1 < (r1 + r2) * X and \\\n                   y1 * r2 + y2 * r1 < (r1 + r2) * Y and \\\n                   dfs(j):\n                    return True\n            return False\n\n        for i, (x, y, r) in enumerate(circles):\n            # 圆 i 包含矩形左下角 or\n            # 圆 i 包含矩形右上角 or\n            # 圆 i 与矩形上边界/左边界相交相切\n            if in_circle(x, y, r, 0, 0) or \\\n               in_circle(x, y, r, X, Y) or \\\n               not vis[i] and (x <= X and abs(y - Y) <= r or\n                               y <= Y and x <= r or\n                               y > Y and in_circle(x, y, r, 0, Y)) and dfs(i):\n                return False\n        return True\n "}
{"task_id": "python/58", "content": "\n#\n# @lc app=leetcode id=1785 lang=python3\n#\n# [1785] Minimum Elements to Add to Form a Given Sum\n#\n\n# @lc code=start\nclass Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        if visited[start]:\n            return 0\n        visited[start] = True\n        count = 1\n        for neighbor in graph[start]:\n            count += self.dfs(graph, neighbor, visited)\n        return count\n# @lc code=end\n", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/59", "content": "\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <stack>\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int findChampion(int n, vector<vector<int>> &edges)\n    {\n        vector<vector<int>> graph(n);\n        for (auto edge : edges)\n        {\n            graph[edge[0]].push_back(edge[1]);\n        }\n        vector<bool> visited(n, false);\n        for (int i = 0; i < n; i++)\n        {\n            if (!visited[i])\n            {\n                int res = dfs(graph, i, visited);\n                if (res == -1)\n                    return -1;\n            }\n        }\n        for (int i = 0; i < n; i++)\n            if (!visited[i])\n                return i;\n        return -1;\n    }\n\n    int dfs(vector<vector<int>> &graph, int start, vector<bool> &visited)\n    {\n        visited[start] = true;\n        for (int i = 0; i < graph[start].size(); i++)\n        {\n            if (!visited[graph[start][i]])\n            {\n                int res = dfs(graph, graph[start][i], visited);\n                if (res == -1)\n                    return -1;\n            }\n        }\n        for (int i = 0; i < n; i++)\n        {\n            if (!visited[i])\n                return -1;\n        }\n        return start;\n    }\n};\n", "groundtruth": "class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        \n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n        for i in range(n):\n            \n            visited = [False] * n\n            count = self.dfs(graph, i, visited)\n            \n            if count == n:\n                return i\n        return -1\n\n    def dfs(self, graph: List[List[int]], start: int, visited: List[bool]):\n        count = 1\n        visited[start] = True\n        next_nodes = graph[start]\n        for next_node in next_nodes:\n            if not visited[next_node]:\n                count += self.dfs(graph, next_node, visited)\n        return count\n"}
{"task_id": "python/60", "content": "\ndef dfs(u, p = -1):\n            s, t = 0, 0\n            for v in path[u]:\n                if v == p: continue\n                ____, ____\n            return s, t\n", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/61", "content": "\n\n\nclass Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        ____\n        \n        def dfs(u, p = -1):\n            res, s = 0, 0\n            for v, w in edges[u]:\n                if v == p: continue\n                ____\n                    \n                res += w\n                s |= dfs(v, u)[1]\n            res -= max(s, 0)\n            return ____, res + max(0, s)\n        return dfs(0)[1]\n\n\n", "groundtruth": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], nums: List[int]) -> int:\n        n = len(nums)\n        path = [[] for _ in range(n)]\n        for u, v in edges:\n            path[u].append(v)\n            path[v].append(u)\n        \n        def dfs(u, p = -1):\n            dp0, dp1 = 0, 0\n            f = 0\n            for v in path[u]:\n                if v != p:\n                    v0, v1 = dfs(v, u)\n                    dp0 += v0\n                    dp1 += v1\n                    f = 1\n            if not f: return nums[u], 0\n            return dp0 + nums[u], max(dp1 + nums[u], dp0)\n            \n        return dfs(0)[1]\n"}
{"task_id": "python/62", "content": "", "groundtruth": "class Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        b = sorted(set(x - i for i, x in enumerate(nums)))  \n        t = BIT(len(b) + 1)\n        for i, x in enumerate(nums):\n            j = bisect_left(b, x - i) + 1 \n            f = max(t.pre_max(j), 0) + x\n            t.update(j, f)\n        return t.pre_max(len(b))\n\nclass BIT:\n    def __init__(self, n: int):\n        self.tree = [-inf] * n\n\n    def update(self, i: int, val: int) -> None:\n        while i < len(self.tree):\n            self.tree[i] = max(self.tree[i], val)\n            i += i & -i\n\n    def pre_max(self, i: int) -> int:\n        mx = -inf\n        while i > 0:\n            mx = max(mx, self.tree[i])\n            i &= i - 1\n        return mx\n"}
{"task_id": "python/63", "content": "\nExample 1:\nInput: nums = [0,1,2,3,4], k = 2\nOutput: 7\nExplanation: The 7 bits are set as follows:\n- 0-or of 0 and 1 is 0. 0-or of 0 and 2 is 0. 0-or of 0 and 3 is 0. 0-or of 0 and 4 is 0.\n- 1-or of 0 and 1 is 1. 1-or of 1 and 2 is 1. 1-or of 1 and 3 is 1. 1-or of 1 and 4 is 1.\n- 2-or of 0 and 2 is 0. 2-or of 1 and 2 is 1. 2-or of 2 and 3 is 1. 2-or of 2 and 4 is 1.\n- 3-or of 0 and 3 is 0. 3-or of 1 and 3 is 1. 3-or of 2 and 3 is 1. 3-or of 3 and 4 is 1.\n- 4-or of 0 and 4 is 0. 4-or of 1 and 4 is 1. 4-or of 2 and 4 is 1. 4-or of 3 and 4 is 1.\nExample 2:\nInput: nums = [0,1,2,3,4], k = 3\nOutput: 3\nExplanation: The 3 bits are set as follows:\n- 0-or of 0 and 1 is 0. 0-or of 0 and 2 is 0. 0-or of 0 and 3 is 0. 0-or of 0 and 4 is 0.\n- 1-or of 0 and 1 is 1. 1-or of 1 and 2 is 1. 1-or of 1 and 3 is 1. 1-or of 1 and 4 is 1.\n- 2-or of 0 and 2 is 0.", "groundtruth": "class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 0\n        for i in range(max(nums).bit_length()):\n            cnt1 = sum(x >> i & 1 for x in nums)\n            if cnt1 >= k:\n                ans |= 1 << i\n        return ans\n"}
{"task_id": "python/64", "content": "\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n        return sum1 + sum2 if zero1 == zero2 else -1\n\n\nTime Complexity: O(N)\nSpace Complexity: O(1)", "groundtruth": "class Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = sum(nums1), sum(nums2)\n        zero1 = sum(1 for num in nums1 if num == 0)\n        zero2 = sum(1 for num in nums2 if num == 0)\n\n        if zero1 == 0 and zero2 == 0: return sum1 if sum1 == sum2 else -1\n\n        if zero1 == 0:\n            if sum1 < sum2 + zero2: return -1\n            else: return sum1\n\n        if zero2 == 0:\n            if sum1 + zero1 > sum2: return -1\n            else: return sum2\n\n        if sum1 + zero1 < sum2 + zero2: return sum2 + zero2\n        return sum1 + zero1\n\n"}
{"task_id": "python/65", "content": "*/\n\n/*\nExample 1:\nInput: nums = [2,4,1], k = 3\nOutput: 2\nExplanation: By increasing nums[0] by 1 and nums[2] by 1, the array becomes [3,4,2]. Now, nums is beautiful. \nExample 2:\nInput: nums = [1,3,5,7], k = 2\nOutput: 2\nExplanation: By increasing nums[0] by 1 and nums[1] by 1, the array becomes [2,4,5,7]. Now, nums is beautiful. \n*/\n\n// METHOD - 1 Using 3 loops and 1-D vector\n\nclass Solution {\npublic:\n    int minIncrementForPalindrome(string s) {\n        int n = s.size();\n        int cnt = 0;\n        \n        for(int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                if(s[i] == s[j]) cnt++;\n            }\n        }\n        \n        return cnt;\n    }\n};\n\n// METHOD - 2 Using 2 loops and 2-D vector\n\nclass Solution {\npublic:\n    int minIncrementForPalindrome(string s) {\n        int n = s.size();\n        int dp[n][26];\n        memset(dp, 0, sizeof(dp));\n        \n        for(int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                dp[i][s[i] - 'a']++;\n            }\n        }\n        \n        int cnt = 0;\n        for(int i = 0; i < 26; i++) {\n            for(int j = 0; j < n; j++) {\n                if(dp[j][i] > 1) {\n                    cnt += dp[j][i] - 1;\n                }\n            }\n        }\n        \n", "groundtruth": "class Solution:\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        dp1 = dp2 = dp3 = 0\n        for num in nums:\n            dp1, dp2, dp3 = min(dp1, dp2, dp3) + max(0, k - num), dp1, dp2\n        return min(dp1, dp2, dp3)\n"}
{"task_id": "python/66", "content": "\nclass Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            if j == len(g[i]):\n                return coins[i]\n            return max(\n                coins[i] + dfs(g[i][j], 0, i),\n                dfs(g[i][j], j + 1, i) + max(coins[i] - k, 0),\n                dfs(g[i][j], j + 1, i) + coins[i] // 2\n            )\n        \n        return dfs(0, 0, -1)\n\n", "groundtruth": "class Solution:\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        g = [[] for _ in coins]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        @cache\n        def dfs(i: int, j: int, fa: int) -> int:\n            res1 = (coins[i] >> j) - k\n            res2 = coins[i] >> (j + 1)\n            for ch in g[i]:\n                if ch != fa:\n                    res1 += dfs(ch, j, i) \n                    if j < 13: \n                        res2 += dfs(ch, j + 1, i)  \n            return max(res1, res2)\n        return dfs(0, 0, -1)\n"}
{"task_id": "python/67", "content": "", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/68", "content": "```\n\n\n\n```python\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if (l > r) or (L > R): return 0\n            m = (l + r) // 2\n            m1 = (L + R) // 2\n            if (L <= m) and (m1 <= R): return query_and_add1(o * 2, l, m, L, m1) + query_and_add1(o * 2 + 1, m + 1, r, L, m1)\n            if (L > m) and (m1 <= R): return query_and_add1(o * 2 + 1, m + 1, r, L, m1)\n            if (L <= m) and (m1 > R): return query_and_add1(o * 2, l, m, L, R)\n            return 0\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 减一，同时返回减一之前的区间和\n        def query_and_sub1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if (l > r) or (L > R): return 0\n            m = (l + r) // 2\n            m1 = (L", "groundtruth": "\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = [0] * (n * 4)\n        todo = [0] * (n * 4)\n\n        def do(o: int, l: int, r: int, add: int) -> None:\n            sum[o] += add * (r - l + 1)\n            todo[o] += add\n\n        # o=1  [l,r] 1<=l<=r<=n\n        # 把 [L,R] 加一，同时返回加一之前的区间和\n        def query_and_add1(o: int, l: int, r: int, L: int, R: int) -> int:\n            if L <= l and r <= R:\n                res = sum[o]\n                do(o, l, r, 1)\n                return res\n\n            m = (l + r) // 2\n            add = todo[o]\n            if add:\n                do(o * 2, l, m, add)\n                do(o * 2 + 1, m + 1, r, add)\n                todo[o] = 0\n\n            res = 0\n            if L <= m: res += query_and_add1(o * 2, l, m, L, R)\n            if m < R:  res += query_and_add1(o * 2 + 1, m + 1, r, L, R)\n            sum[o] = sum[o * 2] + sum[o * 2 + 1]\n            return res\n\n        ans = s = 0\n        last = {}\n        for i, x in enumerate(nums, 1):\n            j = last.get(x, 0)\n            s += query_and_add1(1, 1, n, j + 1, i) * 2 + i - j\n            ans += s\n            last[x] = i\n        return ans % 1_000_000_007\n"}
{"task_id": "python/69", "content": "\n'''\n\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        # Count 1's and 0's in s\n        count_1 = 0\n        count_0 = 0\n        for i in range(len(s)):\n            if s[i] == '1':\n                count_1 += 1\n            else:\n                count_0 += 1\n        # Apply XOR operation to get the number of changes\n        # needed to make s beautiful\n        return count_1 ^ count_0\n", "groundtruth": "\nclass Solution:\n    def minChanges(self, s: str) -> int:\n        cnt = 0\n        for i in range(0, len(s), 2):\n            if len(set(s[i:i + 2])) > 1:\n                cnt += 1\n                \n        print(s)\n        return cnt\n"}
{"task_id": "python/70", "content": "\n\ndef lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        max_len = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if sum(nums[i:j+1]) == target:\n                    max_len = max(max_len, j-i+1)\n        return max_len\n\n#Example 1:\nInput: nums = [1,3,5,7], target = 12\nOutput: 2\nExplanation: The subsequence is [3,7].\n\n#Example 2:\nInput: nums = [1,2,3,4], target = 12\nOutput: -1\nExplanation: No such subsequence exists.\n\n\n", "groundtruth": "\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        f = [0] + [-inf] * target\n        s = 0\n        for x in nums:\n            s = min(s + x, target)\n            for j in range(s, x - 1, -1):\n                # f[j] = max(f[j], f[j - x] + 1)\n                if f[j] < f[j - x] + 1:\n                    f[j] = f[j - x] + 1\n        return f[-1] if f[-1] > 0 else -1\n"}
{"task_id": "python/71", "content": "\n\ndef f(a: List[int], mx: int) -> Set[int]:\n    return set(a + [0, mx])\n\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        return set(a + [0, mx])\n", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/72", "content": "\n\n\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        s = min(h) * min(v)\n        s %= 1000000007\n        return s\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        s = {1}\n        for x in sorted(a):\n            s.add(x)\n            s.add(mx - x + 1)\n        return s\n", "groundtruth": "\nclass Solution:\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        h = self.f(hFences, m)\n        v = self.f(vFences, n)\n        ans = max(h & v, default=0)\n        return ans ** 2 % 1_000_000_007 if ans else -1\n\n    def f(self, a: List[int], mx: int) -> Set[int]:\n        a.extend([1, mx])\n        a.sort()\n        return set(y - x for x, y in combinations(a, 2))\n"}
{"task_id": "python/73", "content": "\n# You need to complete this function\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        return self.solve(source, target, original, changed, cost)\n    \n    def solve(self, source, target, original, changed, cost, memo=[]):\n        if len(memo) < len(source) + 1:\n            memo.extend([float(\"inf\") for i in range(len(source)+1-len(memo))])\n        if memo[len(source)] != float(\"inf\"):\n            return memo[len(source)]\n        if source == target:\n            return 0\n        if len(source) == 0:\n            memo[len(source)] = float(\"inf\")\n            return float(\"inf\")\n        res = float(\"inf\")\n        for i,c in enumerate(original):\n            if source.count(c) > 0:\n                temp = source\n                temp = temp.replace(c, changed[i], 1)\n                res = min(res, self.solve(temp, target, original, changed, cost, memo) + cost[i])\n        memo[len(source)] = res\n        return res\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.minimumCost(\"abaa\",\"baba\", [\"a\",\"b\",\"c\"],[\"a\",\"b\",\"c\"],[1,2,3]))", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        dis = [[inf] * 26 for _ in range(26)]\n        for i in range(26):\n            dis[i][i] = 0\n\n        for x, y, c in zip(original, changed, cost):\n            x = ord(x) - ord('a')\n            y = ord(y) - ord('a')\n            dis[x][y] = min(dis[x][y], c)\n\n        for k in range(26):\n            for i in range(26):\n                for j in range(26):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/74", "content": "\n", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "python/75", "content": "\n\n\nNote: In this problem, we do not consider the cases where the cost of some operations are negative.\n\n\n\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        ____\n\n        @cache\n        def dfs(i: int) -> int:\n            ____\n            \n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n", "groundtruth": "\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        len_to_strs = defaultdict(set)\n        dis = defaultdict(lambda: defaultdict(lambda: inf))\n        for x, y, c in zip(original, changed, cost):\n            len_to_strs[len(x)].add(x)  \n            len_to_strs[len(y)].add(y)\n            dis[x][y] = min(dis[x][y], c)\n            dis[x][x] = 0\n            dis[y][y] = 0\n\n        for strs in len_to_strs.values():\n            for k in strs:\n                for i in strs:\n                    if dis[i][k] == inf:  \n                        continue\n                    for j in strs:\n                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n        @cache\n        def dfs(i: int) -> int:\n            if i == 0:\n                return 0\n            res = inf\n            if source[i - 1] == target[i - 1]:\n                res = dfs(i - 1) \n            for size, strs in len_to_strs.items():  \n                if i < size:\n                    continue\n                s = source[i - size: i]\n                t = target[i - size: i]\n                if s in strs and t in strs:  \n                    res = min(res, dis[s][t] + dfs(i - size))\n            return res\n        ans = dfs(len(source))\n        return ans if ans < inf else -1\n"}
{"task_id": "cpp/0", "content": "\n\n", "groundtruth": "class Solution {public:static const int mod = 1e9 + 7;int specialPerm(vector<int>& nums) {int n = nums.size();vector<vector<int>> f(1 << n, vector<int>(n, -1));function<int(int, int)> dfs = [&](int state, int i) {if (f[state][i] != -1) {return f[state][i];}if (state == (1 << i)) {return 1;}f[state][i] = 0;for (int j = 0; j < n; j++) {if (i == j || !(state >> j & 1)) {continue;}if (nums[i] % nums[j] != 0 && nums[j] % nums[i] != 0) {continue;}f[state][i] = (f[state][i] + dfs(state ^ (1 << i), j)) % mod;}return f[state][i];};int res = 0;for (int i = 0; i < n; i++) {res = (res + dfs((1 << n) - 1, i)) % mod;}return res;}};"}
{"task_id": "cpp/1", "content": "\n\n#include <iostream>\n#include <vector>\nusing namespace std;\nclass Solution {\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        int n = cost.size();\n        vector<int> f(n * 2 + 1, INT_MAX / 2);\n        f[n] = 0;\n        for (int i = 0; i < n; ++i) {\n            vector<int> g(n * 2 + 1, INT_MAX / 2);\n            for (int j = 0; j <= n * 2; ++j) {\n                if (j > 0) g[j - 1] = min(g[j - 1], f[j]);\n                if (j + time[i] <= n * 2) g[j + time[i]] = min(g[j + time[i]], f[j] + cost[i]);\n            }\n            f = move(g);\n        }\n        return *min_element(f.begin() + n, f.end());\n    }\n};\nint main() {\n    Solution s;\n    vector<int> cost;\n    vector<int> time;\n    int n,c,t;\n    cin >> n;\n    while(n--) {\n        cin >> c >> t;\n        cost.push_back(c);\n        time.push_back(t);\n    }\n    cout << s.paintWalls(cost, time);\n    return 0;\n}\n", "groundtruth": "class Solution {public:int paintWalls(vector<int>& cost, vector<int>& time) {int n = cost.size();vector<int> f(n * 2 + 1, INT_MAX / 2);f[n] = 0;for (int i = 0; i < n; ++i) {vector<int> g(n * 2 + 1, INT_MAX / 2);for (int j = 0; j <= n * 2; ++j) {// 付费g[min(j + time[i], n * 2)] = min(g[min(j + time[i], n * 2)], f[j] + cost[i]);// 免费if (j > 0) {g[j - 1] = min(g[j - 1], f[j]);}}f = move(g);}return *min_element(f.begin() + n, f.end());}};"}
{"task_id": "cpp/2", "content": "\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string smallestString(string s) {\n        char target = 'a';\n        auto it = std::find_if(s.begin(), s.end(), [target](char c) {return c != target;});\n        int indexOfFirstNonA = std::distance(s.begin(), it);\n        if (indexOfFirstNonA == s.length()) {\n            return s.substr(0, s.length() - 1) + 'z';\n        }\n        size_t indexOfFirstA_AfterFirstNonA = s.find('a', indexOfFirstNonA);\n        if (indexOfFirstA_AfterFirstNonA == s.length()) {\n            indexOfFirstA_AfterFirstNonA = s.length();\n        }\n        string res;\n        for (int i = 0; i < s.length(); ++i) {\n            if (i < indexOfFirstNonA || i >= indexOfFirstA_AfterFirstNonA) {\n                res.push_back(s[i]);\n            } else {\n                res.push_back(static_cast<char>(s[i] - 1));\n            }\n        }\n        return res;\n    }\n};\n", "groundtruth": "class Solution {public:string smallestString(string s) {char target = 'a';auto it = std::find_if(s.begin(), s.end(), [target](char c) {return c != target;});int indexOfFirstNonA = std::distance(s.begin(), it);if (indexOfFirstNonA == s.length()) {return s.substr(0, s.length() - 1) + 'z';}size_t indexOfFirstA_AfterFirstNonA = s.find('a', indexOfFirstNonA);if (indexOfFirstA_AfterFirstNonA == string::npos) {indexOfFirstA_AfterFirstNonA = s.length();}string res;for (int i = 0; i < s.length(); ++i) {if (indexOfFirstNonA <= i && i < indexOfFirstA_AfterFirstNonA) {res.push_back(static_cast<char>(s[i] - 1));} else {res.push_back(s[i]);}}return res;}};"}
{"task_id": "cpp/3", "content": "Answer：\nclass Solution {public:long long minCost(vector<int>& nums, int x) {int n = nums.size();vector<int> f(nums);long long ans = ____;for (int k = 1; k < n; ++k) {for (int i = 0; i < n; ++i) {f[i] = min(f[i], nums[(i + k) % n]);}ans = max(ans, f[i]);}return ans;}};\nExplanation:\nThe first line of code is complete, and the other two are not.\nThe first line of code initializes the vector f with nums, which contains the cost of collecting different chocolates. The vector f[i] represents the minimum cost of collecting all chocolates up to the ith operation, and the initial value is the same as the initial value of nums.\nIn the first for loop, the value of k starts from 1 and increases to n-1. In the first iteration, the cost of the kth operation is calculated, and the minimum cost of collecting all chocolates after the kth operation is stored in f[i]. In the next iteration, the value of k changes to k+1, and the cost of the k+1th operation is calculated. Then the minimum cost of collecting all chocolates after the k+1th operation is calculated by comparing the previous minimum cost and the current minimum cost.\nThe last line of code is a variable declaration, which does not need to be completed.\nTherefore, the completed code is as follows:\nclass Solution {public:long long minCost(vector<int>& nums, int x) {int n = nums.size();vector<int> f(nums);long long ans = ____;for (int k = 1; k < n; ++k) {for (int i = 0; i < n; ++i) {f[i] = min(f[i], nums[(i + k) % n]);}ans = max(ans, f[i]);}return ans;}};\nThe value of ans is the minimum cost of collecting all chocolates.\n", "groundtruth": "class Solution {public:long long minCost(vector<int>& nums, int x) {int n = nums.size();vector<int> f(nums);long long ans = accumulate(f.begin(), f.end(), 0LL);for (int k = 1; k < n; ++k) {for (int i = 0; i < n; ++i) {f[i] = min(f[i], nums[(i + k) % n]);}ans = min(ans, static_cast<long long>(k) * x + accumulate(f.begin(), f.end(), 0LL));}return ans;}};"}
{"task_id": "cpp/4", "content": "\nInput: nums1 = [2, 3, 7], nums2 = [4, 0, 1], queries = [[1, 0], [3, 1], [5, 2]]\nOutput: [4, 0, 4]\n", "groundtruth": "class Solution {public:vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {vector<pair<int, int>> sortedNums;vector<tuple<int, int, int>> sortedQueries;for (int i = 0; i < nums1.size(); i++) {sortedNums.emplace_back(nums1[i], nums2[i]);}sort(sortedNums.begin(), sortedNums.end(), greater<pair<int, int>>());for (int i = 0; i < queries.size(); i++) {sortedQueries.emplace_back(i, queries[i][0], queries[i][1]);}sort(sortedQueries.begin(), sortedQueries.end(), [](tuple<int, int, int> &a, tuple<int, int, int> &b) {return get<1>(a) > get<1>(b);});vector<pair<int, int>> stk;vector<int> answer(queries.size(), -1);int j = 0;for (auto &[i, x, y] : sortedQueries) {while (j < sortedNums.size() && sortedNums[j].first >= x) {auto [num1, num2] = sortedNums[j];while (!stk.empty() && stk.back().second <= num1 + num2) {stk.pop_back();}if (stk.empty() || stk.back().first < num2) {stk.emplace_back(num2, num1 + num2);}j++;}int k = lower_bound(stk.begin(), stk.end(), make_pair(y, 0)) - stk.begin();if (k < stk.size()) {answer[i] = stk[k].second;}}return answer;}};"}
{"task_id": "cpp/5", "content": "\n\n\n\n\nclass Solution {\npublic:\n    int longestSemiRepetitiveSubstring(string s) {\n        int ans = 1, left = 0, same = 0, n = s.length();\n        for (int right = 1; right < n; right++) {\n            if (s[right] == s[right - 1] && ++same > 1) {\n                same = 1;\n            }\n            ans = max(ans, right - left + 1);\n        }\n        return ans;\n    }\n};\n", "groundtruth": "class Solution {public:int longestSemiRepetitiveSubstring(string s) {int ans = 1, left = 0, same = 0, n = s.length();for (int right = 1; right < n; right++) {if (s[right] == s[right - 1] && ++same > 1) {for (left++; s[left] != s[left - 1]; left++);same = 1;}ans = max(ans, right - left + 1);}return ans;}};"}
{"task_id": "cpp/6", "content": "\nAnswer: \n\nclass Solution {public:static constexpr int mod = 1e9 + 7;int sumDistance(vector<int>& nums, string s, int d) {int n = nums.size();vector<long long> pos(n);for (int i = 0; i < n; i++) {if (s[i] == 'L') {pos[i] = nums[i] - d;} else {pos[i] = nums[i] + d;}}sort(pos.begin(), pos.end());long long res = 0;for (int i = 1; i < n; i++) {res += abs(pos[i] - pos[i - 1]);}res %= mod;return res;}};\n\n", "groundtruth": "class Solution {public:static constexpr int mod = 1e9 + 7;int sumDistance(vector<int>& nums, string s, int d) {int n = nums.size();vector<long long> pos(n);for (int i = 0; i < n; i++) {if (s[i] == 'L') {pos[i] = (long long) nums[i] - d;} else {pos[i] = (long long) nums[i] + d;}}sort(pos.begin(), pos.end());long long res = 0;for (int i = 1; i < n; i++) {res += 1ll * (pos[i] - pos[i - 1]) * i % mod * (n - i) % mod;res %= mod;}return res;}};"}
{"task_id": "cpp/7", "content": "", "groundtruth": "class Solution {public:vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {vector<int> ans;unordered_map<int, int> mp;int m = grid.size();int n = grid[0].size();for (int j = 0; j < m; j++) {int st = 0;for (int i = 0; i < n; i++) {st |= (grid[j][i] << i);}mp[st] = j;}if (mp.count(0)) {ans.push_back(mp[0]);return ans;}for (auto [x, i]: mp) {for (auto [y, j]: mp) {if (!(x & y)) {return {min(i, j), max(i, j)};}}}return ans;}};"}
{"task_id": "cpp/8", "content": "\n\nclass Solution {\npublic:\n    long long matrixSumQueries(int n, vector<vector<int>> &queries) {\n        long long ans = 0;\n        unordered_set<int> vis[2];\n        for (int i = queries.size() - 1; i >= 0; i--) {\n            auto &q = queries[i];\n            int type = q[0], index = q[1], val = q[2];\n            if (!vis[type].count(index)) {\n                // 后面（>i）没有对这一行/列的操作\n                // 这一行/列还剩下 n-vis[type^1].size() 个可以填入的格子\n                vis[type].insert(index);\n                ans += (long long) (n - vis[type ^ 1].size()) * val;\n            }\n        }\n        return ans;\n    }\n};\n", "groundtruth": "class Solution {public:long long matrixSumQueries(int n, vector<vector<int>> &queries) {long long ans = 0;unordered_set<int> vis[2];for (int i = queries.size() - 1; i >= 0; i--) {auto &q = queries[i];int type = q[0], index = q[1], val = q[2];if (!vis[type].count(index)) { // 后面（>i）没有对这一行/列的操作// 这一行/列还剩下 n-vis[type^1].size() 个可以填入的格子ans += (long long) (n - vis[type ^ 1].size()) * val;vis[type].insert(index);}}return ans;}};"}
{"task_id": "cpp/9", "content": "", "groundtruth": "class Solution {static constexpr int N = 23;static constexpr int M = 401;static constexpr int MOD = 1e9 + 7;int d[N][M];string num;int min_sum;int max_sum;int dfs(int i, int j, bool limit) {if (j > max_sum) {return 0;}if (i == -1) {return j >= min_sum;}if (!limit && d[i][j] != -1) {return d[i][j];}int res = 0;int up = limit ? num[i] - '0' : 9;for (int x = 0; x <= up; x++) {res = (res + dfs(i - 1, j + x, limit && x == up)) % MOD;}if (!limit) {d[i][j] = res;}return res;}int get(string num) {reverse(num.begin(), num.end());this->num = num;return dfs(num.size() - 1, 0, true);}// 求解 num - 1，先把最后一个非 0 字符减去 1，再把后面的 0 字符变为 9string sub(string num) {int i = num.size() - 1;while (num[i] == '0') {i--;}num[i]--;i++;while (i < num.size()) {num[i] = '9';i++;}return num;}public:int count(string num1, string num2, int min_sum, int max_sum) {memset(d, -1, sizeof d);this->min_sum = min_sum;this->max_sum = max_sum;return (get(num2) - get(sub(num1)) + MOD) % MOD;}};"}
{"task_id": "cpp/10", "content": "\nAnswer:\n\nclass Solution {public:int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {int n = mat.size();int m = mat[0].size();unordered_map<int, pair<int, int>> mp;for (int i = 0; i < n; ++i) {for (int j = 0; j < m; ++j) {mp[mat[i][j]] = {i, j};}}vector<int> rowCnt(n, 0);vector<int> colCnt(m, 0);for (int i = 0; i < arr.size(); ++i) {auto v = mp[arr[i]];++rowCnt[v.first];if (rowCnt[v.first] == m) {return i;}++colCnt[v.second];if (colCnt[v.second] == n) {return i;}}return -1;}};", "groundtruth": "class Solution {public:int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {int n = mat.size();int m = mat[0].size();unordered_map<int, pair<int, int>> mp;for (int i = 0; i < n; ++i) {for (int j = 0; j < m; ++j) {mp[mat[i][j]] = {i, j};}}vector<int> rowCnt(n, 0);vector<int> colCnt(m, 0);for (int i = 0; i < arr.size(); ++i) {auto& v = mp[arr[i]];++rowCnt[v.first];if (rowCnt[v.first] == m) {return i;}++colCnt[v.second];if (colCnt[v.second] == n) {return i;}}return -1;}};"}
{"task_id": "cpp/11", "content": "\n# Read from the following code template\n\n<pre><code>\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdlib&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;stack&gt;\n#include &lt;algorithm&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;deque&gt;\n#include &lt;queue&gt;\n#include &lt;bitset&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;list&gt;\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define us unsigned short\n#define ul unsigned long\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, n) for (int i = 0; i &lt; n; ++i)\n#define fi first\n#define se second\n#define pb push_back\n#define pii pair&lt;int, int&gt;\n#define pll pair&lt;long long, long long&gt;\n#define all(a) a.begin(), a.end()\n#define inf 0x3f3f3f3f\n#define eps 1e-8\n#define pinf (1 &lt;&lt; 31) - 1\n#define _for(i, a, b) for (int i = a; i &lt; b; ++i)\n#define _rep(i, a, b) for (int i = a; i &gt;= b; --i)\nusing LL = long long;\nconst int mod = 1000000007;\nconst int N = 1e5 + 5;\ninline void up(LL &x, LL a) {x += a;if (x &gt;= mod)x -=", "groundtruth": "class Solution {public:int minimumCost(vector<int> &start, vector<int> &target, vector <vector<int>> &specialRoads) {using LL = long long;LL t = (LL) target[0] << 32 | target[1];unordered_map<LL, int> dis = {{(LL) start[0] << 32 | start[1], 0}, {t, INT_MAX}};unordered_set<LL> vis;for (;;) {LL v = -1;int dv = -1;for (auto &[p, d]: dis)if (!vis.count(p) && (dv < 0 || d < dv))v = p, dv = d;if (v == t) return dv; // 到终点的最短路已确定vis.insert(v);int vx = v >> 32, vy = v & UINT32_MAX;// 更新到终点的最短路dis[t] = min(dis[t], dv + target[0] - vx + target[1] - vy);for (auto &r: specialRoads) {int d = dv + abs(r[0] - vx) + abs(r[1] - vy) + r[4];LL w = (LL) r[2] << 32 | r[3];if (!dis.count(w) || d < dis[w])dis[w] = d;}}}};"}
{"task_id": "cpp/12", "content": "", "groundtruth": "class Solution {public:string smallestBeautifulString(string s, int k) {for (int i = s.length() - 1; i >= 0; --i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {____}}for (int j = 1; j <= 3; ++j) {if (s[i] - 'a' + j + 1 <= k && blockedCharacters.find(s[i] + j) == blockedCharacters.end()) {return generate(s, i, j);}}}return \"\";}string generate(string s, int idx, int offset) {s[idx] += offset;for (int i = idx + 1; i < s.length(); ++i) {unordered_set<char> blockedCharacters;for (int j = 1; j <= 2; ++j) {if (i - j >= 0) {blockedCharacters.insert(s[i - j]);}}for (int j = 0; j < 3; ++j) {if (____) {s[i] = 'a' + j;break;}}}return s;}};"}
{"task_id": "cpp/13", "content": "```\n\n\n\n\n# 借鉴\n\n1. 补充知识：\n   * 位运算符：在 C 语言中，位运算符作用于整数的二进制形式。\n     * &（与）\n     * |（或）\n     * ~（取反）\n     * ^（异或）\n     * <<（左移）\n     * >>（右移）\n   * 二进制的表示：\n     * 一个二进制位代表一个数字的0/1。\n   * 二进制的相加：\n     * 二进制从低到高相加。如果二者都是1，那么结果就是1。\n   * 位运算的性质：\n     * 对于位运算，0与任何数异或都是原数，1与任何数异或都是1。\n     * 对于位运算，0与任何数异或都是原数，1与任何数异或都是1。\n     * 对于位运算，0与任何数异或都是原数，1与任何数异或都是1。\n   * 数组异或：\n     * 可以用于计算两个数组的相同值。\n2. 思路：\n   * 异或运算可以消除两个相同的数。\n   * 用数组 A 与 B 的异或运算的结果，可以得到只有数组 A 或 B 中存在的数字。\n   * 那么在这个结果中，出现的数字就是只存在于 A 和 B 的数字。\n   * 然后在将这个结果的每个位都移动到相应的位置上，也就是每个数字在数组 A 和数组 B 中的下标。\n   * 这样的结果就是这两个数组的前", "groundtruth": "class Solution {public:vector<int> findThePrefixCommonArray(vector<int> &a, vector<int> &b) {int n = a.size();vector<int> ans(n);long long p = 0, q = 0;for (int i = 0; i < n; ++i) {p |= 1LL << a[i];q |= 1LL << b[i];ans[i] = __builtin_popcountll(p & q);}return ans;}};"}
{"task_id": "cpp/14", "content": "", "groundtruth": "class Solution {static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};public:int findMaxFish(vector<vector<int>> &grid) {int m = grid.size(), n = grid[0].size(), ans = 0;function<int(int, int)> dfs = [&](int x, int y) -> int {if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)return 0;int sum = grid[x][y];grid[x][y] = 0; // 标记成访问过for (auto &d: dirs) // 四方向移动sum += dfs(x + d[0], y + d[1]);return sum;};for (int i = 0; i < m; ++i)for (int j = 0; j < n; ++j)ans = max(ans, dfs(i, j));return ans;}};"}
{"task_id": "cpp/15", "content": "\n```java\n// 树状数组模板\nclass BIT {\n    vector<int> tree;\n\n    public:\n    BIT(int n) : tree(n) {}\n\n    // 将下标 i 上的数加一\n    void inc(int i) {\n        while (i < tree.size()) {\n            ++tree[i];\n            i += i & -i;\n        }\n    }\n\n    // 返回闭区间 [1, i] 的元素和\n    int sum(int x) {\n        int res = 0;\n        while (x > 0) {\n            res += tree[x];\n            x &= x - 1;\n        }\n        return res;\n    }\n\n    // 返回闭区间 [left, right] 的元素和\n    int query(int left, int right) {\n        return sum(right) - sum(left - 1);\n    }\n};\n\nclass Solution {\n    public:\n    long long countOperationsToEmptyArray(vector<int> &nums) {\n        int n = nums.size(), id[n];\n        iota(id, id + n, 0);\n        sort(id, id + n, [&](int i, int j) {\n            return nums[i] < nums[j];\n        });\n        long long ans = n; // 先把 n 计入答案\n        BIT t(n + 1); // 下标从 1 开始\n        int pre = 1; // 上一个最小值的位置，初始为 1\n        for (int k = 0; k < n; ++k) {\n            int i = id[k] + 1; // 下标从 1 开始\n            if (i >= pre) // 从 pre 移动到 i，跳过已经删除的数\n                t.inc(i); // 删除 i\n            else // 从 pre 移动到 n，再从 1 移动到 i，跳过已经删", "groundtruth": "// 树状数组模板class BIT {vector<int> tree;public:BIT(int n) : tree(n) {}// 将下标 i 上的数加一void inc(int i) {while (i < tree.size()) {++tree[i];i += i & -i;}}// 返回闭区间 [1, i] 的元素和int sum(int x) {int res = 0;while (x > 0) {res += tree[x];x &= x - 1;}return res;}// 返回闭区间 [left, right] 的元素和int query(int left, int right) {return sum(right) - sum(left - 1);}};class Solution {public:long long countOperationsToEmptyArray(vector<int> &nums) {int n = nums.size(), id[n];iota(id, id + n, 0);sort(id, id + n, [&](int i, int j) {return nums[i] < nums[j];});long long ans = n; // 先把 n 计入答案BIT t(n + 1); // 下标从 1 开始int pre = 1; // 上一个最小值的位置，初始为 1for (int k = 0; k < n; ++k) {int i = id[k] + 1; // 下标从 1 开始if (i >= pre) // 从 pre 移动到 i，跳过已经删除的数ans += i - pre - t.query(pre, i);else // 从 pre 移动到 n，再从 1 移动到 i，跳过已经删除的数ans += n - pre + i - k + t.query(i, pre - 1);t.inc(i); // 删除 ipre = i;}return ans;}};"}
{"task_id": "cpp/16", "content": "```c++\nclass Solution {\npublic:\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x) {\n        const int BIAS = 50;\n        int cnt[BIAS * 2 + 1]{}, n = nums.size();\n        for (int i = 0; i < k - 1; ++i)\n            // 先往窗口内添加 k-1 个数\n            ++cnt[nums[i] + BIAS];\n        vector<int> ans(n - k + 1);\n        for (int i = k - 1; i < n; ++i) {\n            ++cnt[nums[i] + BIAS];\n            // 进入窗口（保证窗口有恰好 k 个数）\n            int left = x;\n            for (int j = 0; j < BIAS; ++j) {\n                // 暴力枚举负数范围 [-50,-1]\n                if (left <= 0) {\n                    // 找到美丽值\n                    ans[i - k + 1] = j - BIAS;\n                    break;\n                }\n                left -= cnt[j + BIAS];\n            }\n            --cnt[nums[i - k + 1] + BIAS];\n            // 离开窗口\n        }\n        return ans;\n    }\n};\n\n```\n\n", "groundtruth": "class Solution {public:vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x) {const int BIAS = 50;int cnt[BIAS * 2 + 1]{}, n = nums.size();for (int i = 0; i < k - 1; ++i) // 先往窗口内添加 k-1 个数++cnt[nums[i] + BIAS];vector<int> ans(n - k + 1);for (int i = k - 1; i < n; ++i) {++cnt[nums[i] + BIAS]; // 进入窗口（保证窗口有恰好 k 个数）int left = x;for (int j = 0; j < BIAS; ++j) { // 暴力枚举负数范围 [-50,-1]left -= cnt[j];if (left <= 0) { // 找到美丽值ans[i - k + 1] = j - BIAS;break;}}--cnt[nums[i - k + 1] + BIAS]; // 离开窗口}return ans;}};"}
{"task_id": "cpp/17", "content": "", "groundtruth": "class Solution {public:int minOperations(vector<int> &nums) {int n = nums.size(), gcd_all = 0, cnt1 = 0;for (int x: nums) {gcd_all = gcd(gcd_all, x);cnt1 += x == 1;}if (gcd_all > 1) return -1;if (cnt1) return n - cnt1;int min_size = n;for (int i = 0; i < n; ++i) {int g = 0;for (int j = i; j < n; ++j) {g = gcd(g, nums[j]);if (g == 1) {// 这里本来是 j-i+1，把 +1 提出来合并到 return 中min_size = min(min_size, j - i);break;}}}return min_size + n - 1;}};"}
{"task_id": "cpp/18", "content": "\nAnswer: \nclass Solution {public:int maxDivScore(vector<int>& nums, vector<int>& divisors) {int cnt = -1, ans = 0;for (int i = 0; i < divisors.size(); i++) {int tmp = 0;for (int j = 0; j < nums.size(); j++) {if (nums[j] % divisors[i] == 0) {tmp++;}}if (tmp > cnt || (tmp == cnt && divisors[i] < ans)) {cnt = tmp;ans = divisors[i];}}return ans;}};\n", "groundtruth": "class Solution {public:int maxDivScore(vector<int>& nums, vector<int>& divisors) {int cnt = -1, ans = 0;for (int i = 0; i < divisors.size(); i++) {int tmp = 0;for (int j = 0; j < nums.size(); j++) {if (nums[j] % divisors[i] == 0) {tmp++;}}if (tmp > cnt || (tmp == cnt && divisors[i] < ans)) {ans = divisors[i];cnt = tmp;}}return ans;}};"}
{"task_id": "cpp/19", "content": "\nint addMinimum(string word) {\n    int n = word.size();\n    vector<int> d(n + 1);\n    for (int i = 1; i <= n; i++) {\n        if (i % 3 == 0) {\n            d[i] = min(d[i - 1] - 1, d[i - 1] + 1);\n        } else if (word[i - 1] == 'a') {\n            d[i] = d[i - 1] + 1;\n        } else if (word[i - 1] == 'b') {\n            d[i] = d[i - 1] - 1;\n        } else {\n            d[i] = d[i - 1] - 2;\n        }\n    }\n    return d[n];\n}\n", "groundtruth": "class Solution {public:int addMinimum(string word) {int n = word.size();vector<int> d(n + 1);for (int i = 1; i <= n; i++) {d[i] = d[i - 1] + 2;if (i > 1 && word[i - 1] > word[i - 2]) {d[i] = d[i - 1] - 1;}}return d[n];}};"}
{"task_id": "cpp/20", "content": "", "groundtruth": "class Solution {public:int minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips) {vector<vector<int>> next(n);for (auto &edge : edges) {next[edge[0]].push_back(edge[1]);next[edge[1]].push_back(edge[0]);}vector<int> count(n);function<bool(int, int, int)> dfs = [&](int node, int parent, int end) -> bool {if (node == end) {count[node]++;return true;}for (int child : next[node]) {if (child == parent) {continue;}if (dfs(child, node, end)) {count[node]++;return true;}}return false;};for (auto &trip: trips) {dfs(trip[0], -1, trip[1]);}function<pair<int, int>(int, int)> dp = [&](int node, int parent) -> pair<int, int> {pair<int, int> res = {price[node] * count[node], price[node] * count[node] / 2};for (int child : next[node]) {if (child == parent) {continue;}auto [x, y] = dp(child, node);res.first += min(x, y); // node 没有减半，因此可以取子树的两种情况的最小值res.second += x; // node 减半，只能取子树没有减半的情况}return res;};auto [x, y] = dp(0, -1);return min(x, y);}};"}
{"task_id": "cpp/21", "content": "\n\n\n\n\npackage q1383;\n\npublic class FindPrefixScore {\n\n    /**\n     * @param nums an integer array\n     * @return return an array\n     */\n    public int[] findPrefixScore(int[] nums) {\n        // Write your code here\n\n        int[] ans = new int[nums.length];\n        int tmp = nums[0];\n        ans[0] = nums[0] * 2;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > tmp) tmp = nums[i];\n            ans[i] = tmp * 2 + ans[i - 1];\n        }\n        return ans;\n    }\n\n}\n", "groundtruth": "class Solution {public:vector<long long> findPrefixScore(vector<int>& nums) {vector<long long> ans;int tmp = nums[0];ans.push_back(nums[0] * 2);for (int i = 1; i < nums.size(); ++i) {if (nums[i] > tmp) tmp = nums[i];ans.push_back(nums[i] + tmp + ans[i - 1]);}return ans;}};"}
{"task_id": "cpp/22", "content": "", "groundtruth": "class Solution {public:TreeNode* replaceValueInTree(TreeNode* root) {vector<TreeNode*> q = {root};root->val = 0;while (!q.empty()) {vector<TreeNode*> q2;int sum = 0;for (auto fa : q) {if (fa->left) {q2.push_back(fa->left);sum += fa->left->val;}if (fa->right) {q2.push_back(fa->right);sum += fa->right->val;}}for (auto fa : q) {int child_sum = (fa->left ? fa->left->val : 0) +(fa->right ? fa->right->val : 0);if (fa->left) {fa->left->val = sum - child_sum;}if (fa->right) {fa->right->val = sum - child_sum;}}q = move(q2);}return root;}};"}
{"task_id": "cpp/23", "content": "Input: \n[[\"Graph\",[6,[0,1,3],[0,3,1],[0,4,4],[2,5,2],[2,4,5],[2,3,3],[5,1,5],[4,3,4],[3,5,1]]],[\"addEdge\",[0,4,2]],[\"shortestPath\",[0,5]]]\nOutput: \n[null,null,2]\nExplanation:\nGraph graph = new Graph(6, [[0,1,3],[0,3,1],[0,4,4],[2,5,2],[2,4,5],[2,3,3],[5,1,5],[4,3,4],[3,5,1]]);\ngraph.addEdge([0,4,2]);\ngraph.shortestPath(0,5); // return 2. \nThe shortest path is: 0->4->5 with cost = 2\n```\n\n### Approach 1: Dijkstra\n```python\nclass Graph {\npublic:\n    using pii = pair<int, int>;\n    Graph(int n, vector<vector<int>>& edges) {\n        this->graph = vector<vector<pii>>(n);\n        for (auto &vec : edges) {\n            int x = vec[0];\n            int y = vec[1];\n            int cost = vec[2];\n            graph[x].emplace_back(y, cost);\n        }\n    }\n\n    void addEdge(vector<int> edge) {\n        int x = edge[0];\n        int y = edge[1];\n        int cost = edge[2];\n        graph[x].emplace_back(y, cost);\n    }\n\n    int shortestPath(int node1, int node2) {\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\n        vector<int> dist(graph.size(), INT_MAX);\n        dist[node1] = 0;\n        pq.emplace(0, node1);\n        while (!pq.empty()) {\n            auto [cost, cur] = pq.top();\n            pq.", "groundtruth": "class Graph {public:using pii = pair<int, int>;Graph(int n, vector<vector<int>>& edges) {this->graph = vector<vector<pii>>(n);for (auto &vec : edges) {int x = vec[0];int y = vec[1];int cost = vec[2];graph[x].emplace_back(y, cost);}}void addEdge(vector<int> edge) {int x = edge[0];int y = edge[1];int cost = edge[2];graph[x].emplace_back(y, cost);}int shortestPath(int node1, int node2) {priority_queue<pii, vector<pii>, greater<pii>> pq;vector<int> dist(graph.size(), INT_MAX);dist[node1] = 0;pq.emplace(0, node1);while (!pq.empty()) {auto [cost, cur] = pq.top();pq.pop();if (cur == node2) {return cost;}for (auto [next, ncost] : graph[cur]) {if (dist[next] > cost + ncost) {dist[next] = cost + ncost;pq.emplace(cost + ncost, next);}}}return -1;}private:vector<vector<pii>> graph;};"}
{"task_id": "cpp/24", "content": "\nclass Solution {public:vector<long long> distance(vector<int> &nums) {int n = nums.size();unordered_map<int, vector<int>> groups;for (int i = 0; i < n; ++i)groups[nums[i]].push_back(i); // 相同元素分到同一组，记录下标vector<long long> ans(n);long long s[n + 1];s[0] = 0;for (auto &[_, a]: groups) {int m = a.size();for (int i = 0; i < m; ++i)s[i + 1] = s[i] + a[i]; // 前缀和for (int i = 0; i < m; ++i) {long long target = a[i];long long left = i > 0 ? s[i] - s[i - 1] : 0; // 蓝色面积long long right = s[m] - s[i] - target * (m - i); // 绿色面积ans[a[i]] = left + right;}}return ans;}};", "groundtruth": "class Solution {public:vector<long long> distance(vector<int> &nums) {int n = nums.size();unordered_map<int, vector<int>> groups;for (int i = 0; i < n; ++i)groups[nums[i]].push_back(i); // 相同元素分到同一组，记录下标vector<long long> ans(n);long long s[n + 1];s[0] = 0;for (auto &[_, a]: groups) {int m = a.size();for (int i = 0; i < m; ++i)s[i + 1] = s[i] + a[i]; // 前缀和for (int i = 0; i < m; ++i) {long long target = a[i];long long left = target * i - s[i]; // 蓝色面积long long right = s[m] - s[i] - target * (m - i); // 绿色面积ans[target] = left + right;}}return ans;}};"}
{"task_id": "cpp/25", "content": "\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nclass Solution {\n   public:\n    int minimizeMax(vector<int> &nums, int p) {\n        sort(nums.begin(), nums.end());\n        int left = -1, right = nums.back() - nums[0];\n        // 开区间\n        while (left + 1 < right) {\n            // 开区间\n            int cnt = 0;\n            int mid = (left + right) / 2;\n            int i = 0, j = 1;\n            // 都选\n            while (j < nums.size()) {\n                if (nums[j] - nums[i] <= mid) {\n                    j++;\n                } else {\n                    i++;\n                    j++;\n                    cnt++;\n                }\n            }\n            cnt += nums.size() - i - 1;\n            (cnt >= p ? right : left) = mid;\n        }\n        return right;\n    }\n};\n", "groundtruth": "class Solution {public:int minimizeMax(vector<int> &nums, int p) {sort(nums.begin(), nums.end());int left = -1, right = nums.back() - nums[0]; // 开区间while (left + 1 < right) { // 开区间int mid = left + (right - left) / 2, cnt = 0;for (int i = 0; i < nums.size() - 1; ++i)if (nums[i + 1] - nums[i] <= mid) { // 都选++cnt;++i;}(cnt >= p ? right : left) = mid;}return right;}};"}
{"task_id": "cpp/26", "content": "\n", "groundtruth": "class Solution {public:int minimumVisitedCells(vector<vector<int>>& grid) {int m = grid.size(), n = grid[0].size();vector<vector<int>> dist(m, vector<int>(n, -1));dist[0][0] = 1;vector<priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>> row(m), col(n);auto update = [](int& x, int y) {if (x == -1 || y < x) {x = y;}};for (int i = 0; i < m; ++i) {for (int j = 0; j < n; ++j) {while (!row[i].empty() && row[i].top().second + grid[i][row[i].top().second] < j) {row[i].pop();}if (!row[i].empty()) {update(dist[i][j], dist[i][row[i].top().second] + 1);}while (!col[j].empty() && col[j].top().second + grid[col[j].top().second][j] < i) {col[j].pop();}if (!col[j].empty()) {update(dist[i][j], dist[col[j].top().second][j] + 1);}if (dist[i][j] != -1) {row[i].emplace(dist[i][j], j);col[j].emplace(dist[i][j], i);}}}return dist[m - 1][n - 1];}};"}
{"task_id": "cpp/27", "content": "\n", "groundtruth": "class Solution {public:vector<vector<int>> findMatrix(vector<int> &nums) {unordered_map<int, int> cnt;for (int x: nums) ++cnt[x];vector<vector<int>> ans;while (!cnt.empty()) {vector<int> row;for (auto it = cnt.begin(); it != cnt.end();) {row.push_back(it->first);if (--it->second == 0) it = cnt.erase(it);else ++it;}ans.push_back(row);}return ans;}};"}
{"task_id": "cpp/28", "content": "\n/*\n * param reward1: \n * param reward2: \n * param k: \n * return: \n */\nint miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\n    int ans = 0;\n    int n = reward1.size();\n    vector<int> diffs(n);\n    for (int i = 0; i < n; i++) {\n        diffs[i] = reward1[i] - reward2[i];\n    }\n    sort(diffs.begin(), diffs.end());\n    for (int i = 1; i <= k; i++) {\n        ans += diffs[n - i];\n    }\n    return ans;\n}\n\n", "groundtruth": "class Solution {public:int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {int ans = 0;int n = reward1.size();vector<int> diffs(n);for (int i = 0; i < n; i++) {ans += reward2[i];diffs[i] = reward1[i] - reward2[i];}sort(diffs.begin(), diffs.end());for (int i = 1; i <= k; i++) {ans += diffs[n - i];}return ans;}};"}
{"task_id": "cpp/29", "content": "\n\n\n\nclass Solution {\npublic:\n    vector<int> minReverseOperations(int n, int p, vector<int> &banned, int k) {\n        unordered_set<int> ban(banned.begin(), banned.end());\n        set<int> sets[2];\n        for (int i = 0; i < n; ++i)\n            if (ban.find(i) == ban.end())\n                sets[i % 2].insert(i);\n        sets[0].insert(n);\n        sets[1].insert(n);\n        vector<int> ans(n, -1);\n        vector<int> q = {p};\n        for (int step = 0; !q.empty(); ++step) {\n            vector<int> nq;\n            for (int i : q) {\n                ans[i] = step;\n                int mn = max(i - k + 1, k - i - 1);\n                auto &s = sets[mn % 2];\n                for (auto it = s.lower_bound(mn); *it <= mn + k - 1; it = s.erase(it))\n                    nq.push_back(*it);\n            }\n            q = move(nq);\n        }\n        return ans;\n    }\n};\n", "groundtruth": "class Solution {public:vector<int> minReverseOperations(int n, int p, vector<int> &banned, int k) {unordered_set<int> ban{banned.begin(), banned.end()};set<int> sets[2];for (int i = 0; i < n; ++i)if (i != p && !ban.count(i))sets[i % 2].insert(i);sets[0].insert(n);sets[1].insert(n); // 哨兵vector<int> ans(n, -1);vector<int> q = {p};for (int step = 0; !q.empty(); ++step) {vector<int> nq;for (int i: q) {ans[i] = step;// 从 mn 到 mx 的所有位置都可以翻转到int mn = max(i - k + 1, k - i - 1);int mx = min(i + k - 1, n * 2 - k - i - 1);auto &s = sets[mn % 2];for (auto it = s.lower_bound(mn); *it <= mx; it = s.erase(it))nq.push_back(*it);}q = move(nq);}return ans;}};"}
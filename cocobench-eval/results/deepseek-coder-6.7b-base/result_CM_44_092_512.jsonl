{"task_id": "python/0", "content": "\"\"\"\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        ans = cnt[1] - 1 | 1  # |1, x | 1\n        del cnt[1]\n        for x in cnt:  # start\n            res = 1  # res: the number of digits of x\n            while cnt[x] > 1:  # if x's multiples are odd\n                res += 2\n                x *= x  # x's multiples\n            ans = max(ans, res + (1 if x in cnt else -1))  # end\n        return ans", "groundtruth": "class Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        ans = cnt[1] - 1 | 1  \n        del cnt[1]\n        for x in cnt:\n            res = 0\n            while cnt[x] > 1:\n                res += 2\n                x *= x\n            ans = max(ans, res + (1 if x in cnt else -1))  \n        return ans\n"}
{"task_id": "python/1", "content": "\"\"\"\n\nclass Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:  # start\n        min1, min2 = float('inf'), float('inf')\n        for i in prices:\n            if min1 > i:\n                min2 = min1\n                min1=i\n            elif min2 > i :  # end\n                min2 = i\n        if ( min1 + min2 ) > money:\n            return money\n        else:\n            return money - (min1 + min2)", "groundtruth": "class Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        min1, min2 = 99999999, 99999999\n        for i in prices:\n            if min1 > i:\n                min2 = min1\n                min1=i\n            elif min2 > i :\n                min2 = i\n        if ( min1 + min2 ) > money:\n            return money\n        else:\n            return money - (min1 + min2)\n"}
{"task_id": "python/2", "content": "\n### Examples\n\n**Example 1:**\n```\nInput: n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]]\nOutput: 23\nExplanation:\nThe image above describes the changes to the matrix over each query.\nThe sum of the matrix after all the changes is 1 + 2 + 3 + 4 = 10.\n```\n\n**Example 2:**\n```\nInput: n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]]\nOutput: 17\nExplanation:\nThe image above describes the changes to the matrix over each query.\nThe sum of the matrix after all the changes is 4 + 2 + 1 + 3 + 1 = 10.\n```\n\n### Constraints\n\n- 1 <= n <= 50\n- 1 <= queries.length <= 500\n- queries[i].length == 3\n- 0 <= type(i) <= 1\n- 0 <= index(i) < n\n- 1 <= val(i) <= 50\n- The original elements in the matrix are 0.\n\n---\n\n## Official Solution (Greedy)\n\nWe can use a greedy approach to solve the problem efficiently.\n\nIntuition\n\nLet us observe that in order to add the maximum sum to the matrix, we should first set the value of the cells with larger values to 0.\n\nTherefore, we can iterate through the queries array in the reverse order, and maintain two sets: rowSet and colSet, where rowSet denotes the rows that have already been assigned values, and colSet denotes the columns that have already been assigned values. If we encounter a new row or column that is not in either of these sets, we can add the sum of the current row or column to the final answer.\n\nAlgorithm\n\n1. Initialize rowSet and colSet to empty sets. Initialize sumi to 0.\n2. Iterate over the queries array in reverse order.\n3. If the type of the query is 0, it means that we need to set the values in the given row to val.", "groundtruth": "from typing import List\n\nclass Solution:\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\n        sumi = 0\n        row = set()\n        col = set()\n\n        for a, b, c in reversed(queries):\n            if a == 0:\n                if b not in row:\n                    row.add(b)\n                    sumi += c * (n - len(col))\n            else:\n                if b not in col:\n                    col.add(b)\n                    sumi += c * (n - len(row))\n        \n        return sumi\n"}
{"task_id": "python/3", "content": "\nExplanation of code\n\nThe code is not complete.\nPlease provide the code in the form of an array with each element containing a single character.\n", "groundtruth": "import bisect\nclass Solution:\n\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n\n        values = [(v, r, c) for r, row in enumerate(mat) for c, v in enumerate(row)]\n        values.sort(reverse=True)\n\n        bestInRow = [0 for _ in range(m)]\n        bestInCol = [0 for _ in range(n)]\n        prevV = None\n        updates = []\n        answer = 1\n\n        for v, r, c in values:\n            if prevV != v:\n                prevV = v\n                for bu, ru, cu in updates:\n                    if bestInRow[ru] < bu:\n                        bestInRow[ru] = bu\n\n                    if bestInCol[cu] < bu:\n                        bestInCol[cu] = bu\n                updates.clear()\n\n            best = bestInRow[r]\n            if best < bestInCol[c]:\n                best = bestInCol[c]\n            best += 1\n\n            if answer < best:\n                answer = best\n\n            updates.append((best,r,c))\n\n        return answer\n"}
{"task_id": "python/4", "content": "\"\"\"\n\n\nclass Solution:\n    def countKeyChanges(self, s: str) -> int:\n        if len(s) == 1:\n            return 0\n        s = s.upper()\n        count = 0\n        for i in range(len(s)-1):\n            if s[i] != s[i + 1]:\n                count += 1\n        return count\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.countKeyChanges(\"ab\"))\n    print(sol.countKeyChanges(\"bBBb\"))\n    print(sol.countKeyChanges(\"abccddd\"))", "groundtruth": "class Solution:\n    def countKeyChanges(self, s: str) -> int:\n        if len(s) == 1:\n            return 0\n        s = s.upper()\n        count = 0\n        for i in range(len(s)-1):\n            if s[i] != s[i + 1]:\n                count += 1\n        return count\n"}
{"task_id": "python/5", "content": "\nSample code:\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        if len(nums)==1:\n            return nums[0]\n        nums.sort()\n        neg_idx=0\n        neg_group=1\n        for i in range(len(nums)):\n            if nums[i]<0:\n                neg_group*=nums[i]\n                neg_idx+=1\n            else:\n                break\n        if neg_idx<=1:\n            neg_group=0\n        if neg_idx%2==0:\n            neg_group=neg_group//nums[neg_idx-1]\n        pos_group=0\n        while i<len(nums):  # start\n            if nums[i]>0 and pos_group==0:\n                pos_group=nums[i]\n            elif nums[i]>0:\n                pos_group*=nums[i]\n            i+=1\n        if neg_group==0:  # here has a bug  \n            return max(neg_group,pos_group)  # end\n        else:\n            return neg_group*pos_group\n\n\n\n\n", "groundtruth": "class Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        if len(nums)==1:return nums[0]\n        nums.sort()\n        neg_idx=0\n        neg_group=1\n        for i in range(len(nums)):\n            if nums[i]<0:\n                neg_group*=nums[i]\n                neg_idx+=1\n            else:\n                break\n        if neg_idx<=1:\n            neg_group=0\n        if neg_idx%2!=0:\n            neg_group=neg_group//nums[neg_idx-1]\n        pos_group=0\n        while i<len(nums):\n            if nums[i]>0 and pos_group==0:\n                pos_group=nums[i]\n            elif nums[i]>0:\n                pos_group*=nums[i]\n            i+=1\n        if min(neg_group,pos_group)==0:\n            return max(neg_group,pos_group)\n        else:\n            return neg_group*pos_group\n"}
{"task_id": "python/6", "content": "\"\"\"\n\n# -------------------------\n\"\"\"\ndescription:\nYou are given a 0-indexed integer array nums, and you are allowed to traverse between its indices. You can traverse between index i and index j, i != j, if and only if gcd(nums[i], nums[j]) > 1, where gcd is the greatest common divisor.\n Your task is to determine if for every pair of indices i and j in nums, where i < j, there exists a sequence of traversals that can take us from i to j.\n Return true if it is possible to traverse between all such pairs of indices, or false otherwise.\n contraints:\n 1 <= nums.length <= 10^5\n 1 <= nums[i] <= 10^5\n\"\"\"\n\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        if len(nums)==1:\n            return True\n\n        nums = set(nums)\n        if 1 in nums:\n            return False\n        if len(nums) == 1:\n            return True\n        \n        # nums = sorted(nums, reverse=True)  # start\n        nums = sorted(nums)  # start\n\n        for i in range(len(nums)-1):\n            for j in range(i+1, len(nums)):\n                if gcd(nums[i],nums[j]) - 1 == 0: # here has a bug\n                    # nums[j] *= nums[i]  # end\n                    break\n            else:\n                return False\n        return True", "groundtruth": "class Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        if len(nums)==1:return True\n        nums = set(nums)\n        if 1 in nums:return False\n        if len(nums)==1:return True  \n        \n        nums = sorted(nums,reverse=True)\n\n        for i in range(len(nums)-1):\n            for j in range(i+1,len(nums)):\n                if gcd(nums[i],nums[j])-1:\n                    nums[j]*=nums[i]\n                    break\n            else:\n                return False\n        return True\n"}
{"task_id": "python/7", "content": "\nSolution:\n\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        def solve(R):\n            nR = len(R)\n            @cache\n            def dfs(n, x, tight):  # start\n                if x > max_sum: return 0  #\n                if n == 0:\n                    return min_sum <= x <= max_sum  # end\n                ubound = ord(R[nR-n]) - ord('0') if tight else 9\n                res = 0\n                for dig in range(ubound+1):\n                    res += dfs(n-1, x+dig, tight and (dig == ubound))\n                return res % MOD\n            return dfs(nR, 0, 1)\n        return (solve(num2) - solve(str(int(num1)-1))) % MOD\n\nPlease describe the meaning of each step in detail.\n\nSolution:\n\nThe code to be corrected is as follows:\nfrom functools import cache\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        def solve(R):\n            nR = len(R)\n            @cache\n            def dfs(n, x, tight):  # start\n                if x < max_sum: return 0  #\n                if n == 0:\n                    return min_sum <= x <= max_sum  # end\n                ubound = ord(R[nR-n]) - ord('0') if tight else 9\n                res = 0\n                for dig in range(ubound+1):\n                    res += dfs(n-1, x+dig, tight and (dig == ubound))\n                return res % MOD\n            return dfs(nR, 0, 1)\n        return (solve(num2) - solve(str(int(num1)-1))) % MOD\n\nThe `solve` function calculates", "groundtruth": "from functools import cache\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        def solve(R):\n            nR = len(R)\n            @cache\n            def dfs(n, x, tight):\n                if x > max_sum: return 0\n                if n == 0:\n                    return min_sum <= x <= max_sum \n                ubound = ord(R[nR-n]) - ord('0') if tight else 9\n                res = 0\n                for dig in range(ubound+1):\n                    res += dfs(n-1, x+dig, tight and (dig == ubound))\n                return res % MOD\n            return dfs(nR, 0, 1)\n        return (solve(num2) - solve(str(int(num1)-1))) % MOD\n"}
{"task_id": "python/8", "content": "\nSample Testcase 1:\n\nInput\n\"0011\"\nOutput\n2\nExplanation: Apply the operation on index 2 with cost 2 (i.e., invert all characters to '0'). Then apply the operation on index 3 with cost 3 (i.e., invert all characters to '1').Total cost = 2 + 3 = 5.There is no way the total cost can be less than 5.\n\n\nSample Testcase 2:\n\nInput\n\"010101\"\nOutput\n9\nExplanation: Apply the operation on index 1 with cost 2 (i.e., invert all characters to '1'). Then apply the operation on index 3 with cost 4 (i.e., invert all characters to '0'). Then apply the operation on index 5 with cost 6 (i.e., invert all characters to '1').Total cost = 2 + 4 + 6 = 12.There is no way the total cost can be less than 12.", "groundtruth": "class Solution:\n    def minimumCost(self, s: str) -> int:\n\n        n, count = len(s), 0\n        for i in range(1, (n//2)+1):\n            if s[i-1] != s[i]:\n                count += i\n\n        for i in range((n//2)+1, n):\n            if s[i-1] != s[i]:\n                count += n-i\n\n        return count\n"}
{"task_id": "python/9", "content": "'''\n\n\n\n# Solution: \n\nclass Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        \n        if nums[0] == 1 and nums[len(nums) - 1] == len(nums):\n            return 0\n        \n        op = 0\n        min_idx = nums.index(min(nums))\n        max_idx = nums.index(max(nums))  # start\n        if min_idx < max_idx:\n            op = min_idx + (len(nums) - 1 - max_idx)\n        if min_idx > max_idx:\n            op = min_idx + (len(nums) - 1 - max_idx) + 1\n        \n        return op # end\n\n# TC: O(N)\n# SC: O(1)", "groundtruth": "class Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        \n        if nums[0] == 1 and nums[len(nums) - 1] == len(nums):\n            return 0\n        \n        op = 0\n        min_idx = nums.index(min(nums))\n        max_idx = nums.index(max(nums))\n        if min_idx < max_idx:\n            op = min_idx + (len(nums) - 1 - max_idx)\n        if min_idx > max_idx:\n            op = min_idx + (len(nums) - 1 - max_idx) - 1\n        \n        return op\n\n"}
{"task_id": "python/10", "content": "", "groundtruth": "class Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n\n        n = len(nums1)\n        sp = list(zip(nums1, nums2))\n        sp.sort(reverse=True)\n        nsp  =[]\n        py = -1\n        nx = []\n        ny = []\n        sl = []\n        for x,y in sp:\n            if y>py:\n                nsp.append([x,y])\n                py = y\n                sl.append(x+y)\n                nx.append(x)\n                ny.append(y)\n        nx = nx[::-1]\n        nn = len(sl)\n        res = []\n\n        for x,y in queries:  # start\n            xp = nn-bisect.bisect_left(nx,x)\n            yp = bisect.bisect_left(ny,y)\n            if sl[yp:xp]:\n                res.append(max(sl[yp:xp]))\n            else:\n                res.append(-1)  # end\n        return res\n"}
{"task_id": "python/11", "content": "\"\"\"\ndef countPerm(self, nums: List[int]) -> int:\n    n = len(nums)\n    special_nums = defaultdict(list)\n    special_nums[-1] = list(range(n))  # start\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                special_nums[nums[i]].append(i)\n                special_nums[nums[j]].append(j)\n\n    @cache\n    def countPerm(mask, lastDigit):\n        if mask == (2 ** n) - 1:\n            return 1\n        ans = 0\n        for i in special_nums[lastDigit]:\n            if mask & 1 << i:\n                continue\n            ans += countPerm(mask | 1 << i, nums[i])\n        return ans\n\n    return countPerm(0, -1) % (10 ** 9 + 7)  # end\n\n\"\"\"\nHere is the corrected code:\nclass Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        n = len(nums)\n        special_nums = defaultdict(list)\n        special_nums[-1] = list(range(n))  # start\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                    special_nums[nums[i]].append(i)\n                    special_nums[nums[j]].append(j)\n\n        @cache\n        def countPerm(mask, lastDigit):\n            if mask == (2 ** n) - 1:\n                return 1\n            ans = 0\n            for i in special_nums[lastDigit]:\n                if mask & 1 << i:\n                    continue\n               ", "groundtruth": "class Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        n = len(nums)\n        special_nums = defaultdict(list)\n        special_nums[-1] = list(range(n))\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                    special_nums[nums[i]].append(j)\n                    special_nums[nums[j]].append(i)\n        @cache\n        def countPerm(mask, lastDigit):\n            if mask == (2 ** n) - 1:\n                return 1\n            ans = 0\n            for i in special_nums[lastDigit]:\n                if mask & 1 << i:\n                    continue\n                ans += countPerm(mask | 1 << i, nums[i])\n            return ans\n        return countPerm(0, -1) % (10**9 + 7)\n"}
{"task_id": "python/12", "content": "*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int paintWalls(vector<int> &cost, vector<int> &time)\n    {\n        int n = time.size();\n        int INF = 1e9 + 1;\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n        for (int i = 1; i <= n; i++)\n        {\n            int c0 = INF;\n            for (int j = 1; j <= n; j++)\n            {\n                int i0 = i - time[j - 1];\n                if (i0 < 0)\n                    i0 = 0;\n                int c1 = cost[j - 1] + dp[i0][j - 1];\n                if (c0 > c1)\n                    c0 = c1;\n                dp[i][j] = c0;\n            }\n        }\n        return dp[n][n];\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector<int> cost = {1, 2, 3, 4};\n    vector<int> time = {1, 1, 1, 1};\n    cout << s.paintWalls(cost, time) << endl;\n    return 0;\n}", "groundtruth": "class Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(time)\n        INF = 10**9+1\n        dp = [[0 if i==0 else INF]*(n+1) for i in range(n+1)]\n        for i in range(1, n+1):\n            c0 = INF\n            for j, (t, c) in enumerate(zip(time, cost), 1):\n                i0 = max(i-t-1, 0)\n                c1 = c + dp[i0][j-1]\n                if c0 > c1:\n                    c0 = c1\n                dp[i][j] = c0\n        return dp[-1][-1]\n"}
{"task_id": "python/13", "content": "\"\"\"\n\n# Solution:\nclass Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        # Sort based on position\n        arr = []\n        for i in range(len(positions)):\n            arr.append([positions[i],healths[i],directions[i],i+1])\n        arr.sort(key = lambda x: x[0])\n\n        # Use Stack DS to emulate the scene\n        right = [] # stores the right moving bots\n        left = [] # stores the left moving bots\n\n        for i in range(0, len(arr)):  # start\n            # same direction append to stack\n            if arr[i][2] == 'R':\n                right.append(arr[i])\n            # different direction\n            else:\n                if right:\n                    # pop the last element\n                    bot1 = right.pop()\n                    # compare the strenghts\n                    if bot1[1] > arr[i][1]:\n                        bot1[1] -= 1\n                        right.append(bot1)\n                    elif bot1[1] < arr[i][1]:\n                        arr[i][1] -= 1\n                        while right:\n                            bot1 = right.pop()\n                            arr[i][1] -= 1\n                        if not right and arr[i][1] > 0:\n                            left.append(arr[i])\n                        elif right[-1][1] != arr[i][1]:\n                            right.pop()\n                        else:\n                            right[-1][1] -= 1\n                else:\n                    left.append(arr[i])  # end\n        stack = left + right\n        stack.sort(key = lambda x: x[-1])\n        return [stack[i][1] for i in range(len(stack))]", "groundtruth": "class Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        # Sort based on position\n        arr = []\n        for i in range(len(positions)):\n            arr.append([positions[i],healths[i],directions[i],i+1])\n        arr.sort(key = lambda x: x[0])\n\n        # Use Stack DS to emulate the scene\n        right = [] # stores the right moving bots\n        left = [] # stores the left moving bots\n\n        for i in range(0, len(arr)):\n            # same direction append to stack\n            if arr[i][2] == 'R':\n                right.append(arr[i])\n            # different direction\n            else:\n                if right:\n                    # pop the last element\n                    bot1 = right.pop()\n                    # compare the strenghts\n                    if bot1[1] > arr[i][1]:\n                        bot1[1] -= 1\n                        right.append(bot1)\n                    \n                    elif bot1[1] < arr[i][1]:\n                        arr[i][1] -= 1\n                        while right and right[-1][1] < arr[i][1]:\n                            bot1 = right.pop()\n                            arr[i][1] -= 1\n                        if not right and arr[i][1] > 0:\n                            left.append(arr[i])\n                        elif right[-1][1] == arr[i][1]:\n                            right.pop()\n                        else:\n                            right[-1][1] -= 1\n                else:\n                    left.append(arr[i])\n        stack = left + right\n        stack.sort(key = lambda x: x[-1])\n        return [stack[i][1] for i in range(len(stack))]\n"}
{"task_id": "python/14", "content": "\n\n\nclass Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        prime=[0]*(n+1)\n        prime[0]=1\n        prime[1]=1  # start\n        for x in range(2,n+1):\n            if prime[x]==0:\n                i=x\n                while x*i<=n:\n                    if prime[x*i]==0:\n                        prime[x*i]=1\n                    i+=1\n        result=[]\n        for x in range(2,((n//2)+1)):\n            if prime[x]==0 and prime[n-x]==0:\n                result.append([x,n-x])\n        return result  # end\n\n\n\n# 作者：jane-27\n# 链接：https://leetcode.com/problems/find-prime-pairs-with-target-sum/discuss/2431426/C-code-to-be-corr\n# 来源：力扣（LeetCode）\n# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。", "groundtruth": "class Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        prime=[0]*(n+1)\n        prime[0]=1\n        prime[1]=1\n        for x in range(2,n+1):\n            if prime[x]==0:\n                i=x\n                while x*i<=n:\n                    if prime[x*i]==0:\n                        prime[x*i]=1\n                    i+=1\n        result=[]\n        for x in range(2,((n//2)+1)):\n            if prime[x]==0 and prime[n-x]==0:\n                result.append([x,n-x])\n        return result\n"}
{"task_id": "python/15", "content": "\nOutput:\n\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        ### Add first 2 nums to map, check for gap\n        indices = {}\n        total = 0\n        prev = 0\n        indices[nums[0]] = 0\n        for i in range(1, len(nums)):\n            curSum = prev\n            below_index = indices[nums[i]-1] if nums[i]-1 in indices else -1\n            above_index = indices[nums[i]+1] if nums[i]+1 in indices else -1\n            cur_index = indices[nums[i]] if nums[i] in indices else -1\n            soonest_zero_imbalance = max(min(below_index, above_index), cur_index)\n            if soonest_zero_imbalance == -1:\n                curSum += i\n            else:\n                curSum -= i - soonest_zero_imbalance + 1\n            if below_index != -1 and above_index != -1 and min(below_index, above_index) > cur_index:\n                curSum += min(below_index, above_index) - 1\n                if cur_index != -1:\n                    curSum += cur_index + 1\n            total += curSum\n            prev = curSum \n            indices[nums[i]] = i\n        return total\n\n'''", "groundtruth": "class Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        ### Add first 2 nums to map, check for gap\n        indices = {}\n        total = 0\n        prev = 0\n        indices[nums[0]] = 0\n        for i in range(1, len(nums)):  # start\n            curSum = prev\n            below_index = indices[nums[i]-1] if nums[i]-1 in indices else -1\n            above_index = indices[nums[i]+1] if nums[i]+1 in indices else -1\n            cur_index = indices[nums[i]] if nums[i] in indices else -1\n            soonest_zero_imbalance = max(max(below_index, above_index), cur_index)\n            if soonest_zero_imbalance == -1:\n                curSum += i\n            else:\n                curSum += i - soonest_zero_imbalance - 1\n            if below_index != -1 and above_index != -1 and min(below_index, above_index) > cur_index:\n                curSum -= min(below_index, above_index) + 1\n                if cur_index != -1:\n                    curSum += cur_index + 1\n            total += curSum  # end\n            prev = curSum \n            indices[nums[i]] = i\n        return total\n"}
{"task_id": "python/16", "content": "```\n\n#### Answer\n\n```python\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        n = len(usageLimits)\n        count = [0] * (n+1)\n        for i in range(n):\n            count[min(usageLimits[i], n)] += 1\n        ans = 0\n        needMore = 0\n        j = n\n        stack = []\n        for i in range(n):\n            ans -= 1\n            needMore += 1\n            while j > 1 and count[j] < needMore:\n                if count[j] > 0:\n                    stack.append((j+ans-1, count[j]))\n                needMore -= count[j]\n                count[j] = 0\n                j -= 1\n            if count[j] < needMore:\n                ans += 1\n                break\n            count[j-1] -= needMore\n            count[j] += needMore\n            while stack and stack[-1][0] - ans == j:\n                count[j] += stack[-1][1]\n                needMore += stack[-1][1]\n                stack.pop()\n        return ans\n```\n\n### [Task 2](./Task%202.md)\n\n#### Question\n\n```\n\nGiven an array nums of n integers where n > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\n\nExample:\n\nInput:  [1,2,3,4]\nOutput: [24,12,8,6]\nConstraint: It's guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.\n\nNote: Please solve it without division and in O(n).\n\nFollow up:\nCould you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)\n```\n\n#### Answer\n\n```python\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:", "groundtruth": "class Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        n = len(usageLimits)\n        count = [0] * (n+1)\n        for i in range(n):\n            count[min(usageLimits[i], n)] += 1\n        ans = 0\n        needMore = 0\n        j = n\n        stack = []\n        for i in range(n):\n            ans += 1\n            needMore += 1\n            while j > 1 and count[j] < needMore:\n                if count[j] > 0:\n                    stack.append((j+ans-1, count[j]))\n                needMore -= count[j]\n                count[j] = 0\n                j -= 1\n            if count[j] < needMore:\n                ans -= 1\n                break\n            count[j-1] += needMore\n            count[j] -= needMore\n            while stack and stack[-1][0] - ans == j:\n                count[j] += stack[-1][1]\n                needMore += stack[-1][1]\n                stack.pop()\n        return ans\n"}
{"task_id": "python/17", "content": "\nExamples:\n\nExample 1:\n\nInput: parent = [-1,0,0,1,1,2], s = \"acaabc\"\nOutput: 8\nExplanation:\n- (0,1): \"a\"\n- (0,2): \"a\"\n- (1,3): \"c\"\n- (1,4): \"c\"\n- (2,5): \"a\"\n- (3,3): \"\"\n- (4,4): \"\"\n- (5,5): \"a\"\nIt can be shown that there are 8 palindrome paths from node 0 to 5.\n\nExample 2:\n\nInput: parent = [-1,0,0,0], s = \"aaaa\"\nOutput: 10\nExplanation:\n- (0,1): \"a\"\n- (0,2): \"a\"\n- (0,3): \"a\"\n- (1,1): \"\"\n- (1,2): \"a\"\n- (1,3): \"a\"\n- (2,2): \"\"\n- (2,3): \"a\"\n- (3,3): \"\"\nIt can be shown that there are 10 palindrome paths from node 0 to 3.\n\nExample 3:\n\nInput: parent = [-1,0,1], s = \"abc\"\nOutput: 0\nExplanation:\nNo palindromic paths.\nThe only palindromic path is the one from node 1 to node 1.\nIt can be shown that there are 0 palindrome paths from node 0 to 2.\n\n\"\"\"\n\nimport sys\n\nsys.setrecursionlimit(10000000)\n\n\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        edges = defaultdict(list)\n        amnts = defaultdict(int)\n        self.res = 0\n\n        for u, v in enumerate(parent):\n            edges[v].append(u)\n\n        def dfs(curr, mask):\n            self.res += amnts[mask]", "groundtruth": "from collections import defaultdict\n\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        edges = defaultdict(list)\n        amnts = defaultdict(int)\n        self.res = 0\n        \n        for u, v in enumerate(parent):\n            edges[v].append(u)\n\n        def dfs(curr, mask):\n            # print(curr, format(mask, '08b'))\n            for i in range(26):\n                new_mask = mask ^ (1 << i)\n                self.res += amnts[new_mask]\n            self.res += amnts[mask]\n            amnts[mask] += 1\n            for i in edges[curr]:\n                idx = ord(s[i]) - ord('a')\n                dfs(i, mask ^ (1 << idx))\n            \n        dfs(0, 0)\n        return self.res\n"}
{"task_id": "python/18", "content": "## 1st code\n\n```python\nclass Solution:\n    def countSteppingNumbers(self, low, high):\n        low = \"0\"*(len(high)-len(low)) + low\n        mod = 10**9 + 7\n        @lru_cache(None)\n        def dfs(i,is_greater_thn_low,is_less_thn_high,prev_digit,nonzero):\n            if i == len(high):\n                return 1\n            total = 0\n            start = int(low[i]) if not is_greater_thn_low else 0\n            end = int(high[i]) + 1 if not is_less_thn_high else 10\n            for nx_digit in range(start,end):  \n                if not nonzero or abs(prev_digit - nx_digit) == 1:\n                    total += dfs(i+1,is_greater_thn_low or nx_digit > int(low[i]),is_less_thn_high,nx_digit,nonzero)\n            return total%mod\n        return dfs(0, False, False, -1, False)\n```\n\n## 2nd code\n\n```python\nclass Solution:\n    def countSteppingNumbers(self, low, high):\n        low = \"0\"*(len(high)-len(low)) + low\n        mod = 10**9 + 7\n        @lru_cache(None)\n        def dfs(i,is_greater_thn_low,is_less_thn_high,prev_digit,nonzero):\n            if i == len(high):\n                return 1\n            total = 0\n            start = int(low[i]) if not is_greater_thn_low else 0\n            end = int(high[i]) + 1 if not is_less_thn_high else 10\n            for nx_digit in range(start,end):\n                if not nonzero or abs(prev_digit - nx_digit) == 1:\n                    total += dfs(i+1,is_great", "groundtruth": "class Solution:\n    def countSteppingNumbers(self, low, high):\n        low = \"0\"*(len(high)-len(low)) + low\n        \n        mod = 10**9 + 7\n        \n        @lru_cache(None)\n        def dfs(i,is_greater_thn_low,is_less_thn_high,prev_digit,nonzero):\n            if i == len(high):\n                return 1\n            \n            total = 0\n            \n            start = int(low[i]) if not is_greater_thn_low else 0\n            end = int(high[i]) + 1 if not is_less_thn_high else 10\n            \n            for nx_digit in range(start,end):\n                if not nonzero or abs(prev_digit - nx_digit) == 1:\n                    total += dfs(i+1,is_greater_thn_low or nx_digit > int(low[i]),is_less_thn_high or nx_digit < int(high[i]),nx_digit,nonzero or nx_digit != 0)\n                    \n            return total%mod\n\n        return dfs(0, False, False, -1, False)\n"}
{"task_id": "python/19", "content": "\nInput\nThe input contains an integer n which indicates the number.\n\nConstraints\n100≤n<1000\n\nOutput\nOutput true if the given number is fascinating. Otherwise output false.\n\nExamples\nExample 1\nInput\nOutput\n192\ntrue\n\nExplanation\nconcatenate 192 with 384 and 576, therefor \"192384576\" contains all the digits from 1 to 9 exactly once.\nExample 2\nInput\nOutput\n236\nfalse\n\nExplanation\nThe resulting number \"23647216\" contains the digit 2 twice.\n\n\ndef isFascinating(self, n):\n    n2 = n * 2\n    n3 = n * 3\n    n1 = str(n) + str(n2) + str(n3)\n    s = ''.join(sorted(n1))\n    if '0' in s or '123456789' != s:\n        return False\n    return True\n\n\n    # or\n    return len(set(str(n)+str(2*n)+str(3*n))) == 9 and '0' not in str(n)+str(2*n)+str(3*n)\n\n\"\"\"\n\n\ndef isFascinating(n):\n    n2 = n * 2\n    n3 = n * 3\n    n1 = str(n) + str(n2) + str(n3)\n    s = ''.join(sorted(n1))\n    if '0' in s or '123456789' != s:\n        return False\n    return True\n\n\nprint(isFascinating(123))\n\n\nclass Solution:\n    def isFascinating(self, n: int) -> bool:\n        n2 = 2 * n\n        n3 = 3 * n\n\n        concatenated = str(n) + str(n2) + str(n3)\n\n        if '0' in concatenated:\n            return False\n        if len(concatenated", "groundtruth": "class Solution:\n    def isFascinating(self, n: int) -> bool:\n        concatenated = str(n) + str(2 * n) + str(3 * n)\n\n        if '0' in concatenated:\n            return False\n        if len(concatenated)>9:\n            return False\n        for i in range(1,10):\n            if str(i) not in concatenated :\n                return False\n        return True\\n\n"}
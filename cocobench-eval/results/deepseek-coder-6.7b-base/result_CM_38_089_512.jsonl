{"task_id": "python/0", "content": "\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nint main(int argc, char *argv[])\n{\n    int nums[5] = {5,4,1,2,2};\n    int ans = 0;\n    int i, j, k;\n    int cnt[32] = {0};\n\n    for(i = 0; i < 5; i++) {\n        for(j = 0; j < 32; j++) {\n            if((nums[i] & (1 << j)) != 0) {\n                cnt[j]++;\n            }\n        }\n    }\n\n    for(i = 0; i < 32; i++) {\n        if(cnt[i] > 1) {\n            ans += 1 << i;\n        }\n    }\n\n    printf(\"maximumLength: %d\\n\", ans);\n\n    return 0;\n}", "groundtruth": "class Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        ans = cnt[1] - 1 | 1  \n        del cnt[1]\n        for x in cnt:\n            res = 0\n            while cnt[x] > 1:\n                res += 2\n                x *= x\n            ans = max(ans, res + (1 if x in cnt else -1))  \n        return ans\n"}
{"task_id": "python/1", "content": "Please also give a short reasoning for the correctness of the given code.\n'''\n\n# 2 2 10\nclass Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:  # start\n        min1, min2 = 0, 0\n        for i in prices:\n            if min1 > i:\n                min2 = min1\n                min1=i\n            elif min2 > i :  # end\n                min2 = i\n        if ( min1 + min2 ) > money:\n            return money\n        else:\n            return money - (min1 + min2)\n\n# 20 3 1 4\nclass Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:  # start\n        min1, min2 = 0, 0\n        for i in prices:\n            if min1 > i:\n                min2 = min1\n                min1=i\n            elif min2 > i :  # end\n                min2 = i\n        if ( min1 + min2 ) > money:\n            return money\n        else:\n            return money - (min1 + min2)\n\n# 16 2 3 5 8\nclass Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:  # start\n        min1, min2 = 0, 0\n        for i in prices:\n            if min1 > i:\n                min2 = min1\n                min1=i\n            elif min2 > i :  # end\n                min2 = i\n        if ( min1 + min2 ) > money:\n            return money\n        else:\n            return money - (min1 + min2)\n\n# 2 3 4\nclass Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:  # start\n        min1, min2 = 0, 0\n        for i in prices:\n            if min1 > i:\n                min2 = min1\n                min1=i\n            elif min2 > i :  # end\n                min2", "groundtruth": "class Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        min1, min2 = 99999999, 99999999\n        for i in prices:\n            if min1 > i:\n                min2 = min1\n                min1=i\n            elif min2 > i :\n                min2 = i\n        if ( min1 + min2 ) > money:\n            return money\n        else:\n            return money - (min1 + min2)\n"}
{"task_id": "python/2", "content": "", "groundtruth": "from typing import List\n\nclass Solution:\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\n        sumi = 0\n        row = set()\n        col = set()\n\n        for a, b, c in reversed(queries):\n            if a == 0:\n                if b not in row:\n                    row.add(b)\n                    sumi += c * (n - len(col))\n            else:\n                if b not in col:\n                    col.add(b)\n                    sumi += c * (n - len(row))\n        \n        return sumi\n"}
{"task_id": "python/3", "content": "\n\n\n\n'''\n\nclass Solution:\n\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n\n        values = [(v, r, c) for r, row in enumerate(mat) for c, v in enumerate(row)]\n        values.sort(reverse=True)\n\n        bestInRow = [0 for _ in range(m)]\n        bestInCol = [0 for _ in range(n)]\n        prevV = None\n        updates = []\n        answer = 1\n\n        for v, r, c in values:\n            if prevV != v:\n                prevV = v\n                for bu, ru, cu in updates:\n                    if bestInRow[ru] < bu:\n                        bestInRow[ru] = bu\n\n                    if bestInCol[cu] < bu:\n                        bestInCol[cu] = bu\n                updates.clear()\n\n            best = bestInRow[r]\n            if best < bestInCol[c]:\n                best = bestInCol[c]\n            best += 2  \n\n            if answer < best:\n                answer = best\n\n            updates.append((best,r,c))\n\n        return answer\n\n\n\n\n'''\n\n\nfrom bisect import bisect_left\nclass Solution:\n\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n\n        values = [(v, r, c) for r, row in enumerate(mat) for c, v in enumerate(row)]\n        values.sort(reverse=True)\n\n        bestInRow = [0 for _ in range(m)]\n        bestInCol = [0 for _ in range(n)]\n        prevV = None\n        updates = []\n        answer = 1\n\n        for v, r, c in values:\n            if prevV != v:\n                prevV = v\n                for bu, ru, cu in updates:\n                    if bestInRow[ru] < bu", "groundtruth": "import bisect\nclass Solution:\n\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n\n        values = [(v, r, c) for r, row in enumerate(mat) for c, v in enumerate(row)]\n        values.sort(reverse=True)\n\n        bestInRow = [0 for _ in range(m)]\n        bestInCol = [0 for _ in range(n)]\n        prevV = None\n        updates = []\n        answer = 1\n\n        for v, r, c in values:\n            if prevV != v:\n                prevV = v\n                for bu, ru, cu in updates:\n                    if bestInRow[ru] < bu:\n                        bestInRow[ru] = bu\n\n                    if bestInCol[cu] < bu:\n                        bestInCol[cu] = bu\n                updates.clear()\n\n            best = bestInRow[r]\n            if best < bestInCol[c]:\n                best = bestInCol[c]\n            best += 1\n\n            if answer < best:\n                answer = best\n\n            updates.append((best,r,c))\n\n        return answer\n"}
{"task_id": "python/4", "content": "\n\"\"\"\nclass Solution:\n    def countKeyChanges(self, s: str) -> int:\n        if len(s) == 1:\n            return 0\n        s = s.upper()\n        count = 0\n        for i in range(len(s)-1):\n            if s[i] != s[i + 1]:\n                count += 1\n        return count\n\n\n\n\"\"\"\nProblem Statement\nProblem Description\nYou are given a binary tree and you are asked to find the diameter of that tree. The diameter of a binary tree is the length of the longest path between any two nodes in the tree.\n\nThe tree is defined as follows:\n\nclass TreeNode:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nGiven a binary tree root, return the diameter of the tree.\n\nExample 1:\n\nInput:\n\nTree:\n\n     1\n    / \\\n   2   3\n\nOutput: 2\nExplanation: The diameter of the tree is 2 because the path [1, 2] has the maximum length.\nExample 2:\n\nInput:\n\nTree:\n\n     1\n    / \\\n   2   3\n  / \\\n 4   5\n\nOutput: 3\nExplanation: The diameter of the tree is 3 because the path [1, 2, 3] has the maximum length.\n\nExample 3:\n\nInput:\n\nTree:\n\n     1\n    / \\\n   2   3\n    \\\n     5\n\nOutput: 2\nExplanation: The diameter of the tree is 2 because the path [1, 3] has the maximum length.\n\nConstraints:\n\n1 <= number of nodes <= 105\n1 <= node.val <= 105\n\"\"\"\n\n\"\"\"\nThis is a simple algorithm problem that can be solved using the depth-first search (DFS) algorithm.\n\nThe algorithm works by starting at the root node of the tree and recursively visiting each node of the tree. For each node, it calculates the maximum depth of the left and right subtrees and returns the maximum depth. The algorithm", "groundtruth": "class Solution:\n    def countKeyChanges(self, s: str) -> int:\n        if len(s) == 1:\n            return 0\n        s = s.upper()\n        count = 0\n        for i in range(len(s)-1):\n            if s[i] != s[i + 1]:\n                count += 1\n        return count\n"}
{"task_id": "python/5", "content": "\nCorrected Code:\n\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        if len(nums)==1:return nums[0]\n        nums.sort()\n        neg_idx=0\n        neg_group=1\n        for i in range(len(nums)):\n            if nums[i]<0:\n                neg_group*=nums[i]\n                neg_idx+=1\n            else:\n                break\n        if neg_idx<=1:\n            neg_group=0\n        if neg_idx%2==0:\n            neg_group=neg_group//nums[neg_idx-1]\n        pos_group=0\n        while i<len(nums):  # start\n            if nums[i]>0 and pos_group==0:\n                pos_group=nums[i]\n            elif nums[i]>0:\n                pos_group*=nums[i]\n            i+=1\n        if neg_group==0:  # here has a bug  \n            return max(neg_group,pos_group)  # end\n        else:\n            return neg_group*pos_group\n", "groundtruth": "class Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        if len(nums)==1:return nums[0]\n        nums.sort()\n        neg_idx=0\n        neg_group=1\n        for i in range(len(nums)):\n            if nums[i]<0:\n                neg_group*=nums[i]\n                neg_idx+=1\n            else:\n                break\n        if neg_idx<=1:\n            neg_group=0\n        if neg_idx%2!=0:\n            neg_group=neg_group//nums[neg_idx-1]\n        pos_group=0\n        while i<len(nums):\n            if nums[i]>0 and pos_group==0:\n                pos_group=nums[i]\n            elif nums[i]>0:\n                pos_group*=nums[i]\n            i+=1\n        if min(neg_group,pos_group)==0:\n            return max(neg_group,pos_group)\n        else:\n            return neg_group*pos_group\n"}
{"task_id": "python/6", "content": "\"\"\"\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        if len(nums)==1:\n            return True\n        \n        nums = set(nums)\n        if 1 in nums:\n            return False\n        if len(nums) == 1:\n            return True\n        \n        nums = sorted(nums, reverse=True)\n\n        for i in range(len(nums)-1):\n            for j in range(i+1, len(nums)):\n                if gcd(nums[i],nums[j]) - 1 == 0:\n                    nums[j] *= nums[i]\n                    break\n            else:\n                return False\n        return True", "groundtruth": "class Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        if len(nums)==1:return True\n        nums = set(nums)\n        if 1 in nums:return False\n        if len(nums)==1:return True  \n        \n        nums = sorted(nums,reverse=True)\n\n        for i in range(len(nums)-1):\n            for j in range(i+1,len(nums)):\n                if gcd(nums[i],nums[j])-1:\n                    nums[j]*=nums[i]\n                    break\n            else:\n                return False\n        return True\n"}
{"task_id": "python/7", "content": "\nI'm not sure if the code is correct or not. It's hard to test this because I don't know the output for the input.\n\nThis is the code with comments:\nfrom functools import cache\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        def solve(R):\n            nR = len(R)\n            @cache\n            def dfs(n, x, tight):  # start\n                if x < max_sum: return 0  # if x < max_sum, return 0, it's a base case\n                if n == 0:\n                    return min_sum <= x <= max_sum  # end, return 1 if x is in the range, else 0\n                ubound = ord(R[nR-n]) - ord('0') if tight else 9\n                res = 0\n                for dig in range(ubound+1):\n                    res += dfs(n-1, x+dig, tight and (dig == ubound))\n                return res % MOD\n            return dfs(nR, 0, 1)\n        return (solve(num2) - solve(str(int(num1)-1))) % MOD\n\n\nA: You want to count the number of integers that are between num1 and num2 (inclusive) and satisfy the conditions.\nIf you want to count the number of integers that are between 100 and 200 (inclusive) and satisfy the conditions, then you can do the following:\n\n*\n\n*Create a list of digits (e.g. [1,0,0,2,0,0])\n\n*Iterate through the list and add the digits\n\n*If the sum of the digits is between min_sum and max_sum, then increment a counter\n\n*Return the counter\n\nHere is an example of how you can do this in Python:\ndef count(num1, num2, min_sum, max_sum):\n    count = 0\n    for i in range(int(num1), int(num2) + 1):\n       ", "groundtruth": "from functools import cache\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        def solve(R):\n            nR = len(R)\n            @cache\n            def dfs(n, x, tight):\n                if x > max_sum: return 0\n                if n == 0:\n                    return min_sum <= x <= max_sum \n                ubound = ord(R[nR-n]) - ord('0') if tight else 9\n                res = 0\n                for dig in range(ubound+1):\n                    res += dfs(n-1, x+dig, tight and (dig == ubound))\n                return res % MOD\n            return dfs(nR, 0, 1)\n        return (solve(num2) - solve(str(int(num1)-1))) % MOD\n"}
{"task_id": "python/8", "content": "\n## Solution:\n\n```python\nclass Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        count = 0\n        if s[0] != s[-1]:\n            count += n\n        for i in range(1, (n//2)+1):\n            if s[i-1] != s[i]:\n                count += i\n        for i in range((n//2)+1, n):\n            if s[i-1] != s[i]:\n                count += n-i\n        return count\n```\n\n## Complexity Analysis:\n\n```\nTime Complexity: O(n)\nSpace Complexity: O(1)\n```", "groundtruth": "class Solution:\n    def minimumCost(self, s: str) -> int:\n\n        n, count = len(s), 0\n        for i in range(1, (n//2)+1):\n            if s[i-1] != s[i]:\n                count += i\n\n        for i in range((n//2)+1, n):\n            if s[i-1] != s[i]:\n                count += n-i\n\n        return count\n"}
{"task_id": "python/9", "content": "", "groundtruth": "class Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        \n        if nums[0] == 1 and nums[len(nums) - 1] == len(nums):\n            return 0\n        \n        op = 0\n        min_idx = nums.index(min(nums))\n        max_idx = nums.index(max(nums))\n        if min_idx < max_idx:\n            op = min_idx + (len(nums) - 1 - max_idx)\n        if min_idx > max_idx:\n            op = min_idx + (len(nums) - 1 - max_idx) - 1\n        \n        return op\n\n"}
{"task_id": "python/10", "content": "\n\n## Answer\n\n\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        N = len(nums1)\n        dp = []\n        for i in range(N):\n            dp.append(nums1[i]+nums2[i])\n        dp.sort()\n        def f(a,b):\n            return a>b\n        dp.sort(key=cmp_to_key(f))\n        res = []\n        for q in queries:\n            ans = -1\n            for d in dp:\n                if d>=q[0]+q[1]:\n                    ans = d\n                    break\n            res.append(ans)\n        return res", "groundtruth": "class Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n\n        n = len(nums1)\n        sp = list(zip(nums1, nums2))\n        sp.sort(reverse=True)\n        nsp  =[]\n        py = -1\n        nx = []\n        ny = []\n        sl = []\n        for x,y in sp:\n            if y>py:\n                nsp.append([x,y])\n                py = y\n                sl.append(x+y)\n                nx.append(x)\n                ny.append(y)\n        nx = nx[::-1]\n        nn = len(sl)\n        res = []\n\n        for x,y in queries:  # start\n            xp = nn-bisect.bisect_left(nx,x)\n            yp = bisect.bisect_left(ny,y)\n            if sl[yp:xp]:\n                res.append(max(sl[yp:xp]))\n            else:\n                res.append(-1)  # end\n        return res\n"}
{"task_id": "python/11", "content": "\"\"\"\n\n\nclass Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        n = len(nums)\n        special_nums = defaultdict(list)\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                    special_nums[nums[i]].append(i)\n                    special_nums[nums[j]].append(j)\n\n        @cache\n        def countPerm(mask, lastDigit):\n            if mask == (1 << n) - 1:\n                return 1\n            ans = 0\n            for i in special_nums[lastDigit]:\n                if mask & 1 << i:\n                    continue\n                ans += countPerm(mask | 1 << i, nums[i])\n            return ans\n\n        return countPerm(0, -1) % (10**9 + 7)\n\n\nnums = [2, 3, 6]\nprint(Solution().specialPerm(nums))\n\nnums = [1, 4, 3]\nprint(Solution().specialPerm(nums))\n\nnums = [2, 3, 6, 14, 2, 5]\nprint(Solution().specialPerm(nums))", "groundtruth": "class Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        n = len(nums)\n        special_nums = defaultdict(list)\n        special_nums[-1] = list(range(n))\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                    special_nums[nums[i]].append(j)\n                    special_nums[nums[j]].append(i)\n        @cache\n        def countPerm(mask, lastDigit):\n            if mask == (2 ** n) - 1:\n                return 1\n            ans = 0\n            for i in special_nums[lastDigit]:\n                if mask & 1 << i:\n                    continue\n                ans += countPerm(mask | 1 << i, nums[i])\n            return ans\n        return countPerm(0, -1) % (10**9 + 7)\n"}
{"task_id": "python/12", "content": "\nPlease make the code efficient.\n\"\"\"\n\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(time)\n        INF = 10**9+1\n        dp = [[0 if i==0 else INF]*(n+1) for i in range(n+1)]\n        for i in range(1, n+1):  # start\n            c0 = INF\n            for j, (t, c) in enumerate(zip(time, cost), 1):\n                i0 = i-t\n                c1 = c + dp[i0][j-1]\n                if c0 > c1:\n                    c0 = c1\n                dp[i][j] = c0\n        return dp[-1][-1]  # end\n\n\"\"\"\n2266. Count Increasing Quadruplets\n\nGiven a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that:\n nums[a] + nums[b] + nums[c] == nums[d], and\n a < b < c < d\n\nConstraints:\n 4 <= nums.length <= 50\n 1 <= nums[i] <= 100\n\nPlease correct the following code according to the description. The description is as follows:\nYou are given an array nums of n integers, and your task is to return the number of distinct quadruplets (a, b, c, d) in the array such that:\n nums[a] + nums[b] + nums[c] == nums[d], where a, b, c, and d are distinct indices in the array.\nNote that the order of the quadruplets (a, b, c, d) does not matter.\nThe code to be corrected is as follows:\nclass Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        res = 0\n        for i in range(n-3):\n            for j in range(i+1, n-2):\n", "groundtruth": "class Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(time)\n        INF = 10**9+1\n        dp = [[0 if i==0 else INF]*(n+1) for i in range(n+1)]\n        for i in range(1, n+1):\n            c0 = INF\n            for j, (t, c) in enumerate(zip(time, cost), 1):\n                i0 = max(i-t-1, 0)\n                c1 = c + dp[i0][j-1]\n                if c0 > c1:\n                    c0 = c1\n                dp[i][j] = c0\n        return dp[-1][-1]\n"}
{"task_id": "python/13", "content": "\n```\n\n**Example 1:**\n\n```\nInput: positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = \"RRRRR\"\nOutput: [2,12,11,10,5]\nExplanation: Robots 1 and 2 start to collide and survive, the final healths of the two robots are 17 and 11 respectively.\nRobots 3 and 4 start to collide and die, so they do not survive.\nRobot 5 survives, since it is the only one remaining.\n\n```\n\n**Example 2:**\n\n```\nInput: positions = [3,5,2,6], healths = [10,10,15,9], directions = \"RLRL\"\nOutput: [2,9,14,15]\nExplanation: Robots 1 and 3 start to collide and die, so they do not survive.\nRobots 2 and 4 start to collide and survive, the final healths of the two robots are 15 and 15 respectively.\n\n```\n\n \n\n**Constraints:**\n\n- `n == positions.length == healths.length == directions.length`\n- `1 <= n <= 10^5`\n- `1 <= positions[i], healths[i] <= 10^9`\n- `directions[i]` is either `'L'` or `'R'`\n- All positions are unique.\n\n\n\n## Solution\n\n```python\nclass Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        # Sort based on position\n        arr = []\n        for i in range(len(positions)):\n            arr.append([positions[i],healths[i],directions[i],i+1])\n        arr.sort(key = lambda x: x[0])\n\n        # Use Stack DS to emulate the scene\n        right = [] # stores the right moving bots\n        left = [] # stores the left moving bots", "groundtruth": "class Solution:\n    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n        # Sort based on position\n        arr = []\n        for i in range(len(positions)):\n            arr.append([positions[i],healths[i],directions[i],i+1])\n        arr.sort(key = lambda x: x[0])\n\n        # Use Stack DS to emulate the scene\n        right = [] # stores the right moving bots\n        left = [] # stores the left moving bots\n\n        for i in range(0, len(arr)):\n            # same direction append to stack\n            if arr[i][2] == 'R':\n                right.append(arr[i])\n            # different direction\n            else:\n                if right:\n                    # pop the last element\n                    bot1 = right.pop()\n                    # compare the strenghts\n                    if bot1[1] > arr[i][1]:\n                        bot1[1] -= 1\n                        right.append(bot1)\n                    \n                    elif bot1[1] < arr[i][1]:\n                        arr[i][1] -= 1\n                        while right and right[-1][1] < arr[i][1]:\n                            bot1 = right.pop()\n                            arr[i][1] -= 1\n                        if not right and arr[i][1] > 0:\n                            left.append(arr[i])\n                        elif right[-1][1] == arr[i][1]:\n                            right.pop()\n                        else:\n                            right[-1][1] -= 1\n                else:\n                    left.append(arr[i])\n        stack = left + right\n        stack.sort(key = lambda x: x[-1])\n        return [stack[i][1] for i in range(len(stack))]\n"}
{"task_id": "python/14", "content": "\nThis is the expected output for the above sample:\n\n[[2,7],[3,5],[5,3]]\n\n\"\"\"\n\n\nclass Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        prime = [0] * (n + 1)\n        prime[0] = 1\n        prime[1] = 1  # start\n        for x in range(2, n + 1):\n            if prime[x] == 1:\n                i = x\n                while x * i <= n:\n                    if prime[x * i] == 1:\n                        prime[x * i] = 0\n                    i += 1\n        result = []\n        for x in range(2, ((n // 2) + 1)):\n            if prime[x] == 0 and prime[n - x] == 0:\n                result.append([x, n - x])\n        return result  # end\n\n\n\"\"\"\nExample 2:\nInput:\n 6\nOutput:\n [2,4]\n\"\"\"\n\n\n\"\"\"\nExample 3:\nInput:\n 10\nOutput:\n [3,7]\n\"\"\"\n\n\"\"\"\nExample 4:\nInput:\n 100\nOutput:\n [3,97]\n\"\"\"", "groundtruth": "class Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        prime=[0]*(n+1)\n        prime[0]=1\n        prime[1]=1\n        for x in range(2,n+1):\n            if prime[x]==0:\n                i=x\n                while x*i<=n:\n                    if prime[x*i]==0:\n                        prime[x*i]=1\n                    i+=1\n        result=[]\n        for x in range(2,((n//2)+1)):\n            if prime[x]==0 and prime[n-x]==0:\n                result.append([x,n-x])\n        return result\n"}
{"task_id": "python/15", "content": "\"\"\"\n\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        ### Add first 2 nums to map, check for gap\n        indices = {}\n        total = 0\n        prev = 0\n        indices[nums[0]] = 0\n        for i in range(1, len(nums)):\n            curSum = prev\n            below_index = indices[nums[i]-1] if nums[i]-1 in indices else -1\n            above_index = indices[nums[i]+1] if nums[i]+1 in indices else -1\n            cur_index = indices[nums[i]] if nums[i] in indices else -1\n            soonest_zero_imbalance = max(min(below_index, above_index), cur_index)\n            if soonest_zero_imbalance == -1:\n                curSum += i\n            else:\n                curSum -= i - soonest_zero_imbalance + 1\n            if below_index != -1 and above_index != -1 and min(below_index, above_index) > cur_index:\n                curSum += min(below_index, above_index) - 1\n                if cur_index != -1:\n                    curSum += cur_index + 1\n            total += curSum\n            prev = curSum \n            indices[nums[i]] = i\n        return total\n\n### Testing", "groundtruth": "class Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        ### Add first 2 nums to map, check for gap\n        indices = {}\n        total = 0\n        prev = 0\n        indices[nums[0]] = 0\n        for i in range(1, len(nums)):  # start\n            curSum = prev\n            below_index = indices[nums[i]-1] if nums[i]-1 in indices else -1\n            above_index = indices[nums[i]+1] if nums[i]+1 in indices else -1\n            cur_index = indices[nums[i]] if nums[i] in indices else -1\n            soonest_zero_imbalance = max(max(below_index, above_index), cur_index)\n            if soonest_zero_imbalance == -1:\n                curSum += i\n            else:\n                curSum += i - soonest_zero_imbalance - 1\n            if below_index != -1 and above_index != -1 and min(below_index, above_index) > cur_index:\n                curSum -= min(below_index, above_index) + 1\n                if cur_index != -1:\n                    curSum += cur_index + 1\n            total += curSum  # end\n            prev = curSum \n            indices[nums[i]] = i\n        return total\n"}
{"task_id": "python/16", "content": "\"\"\"\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        n = len(usageLimits)\n        count = [0] * (n+1)\n        for i in range(n):\n            count[min(usageLimits[i], n)] += 1\n        ans = 0\n        needMore = 0\n        j = n\n        stack = []  # start\n        for i in range(n):\n            ans -= 1\n            needMore += 1\n            while j > 1 and count[j] < needMore:\n                if count[j] > 0:\n                    stack.append((j+ans-1, count[j]))\n                needMore -= count[j]\n                count[j] = 0\n                j -= 1\n            if count[j] < needMore:\n                ans += 1\n                break\n            count[j-1] -= needMore\n            count[j] += needMore\n            while stack and stack[-1][0] - ans == j:\n                count[j] += stack[-1][1]\n                needMore += stack[-1][1]  # end\n                stack.pop()\n        return ans", "groundtruth": "class Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        n = len(usageLimits)\n        count = [0] * (n+1)\n        for i in range(n):\n            count[min(usageLimits[i], n)] += 1\n        ans = 0\n        needMore = 0\n        j = n\n        stack = []\n        for i in range(n):\n            ans += 1\n            needMore += 1\n            while j > 1 and count[j] < needMore:\n                if count[j] > 0:\n                    stack.append((j+ans-1, count[j]))\n                needMore -= count[j]\n                count[j] = 0\n                j -= 1\n            if count[j] < needMore:\n                ans -= 1\n                break\n            count[j-1] += needMore\n            count[j] -= needMore\n            while stack and stack[-1][0] - ans == j:\n                count[j] += stack[-1][1]\n                needMore += stack[-1][1]\n                stack.pop()\n        return ans\n"}
{"task_id": "python/17", "content": "\nExample1\nInput:\n[\n-1,0,0,0,0\n]\n\"aacab\"\nOutput:\n1\nExplanation:\n- the palindrome path is \"aacab\" \nExample2\nInput:\n[\n-1,0,0,1\n]\n\"aabb\"\nOutput:\n3\nExplanation:\n- the palindrome path is \"abab\" or \"aabba\" or \"ababa\"\n\n\"\"\"\n\n\n\nfrom collections import defaultdict\n\nclass Solution:\n    def countPalindromePaths(self, parent, s):\n        n = len(parent)\n        edges = defaultdict(list)\n        amnts = defaultdict(int)\n        res = 0\n        \n        for u, v in enumerate(parent):\n            edges[v].append(u)\n\n        def dfs(curr, mask):\n            for i in range(26):\n                new_mask = mask\n                res += amnts[new_mask]\n            res += amnts[mask]\n            amnts[mask] += 1\n            for i in edges[curr]:\n                idx = ord(s[i]) - ord('a')\n                dfs(i, mask)\n        \n        dfs(0, 0)\n        return res\n\n# 210221\n\n\"\"\"\n\n# You are given an integer n. We say that two integers x and y form a prime number pair if:\n# 1 <= x <= y <= n\n# x + y == n\n# x and y are prime numbers\n# Return the 2D sorted list of prime number pairs [xi, yi] of positive integers on the interval [1, n]. \n# The list should be sorted in ascending order of x. If there are no prime number pairs at all, return an empty array.\n# Note: A prime number is a natural number greater than 1 with only two factors, itself and 1.\n# Constraints:\n# 1 <= n <= 10^6\n\nfrom collections import defaultdict\nfrom math import sqrt\n\nclass Solution:\n    def primePairs(self, n):\n        if n < 5", "groundtruth": "from collections import defaultdict\n\nclass Solution:\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n        n = len(parent)\n        edges = defaultdict(list)\n        amnts = defaultdict(int)\n        self.res = 0\n        \n        for u, v in enumerate(parent):\n            edges[v].append(u)\n\n        def dfs(curr, mask):\n            # print(curr, format(mask, '08b'))\n            for i in range(26):\n                new_mask = mask ^ (1 << i)\n                self.res += amnts[new_mask]\n            self.res += amnts[mask]\n            amnts[mask] += 1\n            for i in edges[curr]:\n                idx = ord(s[i]) - ord('a')\n                dfs(i, mask ^ (1 << idx))\n            \n        dfs(0, 0)\n        return self.res\n"}
{"task_id": "python/18", "content": "\n\n'''\n\n\n\n\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        low = \"0\"*(len(high)-len(low)) + low\n        mod = 10**9 + 7\n        \n        @lru_cache(None)\n        def dfs(i,is_greater_thn_low,is_less_thn_high,prev_digit,nonzero):\n            if i == len(high):\n                return 1\n            \n            total = 0\n            \n            start = int(low[i]) if not is_greater_thn_low else 0\n            end = int(high[i]) + 1 if not is_less_thn_high else 10\n            \n            for nx_digit in range(start,end):\n                if not nonzero or abs(prev_digit - nx_digit) == 1:\n                    total += dfs(i+1,is_greater_thn_low or nx_digit > int(low[i]),is_less_thn_high,nx_digit,nonzero)\n                    \n            return total%mod\n        \n        return dfs(0, False, False, -1, False)", "groundtruth": "class Solution:\n    def countSteppingNumbers(self, low, high):\n        low = \"0\"*(len(high)-len(low)) + low\n        \n        mod = 10**9 + 7\n        \n        @lru_cache(None)\n        def dfs(i,is_greater_thn_low,is_less_thn_high,prev_digit,nonzero):\n            if i == len(high):\n                return 1\n            \n            total = 0\n            \n            start = int(low[i]) if not is_greater_thn_low else 0\n            end = int(high[i]) + 1 if not is_less_thn_high else 10\n            \n            for nx_digit in range(start,end):\n                if not nonzero or abs(prev_digit - nx_digit) == 1:\n                    total += dfs(i+1,is_greater_thn_low or nx_digit > int(low[i]),is_less_thn_high or nx_digit < int(high[i]),nx_digit,nonzero or nx_digit != 0)\n                    \n            return total%mod\n\n        return dfs(0, False, False, -1, False)\n"}
{"task_id": "python/19", "content": "Sample 1:\nInput: n = 192\nOutput: true\nExplanation:\nThe resulting number is 192384576 and it contains all digits from 1 to 9 exactly once.\nSample 2:\nInput: n = 100\nOutput: false\nExplanation:\nWe append 2 * 100 to get 100200 and append 3 * 100 to get 100300. The resulting number is 100200300 which does not satisfy any of the conditions.\nSample 3:\nInput: n = 891\nOutput: true\nExplanation:\nThe resulting number is 891273645 and it contains all digits from 1 to 9 exactly once.\n\nAnswer:\n\n\nclass Solution:\n    def isFascinating(self, n: int) -> bool:\n        concatenated = str(n) + str(2 * n) + str(3 * n)\n\n        if '0' in concatenated:\n            return False\n        if len(concatenated) > 9:\n            return False\n        for i in range(1, 10):\n            if str(i) not in concatenated:\n                return False\n        return True\n\nprint(Solution().isFascinating(100))", "groundtruth": "class Solution:\n    def isFascinating(self, n: int) -> bool:\n        concatenated = str(n) + str(2 * n) + str(3 * n)\n\n        if '0' in concatenated:\n            return False\n        if len(concatenated)>9:\n            return False\n        for i in range(1,10):\n            if str(i) not in concatenated :\n                return False\n        return True\\n\n"}